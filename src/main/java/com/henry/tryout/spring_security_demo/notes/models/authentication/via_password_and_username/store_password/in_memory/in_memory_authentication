基于内存的身份认证

Spring Security提供的支持 - InMemoryUserDetailsManager
作用：管理 UserDetails(核心的用户信息)

InMemoryUserDetailsManager Java Configurations
代码示例：使用 Spring Boot CLI 来编码一个password的值，并获取到 编码后的password；
    @Bean
    public UserDetailsService users() {
    	UserDetails user = User.builder()
    		.username("user")
    		.password("{bcrypt}$2a$10$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW")
    		.roles("USER")
    		.build();
    	UserDetails admin = User.builder()
    		.username("admin")
    		.password("{bcrypt}$2a$10$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW")
    		.roles("USER", "ADMIN")
    		.build();
        // 这里显式地声明 使用的是 内存中的验证方式
    	return new InMemoryUserDetailsManager(user, admin);
    }

在下面的示例中，我们使用 User.withDefaultPasswordEncoder 以确保 存储在内存中的密码受到保护。
但是，它不能防止 通过反编译源代码 来 获取密码。
因此，User.withDefaultPasswordEncoder应该只用于“入门”，而不是用于生产。
代码示例：
    @Bean
    public UserDetailsService users() {
    	// 👇 The builder will ensure the passwords are encoded before saving in memory
    	UserBuilder users = User.withDefaultPasswordEncoder();

    	UserDetails user = users
    		.username("user")
    		.password("password")
    		.roles("USER")
    		.build();
    	UserDetails admin = users
    		.username("admin")
    		.password("password")
    		.roles("USER", "ADMIN")
    		.build();
    	return new InMemoryUserDetailsManager(user, admin);
    }

在 XML形式的配置中，使用 User.withDefaultPasswordEncoder:
略