DeferredResult 比较灵活 我们经常用它处理 “依赖第三方服务的耗时业务逻辑”。

比如我们在使用“转转内部效率平台Beetle”时，开发功能需要新建分支，
新建分支所涉及的服务较多如 tapd、gitlab、jenkins，

假如需要DeferredResult 来 解耦，可能流程如下：
#1 开发者发起新建分支请求，请求新建分支接口，“接口返回值”是DeferredResult；
#2 首先创建分支信息；
#3 往“新建分支队列”里面发送一个新建请求消息，同时保存 “要返回的 DeferredResult 实例”；
#4 “资源创建服务” 监听 “新建分支请求队列”，收到消息后，根据“分支类型及其配置” 来 创建和申请资源；
#5 操作成功之后，“资源创建服务” 将操作结果 广播发送到 “新建分支响应队列”，使得每个集群实例都能收到消息；
#6 beetle服务监听 “新建分支响应队列”，收到结果更新数据，取出第三步中保存的 DeferredResult，然后setResult。
#7 用户收到响应，新建分支结束，开始coding

代码示例：usage_05

如果是单体架构可以不使用消息中间件，可以直接用java队列即可。
多实例也可以使用redis作为消息中间件，redis更为轻量。具体可以参考下面的方案:
    利用redis的发布订阅功能，实例可以构造一个有相同前缀的队列ID，
        比如createbranch-request-084Tkjfh和createbranch-response-084Tkjfh,
    然后消费方根据createbranch-request这个前缀 来 获取到相关队列列表，
    消费消息后根据队列命名规则 将结果塞到对应的响应队列createbranch-response-084Tkjfh中 由请求方消费。
    其中还需要考虑资源的竞争，以及重复消费的问题，需要做好幂等。

== 方案比较 ==
假如我们不使用deferredResult，则可能需要前端设置一个定时任务 来 轮询后端接口，查询分支状态 进而确定操作的完成状态。

假设操作完成时间为20秒，前端每两秒查询一下后端接口，那么用户感知到操作完成需要22秒，
特征：这种处理方式随着操作完成时间的延长，或者轮询间隔的缩短，后端需要响应的次数愈多，服务也会有压力，并且响应结果的延迟是不可避免。
deferredResult则给我们提供了一种更优雅的实现方式。

