在SQL中，一切都是一个表
甚至包括 select的结果
因此 你可以基于 其他查询的结果 进行查询
是时候进入“子查询”的世界了

在编写查询的时候，你将表放在from子句中
由于select语句返回一张表 ，因此 你可以 使用查询 来 替换物理表
这种做法 称为 “内联视图”
这使你 能够把查询分解成为 更小的部分，然后 把它们重新组合起来
这种做法 使得 编写复杂的查询 更加容易

例如，假设你有一张 满是积木块的桌子 和 一本使用这些积木制作的模型书
这本书会告诉你 制作每个模型 所需要的每种颜色和形状的积木数量
你想要知道 你手头的积木 足已完成 哪些设计
为了做到这一点，你需要做三件事
首先，你需要计算每种颜色和形状的积木数量
然后，将其与每种模型所需的每种类型的积木数量 进行比较
最后 你需要确保你拥有 每种设计所需要的 所有不同颜色和形状

首先，你需要按照颜色和形状 对积木进行分组，以便你对它们进行计数
然后 你需要按照模型分组，这样你就能检查你是否拥有 制作它们 所需要的 所有不同类型的积木

尝试在标准SQL中 使用联结和分组 来 执行此操作，是非常棘手的
使用“内联视图” 使它变得更容易。

要做到这一点，首先按照颜色和形状 来 对你的积木 进行分组，
然后 围绕它 写另外一个查询，看看 你有哪些颜色和形状 适合哪些模型，
然后把它放在 另一个内嵌视图中 以确保 你有每个设计 所需要的 所有不同颜色和形状的积木

此时，你可能会认为 这看起来并不容易
要理解SQL，你必须 从内到外工作
这非常棘手，特别是 如果作者的缩进 出现错误
幸运的是，有更好的办法 - 使用“with子句”（也称为 “公共表表达式” 或者 “子查询分解”）

你可以命名子查询，然后你可以
像访问普通表一样 来 访问它们，
它出现在 select的上方，使你能够 使用有意义的名称 来 构建子查询
因此 你可以将前一个查询 分解为 三个独立的单元

首先，计算 每种类型的积木数量
然后 将其与每种模型所需要的积木 相联结，
最后 检查哪些设计 具有所需要的 每种类型的积木

这样 不仅便于 后继编写和理解，同时也便于调试
验证 内联视图时，你很难确定 需要运行查询的哪些部分
而使用with子句时，只需要 把底部的最终select  更改为 要测试的子查询的名称
这样就可以 用子查询来替换表

你也可以在where子句中 联结两个子查询，
这样做的经典示例是
当你想要查找 与取值列表相匹配的任何行 时

假设你想要找到 所有黄色、绿色和蓝色的积木，
你可以使用“in关键字”，并手动写出 所有这些值，但是 这样做很容易出错，
特别是 当你想要包含这些颜色的 所有不同深浅度时，
如果颜色 有数千种色调，你可能会 遇到另一个问题 - 在Oracle数据库中，in具有1000个值的上限

幸运的是，你可以通过把颜色存储在另一张表中 来 克服这个问题

现在，我们不再写出所有颜色，而是 使用颜色表上的查询 来 替代in列表，
与手写列表不同，这张颜色表 可以具有任意数量的值
或者 你可以 将in替换成为exists，
当“颜色查询” 返回至少一行时，它会为你提供所有积木

这导致了 in 和 exists 之间的重要区别
使用in 你可以查询 颜色表，你只会得到 匹配成功的积木块，而不必联结它们。
但是使用exists时，只要颜色表中至少有一行，你就会得到 每种颜色的所有积木
要修复它 并 仅获取 颜色表中的积木颜色，你需要 在子查询中联结这些表

当你的子查询 与像这样的父查询中的表 进行联结时，它被称为 “相关子查询”。
如果不是与父查询中的表 进行联结，则把它称作 不相关。
这个联结 很容易被忽视，所以仔细检查你的子查询 来 避免获取到不需要的数据

你可能陷入的另一个陷阱时 从错误的表中选择一列
例如，假设在积木表中的颜色列 被称为color，
而颜色表中的颜色列 别称为color name。

如果在子查询中 选择color，那么 虽然不太明显，但你其实 只是在检查列是否等于其自身。
select * from bricks
where color in (
    select color
    from colors
)
结果当然是true，这样会返回所有的积木

要避免这种情况，请确保 使用表名 限定所有的列。
但这样的话，如果表名很长，这么做会非常乏味。
幸运的是，你可以通过 使用别名 来 节省一些打字的时间
别名 位于表名之后，在任何引用列之前。

因此，为了确保 使用在SQL中访问正确的表，我强烈建议你 始终使用表的别名。

但只要你联结正确，in与exist 就会返回相同的结果。

你也可以反过来使用它们，如果想要找到 一个表中 所有在另一个表中不存在的行，
手段就是 将NOT放在它们前面

但有一个重要的问题：如果子查询所返回的任何行 为空，即使只有一个null，
那么 在使用not in的时候，整个表达式的结果 是未知的，因此 数据库不会返回它
因此，如果可能存在null的话，你必须使用not exists。

我们已经研究了 from和where子句中的子查询，但是我们还需要讨论另一种类型的子查询：“标量子查询”。

它就像普通的子查询，但是它有一些特殊的属性
它最多可以返回 一行和一列，
这使你可以在 具有一列的大多数地方 使用它们，比如你的select子句

Oracle数据库的某些特性，比如 标量子查询分解，
在某些情况下 可以使它们 比起联结 更快。

到目前为止，我们只是讨论了select，
但是你也可以 在插入、更新和删除中 使用子查询
比如，insert的values子句中 就可以使用子查询，update与delete的where子句

而且，如果你真的很喜欢冒险，你也可以 更新或者删除 子查询。
但是为了做到这一点，你想要更改的行 必须是 “键保留”的。
也就是说，它们在你的结果集中 只出现一次，并且 带有适当的约束来保证这一点。

我们已经看到子查询是一种强大的技术，它有很多的应用。
而且，正如我们在后面的课程中会看到的，它们 不仅使你的SQL更加容易阅读、编写和调试
它们对于获取到 正确的结果 也至关重要。

谢谢观看，希望你喜欢今天的内容，更重要的是，你能学习到一些东西。