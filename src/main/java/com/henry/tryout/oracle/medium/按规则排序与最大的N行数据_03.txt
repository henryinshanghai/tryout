当从表中选择行时，数据库可以按照任意顺序返回它们
但是 如果你只想看到 三个最重的玩具、最吵的玩具、最好抱抱的玩具的话，这样就不好用了

要做到这一点，你需要使用 order by

当你从表中获取数据的时候，数据库 将会 按照从磁盘读取到它们的顺序 来返回它们
这种物理顺序 很少改变，因此 导致了一个常见的初学者陷阱：
认为你的SQL不需要 order by，但这是一个巨大的错误

为了弄清原因，让我们先往表中添加一些行，
如果这是一个“堆表”，数据库可以将它们添加到 任何有空间的地方，这通常在表的末尾
因此，如果要添加的值 总是增加，就像是 ID或者 插入日期一样，
那么 插入它们的顺序 与 逻辑顺序 一致。
因此 在查询它们的时候，它们 会以正确的顺序出现
这只是一个巧合

为了了解原因，让我们从表中删除第一行
现在，当我们插入下一行的时候，由于我们在表的开头释放了一些空间，因此 新行就会被放在这里
现在，当我们读取这些值的时候，它们的顺序就乱了

为了避免这种情况，你需要在SQL中添加一个order by，它将会出现在 查询的末尾
列出 你想要排序的列，然后
对于数字，它将结果 从最小到最大排序
对于日期，它将结果从最老到最新排序
对于字符串，它将结果 按字母顺序排序

如果要按照相反的方式排序，比如从大到小
可以在列后面 添加降序关键字 desc
但是我们的老朋友null呢? 它会在我们的序列中 出现在什么地方呢?
默认情况下 它在所有其他值之后排序，因此 包含空值的行 出现在数据集中的最末位置
但是 你可以使用 nulls子句 来 控制它，将这些设置为 nulls first，
这样 null值的行 将会出现在 数据集的前端

所以 如果你想要 总是按照增加或者减少的值 进行排序的话，排序其实很容易
但是 如果你想要一个自定义的序列，假设 你想要按照颜色 对你的积木进行排序
但不是按照字母顺序 blue, green, red，你想要一个不同的顺序
你希望 先是绿色，然后是红色，最后是蓝色
为了做到这一点，你需要一个函数 来 把颜色映射到 按照正确顺序排列的值，
这样 你就可以 把绿色映射为1，把红色映射为2，然后把蓝色映射为3，
把它放在你的order by中，然后 你就会得到 正确顺序的值。
这么做相当容易，但是如果你有 复杂的排序逻辑，那么 检查映射是否正确 可能会很麻烦

为此，把执行映射的函数放入到你的select语句中
这可以很容易地 查看行的位置上是否具有正确的值，
但是现在你的函数 存在于两处，这可能会导致维护问题

为了克服这个问题，在select中 给函数一个别名，
然后你可以在你的order by中使用这个别名，所以 这个函数只在一个地方。

或者如果你真的很懒，你可以使用 位置表示法，
你写上一个数字，而不是列的别名。这个数字 对应于 select中的列位置，从上到下。
虽然这很容易，但它会使你的代码 容易出错。
如果你更改了 select中的列，但没有同步改动你的order by，
最终结果 可能会按照 不是预期的列 进行排序，从而得到 错误的结果。

在生产系统的SQL 应该避免 这种情况。

正如我们在开始时 看到的那样，通常 在从表中获取行时，
你只需要前几个最新、最便宜、最可爱的几项，而不是整个表。
要做到这一点，首先 你需要对你的行 进行排序，然后 当你得到 你想要的数量时 停止获取。
但你要怎么知道 要在哪里停下来呢?

为了做到这一点，首先 你需要为每一行分配一个 与你的排序相匹配的数字，
然后是一个where子句，用于检查 该数字是否小于 你想要的行数。
Oracle数据库中有一个 叫做rownum的内置函数，它为 每个新行执行此操作，也就是 计数增加1.
所以 很多人 会在他们的where子句中 插入此函数，比如 检查它是否是小于3 或者 其他任何合适的值的。

select *
from toys
where rownum <= 3
order by cuddliness_factor

但当他们得到错误的结果时，他们会觉得很惊讶。为什么会这样呢？
因为 它的处理方式是错误的，上面写法在做的是 获取任意三行，然后 再对他们进行排序。
而不是 相反的顺序

要解决这个问题，你需要使用 子查询。
对此处的数据 进行排序，然后 在外部查询中 基于rownum进行过滤，
select *
from (
    select t.*
    from toys t
    order by cuddliness_factor
)
where rownum <= 3

或者 你可以使用 分析函数 row_number.
select t.*,
    row_number() over(order by cuddliness_factor) rn
from toys t;
它为每一行分配一个 递增的数字，具体数字 有over子句中的order by确定，
然后 你可以在外部查询中 过滤此结果。

这样做虽然有效，但是有些笨重。
幸运的是，在Oracle Database 12c中 就容易多了，在12c中 添加了 符合ANSI标准的 fetch first语句。
它出现在你的order by之后, 并说明要获取多少行
select t.*
from toys t
order by cuddliness_factor
fetch first 3 rows only;

这种写法 更加清楚地 说明了要执行的操作，并且 不需要任何的子查询。

对于排名前N位的查询，你还需要注意一件事：当对 不唯一的值 进行排序的时候。
假设你想要 这个表中 按颜色排列的前三个数字，由于每个颜色都有几个item，这就带来了第一个问题：
你想要的是前三行 还是 你想要 所有行中前三种不同的颜色。

如果你想要的是 所有行中的前三种颜色，那你就不能使用 fetch first了，
这是因为 你事先并不确定 会有多少行。

所以要做到这一点，你必须 仍旧使用子查询。
你需要为每一种颜色 分配唯一的值，而不是 为每一行分配一个唯一的值。
你可以使用 dense_rank 来 实现这一目标。

但更常见的是 你想要三行，这就带来了不同的问题。
表中的第三行和第四行 是相同的颜色，因此查询结果 是不确定的。
这意味着 如果你多次运行查询，每次运行 可能会得到不同的结果 - 这不是一件好事。

为了避免这种情况，你可以在order by中添加更多的列，
数据库首先使用 最左边的列进行排序，然后使用第二列再进行排序...
所以 添加你所需要的任何列 来 使得你的排序结果唯一。
select *
from numbers
order by colour, number_value;

以上就是 如何对数据进行排序，并获取前N行的快速概述。
许多数据库都有自己的查询前N行数据的语法

记住，如果你想要 按照特定顺序输出，你必须使用order by