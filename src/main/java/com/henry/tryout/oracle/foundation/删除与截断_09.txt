不管是不需要的破烂，还是太旧的东西
通常都有你想要从桌子上清除的垃圾，是时候删除了

顾名思义
删除事物 会从表中删除 与where子句相匹配的信息。
一旦提交，数据就消失了
所以 要特别注意 你的where子句
否则你可能会发现 自己丢失了 一些重要的信息

但有时候 你的确想要进行批量删除，
不管是 不再相关的 临时数据
还是 你正在存档的历史数据
有时候 你的确希望 清除所有内容

没有where子句的删除 可以完成这项工作
但这可能会需要很长时间，
特别是 当你的表存储了 大量数据时

幸运的是，有一种更快的方法：truncate
它会立即 重置你的表，将其 标记为空

但这样做会有两大问题：
首先，它总是会 删除所有内容
你不能做到 有选择地truncate

其次 truncate会提交，
因此 即使你改变了主意，不想要再删除，你也无法再取回数据。

许多人 不喜欢 删除数据，
想要掌握一些东西 是人类的天性，但也有实际的原因 不允许这样去做。
如果人们 可以删除 他们想要的任何内容，
那么 如果他们做得不好，他们就可以掩盖自己的行踪
所以 很多应用程序 使用 软删除

这意味着 数据仍旧保存在数据表中，你只需要
通过设置“已删除”标志 来 表示行已经被删除
这样的话，如果你误删除了错误的内容，就能够轻松恢复数据。

或者，如果有人一直试图掩盖他们的踪迹，
你仍然 可以看到 他们认为 已删除的内容

如果你进行软删除的话，你需要确保 你的查询进返回 活跃的行，
这意味着 向所有查询都添加 where子句。
但这既乏味 又容易忘记

幸运的是 有几种方法可以简化这一点
最通用的方法是 在表上创建一个视图，这个视图 包含 只会返回活跃的行 的where子句
然后更改你的应用程序，使它 只使用视图，而不是 基础表本身
这很容易，但也很粗糙

例如，可能有超级用户 确实有权限 来 删除数据 或者 需要查看 被软删除的行
这会是你的代码复杂化，因为
你现在会需要根据具体用户 来 在视图和表之间进行选择

幸运的是，如果你是用的是 Oracle数据库，还有一个 更强大的选项 可用 - 虚拟专用数据库
它可以根据 用户等条件 来 自动地向查询添加where子句，
这种行为 对你的应用程序 是透明的，因此 一旦配置完成，你就可以忘掉这些了

或者你可以使用 Oracle的另外一个数据库特性：数据库内归档
它会 向表中添加一个 隐藏列 来 控制行是否可见
像 经典的软删除一样，你可以通过更新 来 设置它（set ora_archive_state）
然后数据库 会自动对你隐藏 已经被删除的行，
但是 由于它们仍然存在，你可以 通过切换会话设置 来 使他们可见(alter session set row archival visibility = all)

有关数据库内归档 与 虚拟专用数据库的详细信息
请查看描述中的链接

请记住 软删除 会增加应用程序的复杂性，
在盲目地继续这么做之前，先问问自己
是否真的有必要 保留所有东西。

通常，你真正的要求 不是防止删除，
而是为了知道 谁删除了什么 以及 什么时候删除的。
这些功能 你可以通过审计来实现 - 而审计不管怎样 你都应该去做。

这样，如果确实发生了意想不到的事情，你可以追踪线索 并 找到肇事者(perpetrators)