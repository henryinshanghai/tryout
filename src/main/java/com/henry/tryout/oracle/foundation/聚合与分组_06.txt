我想要造一道彩虹，但我不确定我是否有足够多的 每种颜色的积木
为了检查 我是否能通过 选择所有的红色积木 数一数它有多少块
然后用橙色、黄色 等重复这个步骤
但这么做很乏味
幸运的是 SQL可以为你做到这一切 - 欢迎进入聚合的世界

聚合函数计算 来自多行的值 并 输出单行，
这些使你能够执行以下操作：
告诉你有多少行
查找列中的最小值和最大值
或者所有值的总和

大多数聚合都接受列作为参数，不过ANSI稍微有点特别
你可以把一列传递给它，它会为你提供该列中 非空值的数量，
或者，为了确保获得总行数 请使用星号。

它们还允许你使用关键字 DISTINCT 作为列的前缀
它首先会过滤你的数据集 来 查找列中不同的值，
完成操作后，它会将函数 应用于 这些值的一个实例。

比如，我这里有4块积木(红色*2 蓝色*2)，我们数一数，一共是4块。
另外，如果我们数一数颜色，那也是4??
但是只有两种不同的颜色，所以如果我们计算 不同的颜色，我们只会得到两种
同样地，这两块积木的尺寸和重量相同，
所以如果我们要计算 这些积木的不同重量的数量，我们实际上只能得到3个。

count, sum, min和max是我们最常使用的一些聚合函数，
但是Oracle数据库中 还有更多函数 可用于聚合数据。
如果需要完整列表，请查看说明中的链接。
或者如果这些 没能够涵盖你的特殊需求，你也可以自己编写。

所以 为了检查我有多少块积木，我可以运行count，
这给了我 积木的总数
如果我需要每种颜色的数量，
我可以为每种颜色 都运行一个单独的查询 来 找出每种颜色各自有多少块积木。
但这需要很多的工作

幸好有更快捷的方法，
你可以使用 group by 来 在单个查询中 获取每一个分组的总数
它会根据 group by列中的值 来 拆分结果，对于其中每一个不同的值，你都会在输出中 获得一行。
因此，按照颜色计算分组，将会为你提供每种颜色积木的数量

你可以根据需要 按任意数量的列 或 表达式 进行分组，
这样做会进一步细分你的结果，给出表中 每组值的总数。

这很棒，因为我可以检查 我是否有 足够的形状和颜色都正确的积木 来 造出我的彩虹。
但是如果你想要知道 每种颜色 有多少块积木，而不管颜色如何，你就会有问题了

你可以手动计算它们，也可以运行单独的查询 来 得到颜色的数量，
再一次，可以使用SQL中的roll up 来解决。
你把它放在 group by中，然后把你的列 放在里面，
然后计算小计，从右到左 通过列计算，
如果所有分组列 都在你的roll up中，它还会提供 总计。

如果你想要 group by中每一列的小计，请改用cube。
分组时，select中的列 必须或者在group by子句中，
或者 应用了聚合函数。

但反过来就不是这样了
你可以使用 不在select中的列 进行分组，
这可能会令人困惑。
因此大多数情况下，把你的group by子句中的列 复制到 select中

现在，我已经按照颜色 对我的积木 进行了分组，
但我仍旧不确定 我是否有 足够数量的积木 来 构建我的彩虹。
每种颜色 都需要至少10块 才能构建我的彩虹。

为了确保我们有足够的数量，你可能想在 where子句中 进行这种过滤，
但是数据库 是在where子句之后 对行进行分组的，
因此 这么做并不管用。

你需要使用的是 having子句，这将使用聚合函数的结果 来 过滤数据。
想要查看每种颜色的数量 是否足够，在sql中加上 having count(*) >= 10

在我们结束之前，重要的是 记住分组和聚合 会减少输出中的行。
但有时候 你希望看到 所有的表数据和计数
你可以通过添加 over子句 来 把聚合转换为分析函数，以实现这一点。
但是 改天再说它吧

我们已经研究了 如何从表中选择、联结和聚合数据
但是如果表为空，这些操作就不好使了

我们将在下一集中介绍 如何添加数据