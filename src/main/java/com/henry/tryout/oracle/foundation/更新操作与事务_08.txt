我这里有很多的红色玩具，但是我更喜欢蓝色
如果我们能够像变魔术一样 改变颜色就好了

在数据库中，你可以通过update 来 实现这一点

更新语句会覆盖表中的现有值。
为了实现这一点，请使用set子句 来 指定每一列及其新值
你可以根据需要 对表格中的任意多列 执行此操作
但请记住包含一个where子句，否则 你会更新表中的每一行

忘记where子句 会产生一些问题。
首先，把所有东西都设置成相同的值 是非常少见的。
其次，更新整张表需要一些时间，特别是当表很大的时候
这还会带来第三个问题：一次只有一个人 可以更改一行

一旦你开始更新，其他人 就无法更改你的SQL所影响的行
即使他们想要更改不同列中的值，他们也必须等到你完成。
所谓完成，指的是commit

如果由于某种原因，你忘记了执行commit，那么
其他想要更改这些行的人 仍然需要等待 - 这会很快使数据库停止运行。
所以为了避免这种情况，你需要在每次更新后执行commit

对吗？别着急
有时候，你想要同时更改多个表或者行，
重要的是 要么所有的变化都发生，要么 什么都不发生

比如说 我欠你一笔钱，我终于有时间还给你了
当我从我的钱包中取出钱时，我们需要更新它 来 减少剩余的现金
然后 当你拿到钱时，运行另一个更新 来 增加你钱包中的金额
如果我们立即把更改提交给每个钱包，最终可能会是 一团糟

比如说，在 从我的钱包里掏钱 和 把钱添加到你的钱包 之间 发生了一场灾难，
所以我们无法完成转移
如果在我们将更改提交之后 发生了这种情况，我们都得不到这笔钱。
为了确保不会发生这种情况，我们要确保 要么同时更新两个钱包，要么都不更新
这就是“事务”的概念  - 也就是 使我们的数据 处于一致状态的最小工作单元。

通过在更新两个钱包后再提交更改，你完成了这笔事务。
不再像以前那样，否则 每个人都可能身无分文。

通常你的事务会插入或者更新多个表，
如果你有影响相同表的不同事务，那么 你需要注意确保避免死锁。

== 死锁 ==
当两个人各自持有一个资源，然后他们都想要 获得另一个人所拥有的资源时，
就会发生死锁。
两者都不准备 放弃他们所拥有的，但是直到他们从对方那里得到了资源，他们也无法继续。
这就是“死锁”现象。

Oracle数据库自动检测死锁 并 强制一个会话停止请求另一项资源，并抛出异常。
这是解决问题的极端方法，你需要编写代码 来 处理异常，否则 会让用户感到不安

但是处理死锁的正确方法是：确保他们从一开始就不会发生。

你可以采取几个步骤来做到这一点
首先 确保你的所有交易 都是以相同的顺序 对表进行更改??
这在大型应用程序中可能 很难协调，因此 请确保与其他开发人员讨论 并 彻底测试；
其次 你可以使用 select for update,以此来 标记更改行的意图。
这样会 锁定查找到的行，直到 你的事务完成。
在开始时这样做 可以确保 在最终更新时 能够成功进行更改。

这对于影响许多表的 长时间运行事务特别有用。
这仍然会导致很多等待，但至少一切都会奏效。

关于死锁的最后说明
与某些数据库不同，在Oracle中，只有更改行时才需要锁定。
select语句永远不会阻止其他语句，除非你添加了 for update子句。

你已经避免了死锁，你还需要主义更新的另一件事情：
那就是更新是否丢失？
如今大多数应用程序都是无状态的，
这意味着从表中读取数据 并 将更改写回到数据表中 会是两个独立的事务。

如果两个人同时处理 相同的数据时，这种特性可能会导致问题。
假设张三试图关闭武器 Death Query，
而李四只是想让它看起来更漂亮。
两个人同时读取数据，张三关闭武器，并保存了她的更改。
过了几分钟，李四把它变成了一种时髦的红色 - 现在事情变得有趣了

李四发送到数据库的数据 表明 武器状态是打开的。
因此，如果你的代码 更新了 所有列，张三的更改就会丢失~~

为了避免这种情况，你需要确保 从上次读取数据以来，没有其他人 更改过数据。
你可以使用 乐观锁 来 执行此操作

有几种方法可以做到这一点
常见的方法是 为每一行添加一个版本号，
所有客户端 在获取数据时 必须将其读取出来，然后 在保存时将其传回。
然后你的更新 检查版本号 是否仍然相同：
    如果是，则 更新列 并 将版本号加1；
而在你更新之前 读取数据的任何人 仍会拥有旧的版本号 - 当他们执行保存时，什么也不会发生。
这种情况下，你需要检测和确认 更新没有做任何事情，
然后通知 你的用户其他人进行了 更改，并让用户检查 他们的更改 是否仍旧有效。

上述的过程 可以避免人们不断覆盖彼此的更新。

“死锁”和“更新丢失” 都是会导致 使用你的应用程序的人 感到非常沮丧的问题。
因此 请始终测试 当两个人同时使用你的应用程序时 会发生什么，
并进行防御性编码 来 防止这些问题。

你还需要主义在多用户环境中 删除数据的问题，
我们将会在下一集中介绍 删除数据的细节