我这个有两张表，
现在我想要 根据它们的颜色 来 把这张桌子上所有的泰迪熊
与 这张桌子上所有积木相匹配，我需要使用JOIN。

在编写select语句时，你需要把表放在FROM子句中，
你可以在这个地方放置任意多数量的数据表，
但如果仅此而已，你就会遇到问题：交叉联结

这将返回每个表中的每一行 与 每个其他表中的每一行的组合，
这也称为笛卡尔积，这样做是非常罕见的。

如果确实要这样做，最好使用 cross join的语法 来 明确说明这一点。
这样有助于 未来的开发人员知道 笛卡尔积正是你想要的。

== side note ==
注意：有两种类型的JOIN样式 - ORACLE 与 ANSI

使用oracle语法，所有联结条件 都在where子句中，
而ANSI有单独的join子句，它的where子句 则用于 非联结过滤器

哪个更好通常会引发激烈的争论，我个人更喜欢使用ANSI，
它可以清楚地表明 你的JOIN条件是什么，并且
你不太可能意外地错过JOIN

不管你喜欢哪一个，我都有一条最重要的建议：
保持一致，选择一种风格并坚持下去，否则事情会变得一团糟
== end side note==

在绝大多数情况下，你只会需要 输出彼此相关的行，
但是仍旧有几种方法 可以做到这一点，让我们分别来讲一下

最常见的联结类型是 内部联结
这只会从一张表中 返回与另一张表中存在匹配行的所有行，
如果某一行 在另一张表中不存在匹配项，，则 不会返回这一行。
但是 这并不意味着 你只能从表中 获得每一行的一个副本，
单个行仍然可以 在你的查询结果中 多次出现。
比如，我在左边的桌子上有两个绿色玩具，在右边这张桌子上有3个绿色玩具，
如果我通过颜色进行联结，那么 左边表中的每个绿色行 都会链接到  右边表中的每一个绿色行，
所以你 从左边表中 得到三份绿色行的副本，从右边表中得到 两份绿色行的副本。

如果左边表的某一行 在右边表中没有匹配项，那么这一行就不会被返回。

有时候，既是在另一张表中 没有对应匹配的项，你也想要当前表中的所有行。
为此，你需要一个外部联结。

我想要从左边表中/桌上得到所有的泰迪熊，然后，如果有的话，
从右边表中/桌上 得到相同颜色的积木。
有一些泰迪没有相同颜色的积木。

为了确保我得到所有这些 所有的泰迪熊，
我需要与积木 做外部联结。

外部联结有两种形式：左联结 和 右联结；
左联结 会返回 左边表中所有的行，
右联结 则会返回 右边表中的所有的行。

我的泰迪熊 在左边，所以我需要一个左联结。
但是如果 你想要 每张桌子上的 所有积木和泰迪熊，即使 另一张桌子上 没有匹配的颜色，
该怎么办呢?

为了做到这一点，你需要一个完整的外部联结。
它将会返回 两张表中的所有行。
但是 与笛卡尔积不同的是，每个泰迪熊 只会连接到 相同颜色的积木。
如果另一张表中 没有颜色匹配，则：泰迪熊 或者 积木 只会出现一次。

要进行完整的外部联结，你需要使用 ANSI语法
select * from tableA
full outer join tableB
on tableA.color = tableB.color;

或者用一个笨拙的变通方法
query1 union all query2

到目前为止，我们根据联结 获取了 我们可以获取的所有行，
但有时候 你想根据列 从一个或者两个表中 过滤行，
比如说 我们只想要得到 是立方体的积木，
通过内部联结，我们 只能得到 相同颜色的 立方体积木 和 泰迪熊。
但是当涉及到 外部联结的时候，你需要小心。

如果你在外部联结中加入泰迪熊，这很好，你会得到 所有的立方体积木 以及 所有颜色的泰迪熊。
但是如果你做了相反的事情，并且与积木做外部联结，那么 你如何进行过滤 就很关键了
如果是在where子句中执行过滤的话，那你的查询 会再次成为 内部联结。
想要保留外部联结，你需要 在ANSI查询的联结子句中 过滤积木。

如果你使用Oracle语法，则需要 把加号运算符 放在外联结表的所有列上。

到目前为止，我们只研究了 把两张表联结到一起，
但是你可以根据需要 联结任意数量的表，
不论你使用多少表，都要熟悉 JOIN的操作。

它们是SQL和关系模型 最强大的功能之一
