Gradle有一个丰富的API，有几种方法来创建构建逻辑。
相关的灵活性很容易导致不必要的复杂构建，通常将定制代码直接添加到构建脚本中。
在本章中，我们将介绍几个最佳实践，这些实践将帮助您开发易于使用的具有表现力和可维护的构建。

如果你感兴趣的话，第三方Gradle lint插件可以帮助你 “在构建脚本中，强制执行所需的代码风格”。

-- 避免使用命令式逻辑 --
“Gradle运行时” 并没有 为“构建逻辑”强制执行特定的样式。
由于这个原因，构建脚本很容易将： #1 声明性DSL元素 与 命令式、过程式代码 混合在一起。
让我们来讨论一些具体的例子。

#1 声明性代码: 内置的、与语言无关的DSL元素(例如Project.dependencies{}或Project.repositories{})或由插件公开的DSL
#2 命令式代码（imperative code）: 条件逻辑 或 非常复杂的任务操作实现

每个构建脚本的最终目标应该是 “只包含声明性语言元素”，使代码更容易理解和维护。
命令式逻辑应该存在于“二进制插件”中，并反过来 应用于构建脚本。
作为副产品，如果您将工件发布到 “二进制存储库” 中，您将自动使您的团队能够 “在其他项目中重用插件逻辑”。


下面的示例构建展示了 “在构建脚本中直接使用条件逻辑” 的反面例子。
虽然这个代码片段很小，但很容易想象一个使用大量过程语句的完整构建脚本，以及它对可读性和可维护性的影响。
通过将代码移动到一个类中，还可以单独对其进行测试。
-- 使用控制语句来创建一个任务 --
using_conditional_logic

让我们将 “构建脚本” 与 “二进制插件” 实现的相同逻辑进行比较。
代码乍一看可能比较复杂，但显然更像典型的应用程序代码。
这个特定的插件类 位于buildSrc目录中，这使得构建脚本可以自动使用它。
-- 实现了命令式逻辑的二进制插件 --
plugin_using_imperative_logic

现在构建逻辑已经转换为插件，您可以将其应用到构建脚本中。
构建脚本已从8行代码缩减为一行代码。
plugins {
    id 'com.enterprise.release'
}















