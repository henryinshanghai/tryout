Gradle是“基于依赖编程”的一个例子: 开发者需要定义“任务和任务之间的依赖关系”。
Gradle保证这些任务“按照它们的依赖顺序执行”。
您的“构建脚本” 和 “插件” 一起配置了此依赖关系图。
本页讨论了Gradle在“解释这些脚本”时 所经历的生命周期的各个阶段。
此外，本页还解释了如何“使用通知” 来 “对生命周期中的事件做出反应”。

=== 任务图 ===

一些构建工具会“在执行任务时来组装任务图”。
而Gradle“在执行任何任务之前”会先构建任务图。
通过“配置避免”，Gradle可以跳过 对“不属于当前构建”的任务的配置。

在每个项目中，任务形成有向无环图(DAG)。

该图显示了两个示例任务图:一个是抽象的，另一个是具体的。
图中用箭头表示任务之间的依赖关系:
xxx | ooo

build
    - check
        - test
    - assemble
        - jar
            - classes
                - compileJava
                - processResources


“插件” 和 “您自己的构建脚本” 都通过“任务依赖机制”对任务图做出贡献。

=== 构建中的各个阶段 ===
Gradle构建有三个不同的阶段。
Gradle按顺序运行这些阶段: #1 首先初始化，#2 然后配置，#3 最后执行。

#1 初始化
    # 检测设置文件（settings file）。
    # 评估设置文件，以确定“哪些项目”和“包含的构建” 会参与当前构建。
    # 为每个项目创建一个Project实例。

#2 配置
    # 评估“参与构建的每个项目”的构建脚本。
    # 为请求的任务创建任务图。

#3 执行
    按照所选“任务的依赖顺序” 来 安排并执行它们。

例子
下面的示例显示了“settings和构建文件的哪些部分” 对应于 不同的构建阶段:
settings.gradle_clip

build.gradle_clip

下面的命令“配置并执行” 上面所指定的 test 和 testBoth任务。
因为Gradle只会配置“被请求的任务和它们的依赖关系”，因此 “configured任务”其实不会被真的配置
execution_result

