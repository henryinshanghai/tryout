“程序员Carl”（代码随想录作者）提出的 动态规划五部曲 是一套非常实用、清晰的解题框架，旨在帮助初学者系统化地理解和解决动态规划（DP）问题。这套方法在 LeetCode 社区和中文算法学习者中广受欢迎。

✅ 动态规划五部曲（完整版）
这五步环环相扣，缺一不可。按顺序思考，能极大降低 DP 题目的理解难度。

==
第一步：确定 dp 数组（dp table）以及下标的含义
📌 问自己：dp[i] 到底表示什么？

① 明确 状态的定义 是 DP 的核心！
② 必须 用一句话 清晰描述 dp[i] 的物理意义。
③ 常见形式：
    1.dp[i]：以 nums[i] 结尾的……
    2.dp[i][j]：从 i 到 j 的……
    3.dp[i]：前 i 个物品中……（背包问题）

✅ 错误示例：
    “dp[i] 是最大值” → ❌ 太模糊！

✅ 正确示例（LeetCode 53 最大子序和）：
    “dp[i] 表示以 nums[i] 结尾的 连续子数组 的最大和。”

===
第二步：确定 递推公式（状态转移方程）
📌 问自己：dp[i] 怎么由 前面的状态 推导出来？

① 根据 第一步的定义，分析 当前状态 如何依赖 之前的状态。
② 通常需要考虑 多种选择（如选 or 不选、取 max/min 等）。
✅ 示例（最大子序和）：
    要么把 nums[i] 接到 前面的子数组 后面（dp[i-1] + nums[i]），
    要么 从 nums[i] 重新开始（nums[i]）。

所以：dp[i] = max(dp[i-1] + nums[i], nums[i])

===
第三步：dp 数组如何初始化
📌 问自己：哪些 dp 值是已知的？边界条件是什么？

① 初始化 必须符合 第一步的定义。
② 通常初始化 dp[0]、dp[1] 或 首行/首列（二维 DP）。
③ 注意：不要 随意初始化 为  0！要看 问题语义。

✅ 示例（最大子序和）：
    dp[0] = nums[0]（以第一个元素结尾的最大和 就是 它自己）

✅ 反例：
    若初始化 dp[0] = 0，当 nums[0] = -5 时 就错了！

===
第四步：确定遍历顺序
📌 问自己：应该从左到右？从右到左？先遍历物品还是背包？

① 一维 DP：通常从前往后（但有些题需从后往前，如完全背包 vs 01背包）
② 二维 DP：
    1.dp[i][j] 依赖于 dp[i-1][j] 和 dp[i][j-1] → 从上到下、从左到右
    2.若依赖于 dp[i+1][j-1] → 可能需要 斜着遍历 或 从下往上
✅ 关键原则：计算 dp[i] 时，它 所依赖的状态 必须 已经算好！

===
第五步：举例推导 dp 数组
📌 手动模拟 一个小例子，验证你的 dp 逻辑 是否正确

① 选一个 简单输入（如 [−2,1,−3,4]）
② 按 你的递推公式 一步步填 dp 数组
③ 看 最终结果 是否符合预期

✅ 作用：
① 暴露 逻辑漏洞（比如初始化错、递推式漏情况）
② 加深 对 状态转移 的理解
③ 面试时 可 向 面试官 展示思考过程

