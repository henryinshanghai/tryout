前缀和数组是什么？为什么要构建前缀和数组呢？

===
一、什么是前缀和数组？（Prefix Sum Array）
✅ 定义：
前缀和数组 是一个 新数组，其中 每个元素 prefix[i] 表示 原数组从第 0 项到第 i 项的累加和。

📐 数学表达：
给定原数组 w = [w₀, w₁, w₂, ..., wₙ₋₁]，

其前缀和数组 prefix 定义为：
    prefix[0] = w[0]
    prefix[1] = w[0] + w[1]
    prefix[2] = w[0] + w[1] + w[2]
    ...
    prefix[i] = w[0] + w[1] + ... + w[i]

🔢 举例：
    w = [1, 3, 2, 4]
    prefix = [1, 4, 6, 10]
    prefix[0] = 1
    prefix[1] = 1+3 = 4
    prefix[2] = 1+3+2 = 6
    prefix[3] = 1+3+2+4 = 10
💡 前缀和数组 天然 单调递增（因为 权重 都是正整数）。

===
二、为什么本题 需要 前缀和数组？
🎯 问题目标回顾：
我们 要实现 一个函数 pickIndex()，使得：
    返回 索引i 的概率 = w[i] / (w[0]+w[1]+...+w[n-1])
但 计算机 只能生成 均匀分布的随机数（比如 rand() % N）。

如何用 “均匀随机” 来模拟 “加权随机”？

✅ 核心思想：把 权重 转换成 一段段 连续的整数区间，然后“投点”。

===
三、前缀和 如何帮助我们 构建这些区间？
步骤 1：计算总权重
    total = w[0] + w[1] + ... + w[n-1] = prefix[n-1]

步骤 2：将 [0, total) 划分为 若干子区间
① 索引 0 占 w[0]个整数 → 区间 [0, w[0])
② 索引 1 占 w[1]个整数 → 区间 [w[0], w[0]+w[1])
③ 索引 2 占 w[2]个整数 → 区间 [w[0]+w[1], w[0]+w[1]+w[2])
④ ...

你会发现：
① 这些区间的右端点 正好是 前缀和数组的值！
② 区间i 的右边界 = prefix[i]
③ 区间i 的左边界 = prefix[i-1]（i=0 时为 0）


📊 示例：w = [1, 3, 2]
索引 i	权重 w[i]	对应区间（整数点）    | 右边界 = prefix[i]
    0	    1	    [0, 1) → {0}	   | 1
    1	    3	    [1, 4) → {1,2,3}   | 4
    2	    2	    [4, 6) → {4,5}	   | 6
✅ 前缀和数组 直接给出了 所有区间的分割点！

===
四、没有前缀和 会怎样？（反面论证）
假设你 不用 前缀和，每次都要 重新计算 区间：
    // ❌ 低效做法（O(n) 每次查询）
    int total = Arrays.stream(w).sum();
    int rand = random.nextInt(total);
    int cumulative = 0;
    for (int i = 0; i < w.length; i++) {
        cumulative += w[i];
        if (rand < cumulative) {
            return i;
        }
    }

① 时间复杂度：O(n) 每次调用 pickIndex()
② 如果调用 10⁵ 次，总时间 O(10⁵ × n) → 可能超时

而用 前缀和 + 二分查找：
① 初始化：O(n)
② 每次查询：O(log n)
✅ “前缀和 + 二分” = 将 查询 从 O(n) 优化到 O(log n)

===
五、前缀和在本题中的三大作用
作用	                说明
1. 编码 区间边界	    prefix[i] 就是 索引i 所对应区间的 右端点
2. 提供 单调性	    因为 w[i] > 0，所以 prefix 严格递增 → 可 二分查找
3. 支持 快速定位	    给定 随机数rand，通过二分 找 第一个 prefix[i] > rand 即可 得答案

六、总结：为什么 必须构建 前缀和数组？
因为 前缀和数组 是 连接 “权重” 与 “整数区间划分” 的桥梁。
它把 概率问题 转化为 几何问题（在数轴上 找 点 落在哪一段），并 利用 其单调性 支持高效查找。

没有它：
① 要么 无法建模 加权分布
② 要么 效率低下（线性扫描）

有了它：
① 概率映射 清晰
② 查询高效（对数时间）
③ 代码简洁可靠

💡 一句话记住：
前缀和数组 = 权重的累积刻度尺，让我们能在“概率直尺”上 精准定位 随机点 属于 哪个索引。