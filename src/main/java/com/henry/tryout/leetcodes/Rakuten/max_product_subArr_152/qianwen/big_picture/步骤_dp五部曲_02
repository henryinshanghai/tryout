LeetCode 152 - 乘积最大子数组
用「Carl的DP五部曲」系统解析

📌 五部曲框架

代码随想录（programmercarl）的动态规划解题模板
步骤   内容
1️⃣   确定dp数组及下标含义
2️⃣   确定递推公式
3️⃣   dp数组初始化
4️⃣   确定遍历顺序
5️⃣   举例推导dp数组

===
1️⃣ 确定dp数组及下标含义

本题的特殊性：需要维护两个dp数组
dp_max[i]：以 nums[i] 结尾的连续子数组的【最大乘积】
dp_min[i]：以 nums[i] 结尾的连续子数组的【最小乘积】

==
❓ 为什么需要两个数组？

关键原因：负数的存在

示例：[-2, 3, -4]
到位置1：max=3, min=-2
到位置2：min(-2) × (-4) = 8 → 变成最大值！

结论：最小值 × 负数 = 可能的最大值
      最大值 × 负数 = 可能的最小值

===
2️⃣ 确定递推公式

每个位置 i 有三种选择：
选择                      含义
nums[i]                 重新开始，只取当前元素
dp_max[i-1] * nums[i]   延续之前的最大乘积
dp_min[i-1] * nums[i]   之前的最小值 × 当前数（负负得正）

状态转移方程：
dp_max[i] = max(nums[i], dp_max[i-1] * nums[i], dp_min[i-1] * nums[i])
dp_min[i] = min(nums[i], dp_max[i-1] * nums[i], dp_min[i-1] * nums[i])

📊 决策树示意图：

                    nums[i]
               /       |     \
              /        |      \
        重新开始      延续max     延续min
           ↓           ↓               ↓
        nums[i]  dp_max[i-1nums[i]  dp_min[i-1]nums[i]
                   |        /
                   |       /
                   |      /
              max(三选一) / min(三选一)

===
3️⃣ dp数组初始化

初始状态：第一个元素
dp_max[0] = nums[0]
dp_min[0] = nums[0]

全局结果初始化
result = nums[0]

⚠️ 注意事项：
情况           处理方式
数组长度为1     直接返回 nums[0]
包含0          0会让乘积归零，但递推公式自动处理
全负数         取绝对值最小的负数（或偶数个负数的乘积）

===
4️⃣ 确定遍历顺序

从前向后遍历（依赖前一个状态）
for i in range(1, len(nums)):
    # 计算 dp_max[i] 和 dp_min[i]

遍历方向说明：
    依赖关系：dp[i] 依赖 dp[i-1]
        ↓
    遍历顺序：从左到右（正向遍历）
        ↓
    索引范围：1 到 n-1（0已初始化）

5️⃣ 举例推导dp数组

示例：nums = [2, 3, -2, 4]
i   nums[i]   dp_max[i]         dp_min[i]       result
0   2           2               2               2
1   3           max(3, 2×3,     min(3, 2×3,     6
                2×3)=6          2×3)=3
2   -2          max(-2, 6×-2,   min(-2, 6×-2,   6
                3×-2)=-2        3×-2)=-12
3   4           max(4, -2×4,    min(4, -2×4,    6
                -12×4)=4        -12×4)=-48

🎯 关键步骤分析（i=2时）：
nums[2] = -2

dp_max[2] 的三种选择：
  ① 重新开始：-2
  ② 延续max：6 × (-2) = -12
  ③ 延续min：3 × (-2) = -6

  max(-2, -12, -6) = -2 ✓

dp_min[2] 的三种选择：
  ① 重新开始：-2
  ② 延续max：6 × (-2) = -12
  ③ 延续min：3 × (-2) = -6

  min(-2, -12, -6) = -12 ✓

再举一个负数翻转的例子：nums = [-2, 3, -4]
i   nums[i]   dp_max[i]   dp_min[i]   result
0   -2   -2   -2   -2

1   3   max(3, -6, -6)=3   min(3, -6, -6)=-6   3

2   -4   max(-4, -12, 24)=24   min(-4, -12, 24)=-12   24

✨ 关键点：i=2时，dp_min[1]×(-4) = -6×(-4) = 24（负负得正！）

💻 完整代码实现

版本1：标准DP数组版
参考：Solution_xxx

版本2：空间优化版（推荐）
参考：Solution_xxx

📊 五部曲总结表
步骤               本题解答
1️⃣ dp数组含义      dp_max[i]/dp_min[i] = 以i结尾的最大/最小乘积
2️⃣ 递推公式        三选一：当前值、延续max、延续min
3️⃣ 初始化          dp[0] = nums[0]，result = nums[0]
4️⃣ 遍历顺序        从左到右，i 从 1 到 n-1
5️⃣ 举例推导        手动模拟 [-2,3,-4] 验证负负得正

🎓 学习建议

前置知识：
├── LeetCode 53. 最大子数组和（单状态DP）
├── 动态规划基础概念
└── 负数乘法规则

进阶练习：
├── LeetCode 918. 环形子数组的最大和
├── LeetCode 1567. 乘积为正数的最长子数组长度
└── 各类"双状态维护"的DP问题

用五部曲分析后，这道题的思路就非常清晰了！核心 就是 理解为什么需要 同时维护 最大值 和 最小值。