为什么成员变量 能够 跨调用持久化?

===
这是一个非常基础但极其重要的问题！
理解“为什么成员变量 能 跨调用持久化”，是掌握面向对象编程（OOP）和 状态管理的关键。

✅ 一句话答案
因为成员变量 属于 对象（实例），只要 对象 没有被销毁，成员变量 就会一直存在；
而 方法调用 只是“借用”这个对象 来 执行操作，不会 清空它的状态。

===
🧠 一、从 内存模型 理解（核心）
1. 对象 vs 方法调用
① 当你写：
    Solution sol = new Solution();
    JVM 会在 堆（Heap）内存 中 创建一个 Solution 对象。
② 这个对象包含：
    1.所有 成员变量（instance variables）
    2.指向 类方法的引用（方法代码 本身在 方法区，不重复存储）

2. 方法调用时发生了什么？
① 每次调用 sol.read(...)：
    1.JVM 在栈（Stack） 上创建一个栈帧（stack frame）
    2.栈帧包含：局部变量、参数、返回地址
    3.方法执行完 → 栈帧 被弹出并销毁 → 局部变量 消失
② 但 堆上的对象 依然存在！ 成员变量不受影响。

===
🖼️ 二、图解内存布局

堆内存（Heap）                     栈内存（Stack）
┌───────────────────┐            ┌───────────────────┐
│  Solution 对象     │            │  read() 调用1      │
│                   │            │  - 局部变量 temp   │ ← 调用结束就销毁
│  internalBuf: [...]│◄───────────┤  - 参数 buf, n     │
│  internalIndex: 1 │            └───────────────────┘
│  internalSize: 4  │
└───────────────────┘            ┌───────────────────┐
                                 │  read() 调用2      │
                                 │  - 新的局部变量    │ ← 又一个独立栈帧
                                 │  - 参数 ...        │
                                 └───────────────────┘
✅ 成员变量在堆上，生命周期 = 对象生命周期
❌ 局部变量在栈上，生命周期 = 方法调用周期

===
📌 六、关键总结
概念	                            | 说明
成员变量（Instance Variables）	| 属于对象，存储在 堆内存，生命周期 = 对象生命周期
局部变量（Local Variables）	    | 属于方法，存储在 栈内存，生命周期 = 方法调用周期
多次调用同一对象的方法	            | 共享 同一个堆上的成员变量，因此状态 可持久化
LeetCode 158 的核心	            | 利用 成员变量 作为“内部缓冲区”，在多次 read() 调用间 传递未消费数据

===
💡 面试提示
当被问到“为什么用成员变量”时，你可以这样回答：
“因为题目要求 read() 函数会 被多次调用，而 每次调用 可能 只消费 部分数据。
我需要一个地方 来 暂存 未消费的字符。
成员变量 属于 对象实例，只要 对象存在，它的值 就会保留到 下一次调用，
这正是 我们需要的 跨调用 状态持久化机制。”

这展示了你对 内存模型 和 对象生命周期 的深入理解！