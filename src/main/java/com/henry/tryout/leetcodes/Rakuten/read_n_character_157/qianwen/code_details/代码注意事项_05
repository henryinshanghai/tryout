💡 最佳实践建议（针对 157）
① 每次调用新建 temp[4]，不要用 全局变量
② 严格限制 写入 不超过 n 个字符
③ read4 返回后，只取 min(count, n - total) 个字符
④ 多余的字符 直接丢弃————这是正确行为！

===
表格
#	易错点	                    错误示例 / 误解	                        正确做法	                                                为什么重要？
1	写入超过 n 个字符	            直接把 read4 读到的全部写入 buf	        必须限制：writeCount = Math.min(count, n - total)	    否则会数组越界或返回值 > n，违反接口契约
2	未处理提前终止（n 已满足）	    即使 total == n 仍继续调用 read4	        在循环条件中写 while (total < n)，并在 写入 后检查 是否已满	避免多读（虽不影响结果，但不符合“按需读取”语义）
3	忽略 read4 返回 0（EOF）	    没有在 count == 0 时 break	            一旦 read4 返回 0，立即退出循环	                        否则无限循环或读无效数据
4	错误计算写入位置	            buf[i] = temp[i]（未加偏移）	            应为 buf[total + i] = temp[i]	                        否则 覆盖 前面已写入的数据
5	返回值错误	                返回 n 或 read4 总和	                    必须返回 实际写入数 total	                                测试用例 会校验 返回值是否 ≤ n 且 等于实际读取量
6	使用全局/静态缓冲区	        用 类成员变量缓存 temp	                每次调用 新建 char[4] temp	                            题目说“只调用一次”，但即使如此，用 局部变量 更安全、符合规范
7	未处理 n = 0 边界	        循环直接执行	                            循环条件 total < n 自然跳过（n=0 时不进入）	                虽小，但需确保不 crash
8	混淆 buf 的用途	            试图用 buf 作为 read4 的参数	            read4 必须传 临时数组，不能 直接传 buf（因为 read4 会写满 4 个，可能超 n）	否则可能写越界（如 n=2，buf 长度=2，但 read4 写 4 个 → 越界！）
9	忘记更新 total	            写入后 没加 total += writeCount	        每次写入后 必须更新 total	                                否则死循环或返回值错误
10	过度优化：试图避免临时数组	    直接 read4(buf + offset)（Java不支持指针）	Java 中必须用 临时 char[4] 中转	                        Java 数组 无指针偏移，必须拷贝