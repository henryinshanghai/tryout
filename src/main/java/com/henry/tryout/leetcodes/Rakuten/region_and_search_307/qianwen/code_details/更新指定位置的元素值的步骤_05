在私有update()的实现中，为什么 当节点是叶子节点时，就一定是 需要更新的index呢？
谁来保证这一点?

===
为什么在 update() 中，当 start == end（叶子节点）时，就一定是用户要更新的那个 index？

答案是：
✅ 不是“所有叶子节点都是目标”，而是“递归路径 保证了 只有目标叶子会被访问到”。

下面我们一步步拆解这个 递归剪枝 与 路径选择机制。

🔍 核心原理：递归 只走向 包含目标 index 的子树
update() 方法 在每一步都会判断 目标 index 落在 左子树 还是右子树，
然后 只 递归进入 那一侧。

这意味着：从根 到 目标叶子的路径 是唯一且精确的，其他分支 根本不会被访问！

===
① 递归的base condition：查询路径的当前节点 是 叶子节点；
② 一般情况：查询路径的当前节点 不是 叶子节点；

两种情况是 互斥的，所以 需要使用if/else的语法。

步骤：
① 查询路径的当前节点 是 叶子节点，则：
    更新 当前节点的value值；
② 查询路径的当前节点 是 内部节点，则：
    比较 当前节点的区间终点 与 用户指定的index，根据比较结果，导航到 对应的子树中；
    1.如果小于等于，导航到 左子节点 递归更新；
    2.如果大于，导航到 右子节点 递归更新；
    3.更新结束后，左右子节点 都已经有了 正确的sum值，使用它们 来 更新 当前节点的sum值。

