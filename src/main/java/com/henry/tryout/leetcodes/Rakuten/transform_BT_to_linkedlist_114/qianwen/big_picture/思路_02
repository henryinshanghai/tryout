✅ 思路：迭代 + 前驱节点（推荐！高效且易懂）

===
核心思想（关键洞察）：
    对于当前节点 curr：
    ① 如果它 存在有 左子树，那么 在 前序遍历的结果序列 中，左子树 会整体出现 在右子树之前；
    ② 所以我们可以：
        1.找到 左子树的最右节点（前驱）
        2.重建 关键节点 之间的关系；
    这样就把 右子树 “挂”到了 左子树的末尾，然后把 整个左子树 移到右边。

===
目标：重建 关键节点 之间的关系：
3个关键节点：当前节点、前驱节点（左子树中的最右节点）、当前节点的右子节点；
具体步骤：
    1.前驱.right = curr.right；// 把 前驱节点的右链接 连接到 当前节点的右子节点；
    2.将 curr.right = curr.left；// 把 当前节点的右链接 连接到 当前节点的左子节点；
    3.curr.left = null；// 把 当前节点的左链接 连接到 null；

步骤图解（以根节点 1 为例）：
初始：
    1
   / \
  2   5
 / \   \
3   4   6

Step 1: 找到左子树(2)的最右节点 → 4
Step 2: 4.right = 5（原右子树）
Step 3: 1.right = 2（左子树）
Step 4: 1.left = null

变成：
1
 \
  2
 / \
3   4
     \
      5
       \
        6
然后移动到 curr = 2，重复同样操作。

代码（Java）：参考 Solution_qianwen_Morris

⏱️ 复杂度：
时间：O(n) —— 每条边最多访问两次
空间：O(1) —— 真正的原地算法！
✅ 这是最推荐的解法：高效、简洁、空间最优