手段：检查 所追加的字符 在窗口/子字符串中 是否已经出现过

===
具体做法1：使用Map；

使用一个Map 来 记录下 所有出现过的字符 -> 字符出现的位置；
然后 在获取到 当前所追加的字符后，使用 containsKey() 来 判断 它是否已经出现过；

‘已经出现过’ 并不能说明 它是‘在当前子字符串中出现过’ 呀？
手段：
    滑动窗口的开始位置 =
        max(滑动窗口的开始位置,
            字符最近一次出现过的位置 + 1)
作用：
① 如果 字符出现过的位置 不在滑动窗口中，说明 不需要更新 滑动窗口的开始位置，则：
    max()会取用 ”滑动窗口的开始位置“这个option；
② 如果 字符出现过的位置 在滑动窗口中，说明 需要更新 滑动窗口的开始位置，则：
    max()会取用 ”字符最近一次出现过的位置 + 1“这个option；

===
具体做法2：使用一个HashSet 来 维护 当前窗口中的所有字符；
如果 所追加的字符 在Set中已存在，说明 它 是‘重复字符’；

===
具体做法3：

因为题目中字符串 通常只包含 ASCII 字符（0～127），
我们可以 用数组 代替 哈希表，速度会更快。

如果 所追加的字符 对应的boolean值为true，说明 它 是‘重复字符’；

===
✅ 总结：如何判断字符是否已出现？

方法	  数据结构	         判断方式	                时间	        适用场景
推荐	  boolean[128]	     if (inWindow[c])	        O(1)	    字符串为 ASCII（绝大多数情况）
通用	  HashSet<Character> if (set.contains(c))	    O(1) avg	包含 Unicode 字符（如中文）
不推荐 字符串查找	         substring.contains(...)	O(n)	    效率太低，会超时