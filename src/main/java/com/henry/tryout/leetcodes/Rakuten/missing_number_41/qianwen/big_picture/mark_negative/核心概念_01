🔑 一、你需要理解的核心概念
1. 问题范围分析（关键洞察）
    答案一定在 [1, n+1] 范围内，其中 n = nums.length。
① 原因：
    1.如果数组 恰好包含 1, 2, ..., n，那么 最小缺失正整数是 n+1。
    2.否则，一定在 1 到 n 中缺了一个。
② 这个观察 限定了 搜索空间，是 后续所有优化的基础。
✅ 你要明白：我们根本不需要关心那些 ≤0 或 >n 的数字！


2. 原地算法（In-place Algorithm）
① 不使用 额外数组、哈希表等 数据结构。
② 直接利用 输入数组本身 来 存储信息。
③ 这是 满足 O(1) 空间复杂度 的 唯一可行路径。


3. 下标映射（Index as Hash Key）
① 数组下标天然有序：0, 1, 2, ..., n-1
② 我们可以约定：下标 i 代表 数字 i+1 是否存在
    比如：nums[0] 表示数字 1，nums[1] 表示数字 2，……
③ 这 相当于 把 数组 当作一个 长度为 n 的 布尔哈希表。
💡 这是本题 最核心的 “思维转换”：用 位置 代替 值 来 记录信息。


4. 状态标记技巧
由于 不能用 额外空间，我们需要 在 不丢失原始信息 的前提下“打标记”。
常用方法有：

✅ 方法 A：负数标记法
① 把 nums[i] 变成负数 → 表示 “数字 i+1 出现过”
② 前提：先清理掉 负数 和 超大数（替换为 无害值）

✅ 方法 B：交换归位法（桶排序思想）
① 把 每个 有效数字 x ∈ [1, n] 交换到 nums[x-1] 的位置
② 最终检查 哪个位置 “名不副实”

这两种方法 都依赖 “下标映射”思想，只是 实现方式 不同。

