✅ 策略一：不修改 无效值，直接跳过（你之前看到的标准写法）
这是最简洁、高效的做法，不需要预处理：
    for (int i = 0; i < n; i++) {
        while (nums[i] >= 1 && nums[i] <= n && nums[i] != nums[nums[i] - 1]) {
            // 只处理 [1, n] 范围内的数，其他直接忽略
            swap(...);
        }
    }
① ≤0 或 >n 的数：在 while 条件中 被自动跳过（因为不满足 1 ≤ x ≤ n）
② 它们会 “留在原地”，但在 最后检查 时：
    if (nums[i] != i + 1) return i + 1;
这些 无效值 必然 ≠ i+1，所以 能正确 触发返回。

✅ 优点：无需 预处理，代码更短，效率更高。
✅ 这是目前 LeetCode 社区 最推荐的写法。