🧠 二、你需要掌握的核心概念
要理解这道题的解法，需先掌握以下 4 个关键概念：

==
✅ 概念 1：API 封装 与 黑盒调用
① read4 是一个“黑盒”函数：你不知道它内部怎么读文件，只知道：
    1.每次 最多返回 4 个字符；
    2.返回值 = 实际读出的 字符数（可能 < 4，表示 文件结束）；
    3.它会 把 字符 写入 你传给它的 char[] 缓冲区。
② 你的 read 函数 必须基于 这个受限接口 完成 更灵活的读取。
💡 类比：
    你只能每次 从水龙头接 4 杯水（read4），
    但用户 可能只要 1 杯 或 10 杯（n），你 要控制好 接水 和 倒水的过程。

==
✅ 概念 2：缓冲区（Buffer） 与 指针管理
① 由于 read4 每次读 4 个字符，但 用户 可能只读 n=1，所以 可能出现 “读多了”的情况。
② 但在 LeetCode 157（简单版）中，假设 每次调用 read 都是独立的（即不会 调用 read多次 来 读同一个文件流）。
    → 所以 不需要 跨调用保存 剩余字符（那是第 158 题的内容！）。

✅ 重要区分：
① 157 题：单次调用，无状态（无需缓存）；
② 158 题：多次调用，需内部缓存（有状态）。

==
✅ 概念 3：循环 与 分块读取
① 因为 read4 一次最多读 4 字符，而 n 可能很大（如 1000），所以需要 用循环 多次调用 read4。
② 每次读取 后，把 字符 复制到 目标 buf 的正确位置。

==
✅ 概念 4：边界条件处理
这是本题最容易出错的地方！需考虑：
① 文件总长度 < n → 提前结束；
② 最后一次读取 时，read4 返回 k < 4 → 文件结束；
③ 累计读取数 达到 n 时，立即停止（即使 read4 还能读，也不能超 n）。