🔁 一、核心思想：对称位置 互换
要将一行 [a₀, a₁, a₂, ..., aₙ₋₁] 变成 [aₙ₋₁, ..., a₂, a₁, a₀]，
只需要让：
① 第 0 个 ↔ 第 n−1 个
② 第 1 个 ↔ 第 n−2 个
③ 第 2 个 ↔ 第 n−3 个
④ ……
⑤ 直到中间相遇

✅ 这就是 “首尾 对称交换” ———— 每一对交换后，它们 就到达了 最终正确的位置。

===
🧩 二、具体实现（Java 双指针交换）
    public void reverse(int[] row) {
        int left = 0;                // 左指针：从开头开始
        int right = row.length - 1;  // 右指针：从末尾开始

        while (left < right) {       // 当 left >= right 时，已处理完 所有对
            // 交换 row[left] 和 row[right]
            int temp = row[left];
            row[left] = row[right];
            row[right] = temp;

            // 移动指针向中心靠拢
            left++;
            right--;
        }
    }

===
🔍 三、为什么只交换“前一半”？
假设数组长度为 n：

情况	            需要交换的对数	    原因
n 为偶数（如 4）	2 对：(0↔3), (1↔2)	中间 无元素，交换 n/2 次
n 为奇数（如 5）	2 对：(0↔4), (1↔3)	中心元素（索引 2）不动
✅ 所以，最多 只需交换 floor(n/2) 次，即 left < right 的循环次数。

❗ 如果你 交换 超过一半（比如 遍历全部），会发生：
先把 [1,2,3,4] → [4,3,2,1]
再次交换 又变回 [1,2,3,4] → 白干了！

===
✅ 总结：关键点回顾

问题	                    答案
翻转是通过交换实现的吗？	✅ 是的！通过 对称位置 两两交换
交换哪些位置？	        首尾、次首尾……直到中心
为什么不会重复或遗漏？	    left < right 确保 每对 只交换一次
中间元素怎么办？	        奇数长度时，中间元素 天然在 正确位置，无需操作
空间复杂度？	            O(1)，仅用一个 temp 变量

===
这种“双指针交换翻转”是算法 基础中的基础，不仅用于 矩阵旋转，还广泛应用于：
① 字符串反转（如 "hello" → "olleh"）
② 回文判断
③ 数组重排 等场景