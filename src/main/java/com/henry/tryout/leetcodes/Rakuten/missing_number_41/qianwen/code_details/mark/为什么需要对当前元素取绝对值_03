===
✅ 总结：为什么需要两次 Math.abs()

位置	                        作用	            原因
int x = Math.abs(nums[i])	还原 原始数字	    因为 nums[i] 可能已被 前面的操作 标记为负
nums[x-1] = -Math.abs(...)	安全 设为负数	    防止 原值 已是 负数 时，“负负得正” 取消标记

💡 关键洞察：
“预处理 只保证 初始状态 全为正，但 步骤2的遍历过程 会动态产生 负数！”
后面的 i 会读到 前面 i 修改过的负值，所以必须 用 abs 还原。