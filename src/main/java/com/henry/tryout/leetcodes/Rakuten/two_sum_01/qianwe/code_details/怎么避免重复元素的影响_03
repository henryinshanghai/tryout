手段：在遍历时，先检查 补数的存在性，再向Map中添加 当前元素的条目；

原理：map中永远只包含 当前索引i之前 的元素（也就是 索引<i的元素）；
（所导致的）特性：
① 检查 补数的存在性时，不会 检查到 自己；// 因此 不会出现 一个元素 被用2次的情况
② 后续出现重复元素时，不会因为覆盖 而丢失 有效配对；

如果 当前元素的 补数元素 存在的话，那么有以下情形：
① 补数元素 在当前元素的前面：
    这种情况 补数元素 一定已经被添加到map中了，则：能够 快速检查 补数的存在性；
② 补数元素 在当前元素的后面：
    这种情况 会先把当前元素添加到map中，等遍历到 补数元素时，就能 快速检查到 当前元素的存在性；

===
✅ 终极总结：标准解法 为何免疫 重复问题？

风险类型	                标准解法如何避免
自己匹配自己	            map 中 不含 当前元素（先查后插）
                        → 补数 若等于自己，但 未插入，查不到
重复值覆盖导致丢失有效索引	找到解 就立即返回；
                        且只需要一个 配对索引，不需要 保留所有
当前与先前重复（构成解）	先前的 已存入 map，当前查到 即可配对
当前与之后重复	        当前存入 map，等 之后的元素 来查它
                        （顺序无关，总有一方 能查到 另一方）
💡 本质：利用“时间差”————用历史信息 解决 当前问题，绝不让 当前 污染历史

📌 一句话记住：
“我只和 过去的人 配对，绝不和 未来的自己 或 现在的自己 纠缠。”
