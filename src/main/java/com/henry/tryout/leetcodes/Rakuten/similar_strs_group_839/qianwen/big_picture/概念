🧠 要理解本题，你需要掌握以下核心概念
1. 等价关系 与 连通分量（Connected Components）
① “相似”关系具有：
    1.自反性（自己和自己相似）
    2.对称性（A 与 B 相似 → B 与 A 相似）
    3.传递性（A～B, B～C → A～C 在组内成立，虽然直接 A 和 C 可能不相似，但通过 B 连通）
② 所以这是一个 等价关系，自然形成 若干 等价类（即“组”）。
③ 图论中，这等价于 求 无向图的连通分量数量。


2. 如何判断 两个字符串 是否“相似”？
写一个辅助函数 isSimilar(s1, s2)：
① 如果 s1.equals(s2) → true
② 否则，遍历字符，记录 不同位置的索引
    1.如果不同位置数 ≠ 2 → false
    2.如果不同位置数 = 2，检查是否 s1[i] == s2[j] && s1[j] == s2[i] → true

代码：参考 Solution_qianwen_UF

3. 建图 or 并查集（Union-Find）
有两种主流解法：

==
✅ 方法一：并查集（推荐）
① 每个字符串 初始为 独立集合。
② 遍历 所有 字符串对 (i, j)，如果 isSimilar(strs[i], strs[j])，就 union(i, j)。
③ 最终统计 不同根节点的数量。

⏱ 时间复杂度：O(n² × m)，其中 n = strs.length, m = 字符串长度
（因为要检查 O(n²) 对，每对比较 O(m)）

==
✅ 方法二：DFS / BFS（构建邻接表）
① 先构建图：对 每个字符串，找所有 与它相似的 其他字符串，添加边。
② 然后 从 每个未访问节点出发 做 DFS/BFS，每次遍历完 一个连通块，计数 +1。

⏱ 时间复杂度同样是 O(n² × m)，但常数可能更大（因为要显式建图）。