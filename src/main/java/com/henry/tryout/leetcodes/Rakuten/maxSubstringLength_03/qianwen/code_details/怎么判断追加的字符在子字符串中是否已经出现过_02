===
手段1：使用Map；

使用一个Map 来 记录下 所有出现过的字符 -> 字符出现的位置；
然后 在获取到 当前所追加的字符后，使用 containsKey() 来 判断 它是否已经出现过；

已经出现过 并不能说明 它是在当前子字符串中出现过 呀？
手段：
    滑动窗口的开始位置 =
        max(滑动窗口的开始位置,
            字符出现过的位置 + 1)
作用：
① 如果 字符出现过的位置 不在滑动窗口中，说明 不需要更新 滑动窗口的开始位置，则：
    max()会取用 ”滑动窗口的开始位置“这个option；
② 如果 字符出现过的位置 在滑动窗口中，说明 需要更新 滑动窗口的开始位置，则：
    max()会取用 ”字符出现过的位置 + 1“这个option；

===
手段2：使用一个HashSet 来 维护所有 当前窗口中的字符

===
方法3：

因为题目中字符串通常只包含 ASCII 字符（0～127），我们可以用数组代替哈希表，速度更快。


===
✅ 总结：如何判断字符是否已出现？
表格
方法	  数据结构	         判断方式	                时间	        适用场景
推荐	  boolean[128]	     if (inWindow[c])	        O(1)	    字符串为 ASCII（绝大多数情况）
通用	  HashSet<Character> if (set.contains(c))	    O(1) avg	包含 Unicode 字符（如中文）
不推荐 字符串查找	         substring.contains(...)	O(n)	    效率太低，会超时