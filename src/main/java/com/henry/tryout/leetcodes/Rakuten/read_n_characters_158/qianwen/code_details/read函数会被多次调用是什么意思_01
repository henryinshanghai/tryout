leetcode第158题中 “read()函数会被多次调用” 是什么意思？这对read()函数的实现有什么影响?

===
🎯 一、“多次调用”是什么意思？
字面意思：
同一个 Solution 对象的 read() 方法会 被连续调用多次，每次传入 不同的 n。

举个真实场景 🌰：
    Solution sol = new Solution();  // 只创建一次对象

    char[] buf1 = new char[1];
    int r1 = sol.read(buf1, 1);   // 第一次调用：读 1 个字符

    char[] buf2 = new char[3];
    int r2 = sol.read(buf2, 3);   // 第二次调用：再读 3 个字符

    char[] buf3 = new char[5];
    int r3 = sol.read(buf3, 5);   // 第三次调用：再读 5 个字符
💡 同一个 sol 对象 被 多次调用read()，而不是 每次 新建对象！

===
⚠️ 二、这对实现有什么根本性影响？
✅ 核心影响：
你必须在 多次调用 之间 保存 “未消费完的数据状态”。

为什么？
因为底层 API read4() 总是读取 4 个字符，
但用户可能 只取 1 个、2 个…… 剩下的 必须 暂存起来，供 下一次调用 使用。

===
🔍 三、对比：单次调用 vs 多次调用
特性	    | LeetCode 157（单次调用）	| LeetCode 158（多次调用）
调用次数	| 只调用 read() 一次	        | 同一对象调用 read() 多次
状态保存	| 不需要（局部变量即可）	    | 必须用 类成员变量 保存状态
缓冲区	| 每次临时申请	            | 必须 跨调用 持久化
难度	    | 简单	                    | 中等（考察 状态管理）

===
✅ 五、正确做法：用成员变量保存状态
必须保存两个状态：
① 内部缓冲区：存放 read4 多读出来的字符
② 读取位置指针：记录 下一个 要返回的 字符位置

代码：参考 Solution_qianwen

为什么这样能解决问题？
① 第一次调用 后，"bcd" 保存在 internalBuf 中，internalIndex=1, internalSize=4
② 第二次调用 时，先消费 内部缓冲区，不会 立即调用 read4
数据不会丢失！

===
📌 七、面试关键点
当被问到这道题时，一定要强调：

“由于 read() 会被多次调用，
我必须使用 类的成员变量 来 保存 未消费的缓冲区数据 和 读取位置。
如果使用 局部变量，每次调用 都会丢失 之前多读的数据，导致 结果错误。”

这展示了你对 对象生命周期 和 状态管理 的理解。

===
✅ 总结
问题	                | 答案
“多次调用”是什么意思？	| 同一个对象的 read() 被 连续调用多次
最大影响是什么？	    | 必须 跨调用 保存 未消费的数据状态
如何保存状态？	    | 用 private 成员变量：缓冲区 + 读取指针
不保存会怎样？	    | 丢失数据，结果错误
本质考察什么？	    | 状态 持久化能力 和 I/O 缓冲思想

你现在完全理解了 LeetCode 158 的核心挑战！
这也是很多 真实系统（如文件流、网络流）的 基本设计模式。