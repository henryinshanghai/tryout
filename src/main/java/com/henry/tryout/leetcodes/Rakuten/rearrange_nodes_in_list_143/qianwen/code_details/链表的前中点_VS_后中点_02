前中点 和 后中点 分别有哪些使用的场景与题目，帮我列举一下

===
非常好的问题！
理解 前中点（Lower Middle） 和 后中点（Upper Middle） 的区别，
并知道它们 在不同算法场景中的应用，是 掌握 链表分治类题目的关键。


下面我们系统梳理：
📌 一、定义回顾（1-based 位置）
对于长度为 n 的链表：

类型	                    位置（1-based）	                            示例（n=4: [A,B,C,D]）	示例（n=5: [A,B,C,D,E]）
前中点（Lower Middle）	⌊(n+1)/2⌋ 或 n/2（偶）
                        即第 ⌈n/2⌉ 个？不，更准确：第 n//2 个（整除）	第 2 个 → B	            第 3 个 → C
后中点（Upper Middle）	⌊n/2⌋ + 1	                                第 3 个 → C	            第 3 个 → C

✅ 更实用的判断方式：
① 前中点：分割后，左半段 ≥ 右半段（奇数时左多1）
② 后中点：分割后，右半段 ≥ 左半段
但最可靠的是看 快慢指针的循环条件。

===
🔧 二、如何用 快慢指针 控制中点
✅ 找 前中点（Left-biased）
    slow = head;
    fast = head;
    while (fast.next != null && fast.next.next != null) {
        slow = slow.next;
        fast = fast.next.next;
    }
    // slow 是前中点
适用于：归并排序、重排链表（LeetCode 143）

✅ 找 后中点（Right-biased）
    slow = head;
    fast = head;
    while (fast != null && fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
    }
    // slow 是后中点
适用于：回文链表（LeetCode 234）、找环相关变种

===
🆚 四、对比总结表

特性	            前中点（Lower Middle）	    后中点（Upper Middle）
快慢指针条件	    fast.next != null
                && fast.next.next != null	fast != null && fast.next != null
偶数 n=4 时位置	第 2 个	                    第 3 个
奇数 n=5 时位置	第 3 个	                    第 3 个（相同）
分割后左半段长度	≥ 右半段	                    ≤ 右半段
典型题目	        143（重排）、148（排序）	    234（回文）、876（中点）
是否包含中心节点	是（奇数时）	                否（奇数时中心被跳过）
链表断开方式	    mid.next = null，           后半段 = slow（或 slow.next）
                后半段 = mid.next

===
五、记忆技巧
① “重排和排序，要保中心，用前中点”
    → 因为 中心节点 要留在 前半段结尾（如 143 的 3 在 [1,2,3,4,5] 中最后输出）

② “回文和找中，对称检查，用后中点”
    → 因为要 从中间“劈开”，后半段 独立反转（如 234 的 [1,2,3,2,1] 只比 1,2 vs 2,1）
LeetCode 876 明确说：“如果有两个中间节点，返回第二个” → 这就是 后中点的定义！


✅ 六、一句话终极总结
前中点：用于 分割+重组类问题（重排、排序），保留 中心节点 在前半段。
后中点：用于 对称性检查类问题（回文），或 题目明确要求“第二个中点”（如 876）。
掌握 这个区分，你在 面对 任何链表分治问题 时，都能 精准选择 中点策略，避免边界错误！