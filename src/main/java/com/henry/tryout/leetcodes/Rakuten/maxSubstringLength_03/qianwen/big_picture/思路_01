===
思路1：暴力枚举
❌ 方法 1：暴力枚举所有子串
① 枚举所有起点 i 和终点 j（i ≤ j）
② 检查 s[i..j] 是否无重复
③ 记录最大长度
✅ 简单
❌ 时间复杂度：O(n³)（检查重复需 O(n)），会超时

===
思路2：滑动窗口 + 哈希集合?

核心思想：用两个指针维护一个“窗口”，动态扩展和收缩
窗口定义：
① [left, right]：当前无重复字符的子串
② 用 Set<Character> 记录 窗口中 已有的字符

===
💡 进阶优化：用哈希表记录最后出现位置（跳过无效移动）
我们可以 不用逐步移动 left，而是 直接跳到 重复字符的下一位！

改进思路：
① 用 Map<Character, Integer> 记录 每个字符 最近一次出现的下标
② 当 s[right] 已存在 且 其位置 ≥ left，说明 在 当前窗口 内 重复
③ 直接令 left = lastSeen[s[right]] + 1
✅ 这样避免了 while 循环一步步移动，但逻辑要更小心！