✅ 核心思想：按位确定 + 阶乘分组
我们不生成 所有排列，而是一位一位地 构造答案。

==
🔑 关键观察：
① 对于 n 个不同数字，以 某个数字 作为开头的排列 有 (n-1)! 个。
② 所有排列 按 字典序 分组：
    1.以 1 开头：共 (n-1)! 个（第 1 ~ (n-1)! 个）
    2.以 2 开头：接下来 (n-1)! 个（第 (n-1)!+1 ~ 2×(n-1)! 个）
    ...
    4.以 d 开头：第 (d-1)×(n-1)! + 1 到 d×(n-1)! 个
✅ 因此，第k个排列 的 首位数字 可以通过：
    index = (k - 1) / (n - 1)!
来 确定（注意：k 从1开始，所以 先减1 来 转为 0-based）


===
🧠 你需要掌握的核心概念
要理解 整个算法，你 需要掌握 以下3个关键概念：

1. 阶乘（Factorial）与 分组计数
① f[n] = n! = n × (n-1) × ... × 1
② 以 某个特定数字 作为开头的 排列数量 = (n-1)!
③ 这 让我们能 跳过 整块排列区域，直接定位到 目标分组
💡 预计算 阶乘数组 fact[0..n]，其中 fact[i] = i!

2. “可用数字”列表的 动态维护
① 初始可用数字：[1, 2, 3, ..., n]
② 每确定一位，就 从列表中移除 已使用的数字
③ 下一位的选择 基于 剩余可用数字的字典序
✅ 使用 List<Integer> 存储 可用数字，支持 按索引删除

3. 0-based 索引转换（避免 off-by-one 错误）
① 题目中 k 从1开始；
② 但编程中 用 0-based索引 更方便
③ 所以第一步：k = k - 1
然后每一步：
    int index = k / fact[remaining - 1];  // 剩余数字个数 = remaining
    k = k % fact[remaining - 1];          // 更新 k 为 组内偏移

===
✅ 总结：你需要理解的 3 个核心
概念	            | 作用
阶乘分组	        | 快速跳过 无关排列，定位 目标分组
0-based 索引转换	| 统一 计数方式，避免 边界错误
动态可用数字列表	| 确保 每次选择的是 剩余数字中的 第index小的数字

这道题 是 组合数学 + 构造算法 的经典范例。
掌握它，你 就掌握了 “通过 数学规律 跳过 暴力枚举”这一重要思想，
对后续做「康托展开」「排列序号」等问题大有帮助！