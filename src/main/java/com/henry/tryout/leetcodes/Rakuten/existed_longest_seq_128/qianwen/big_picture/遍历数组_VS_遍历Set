for循环遍历数组 与 for循环遍历set 有很大的区别吗?

===
这是一个非常重要且常被忽视的问题！

“遍历数组 vs 遍历 Set” 在 LeetCode 第 128 题（以及类似问题）中，确实有显著区别，主要体现在 效率、重复处理、代码健壮性 三个方面。

下面我们从原理到实践，彻底讲清楚。

✅ 结论先行
对比维度	    | for (x : nums)（遍历数组）   | for (x : set)（遍历 Set）
是否去重	    | ❌ 会重复处理相同元素	     |  ✅ 每个唯一值只处理一次
时间效率	    | 可能更低（尤其含大量重复）	 | 更高（避免无效工作）
逻辑正确性	| ✅ 正确（因有 continue 保护） | ✅ 正确
推荐程度	    | 可用，但非最优	             | ✅ 更优
📌 两者都能 AC，但遍历 Set 是更干净、更高效的做法。

===
🔍 详细分析

1. 重复元素的影响
假设输入：nums = [1, 1, 1, 1, 2, 2, 3]

① 遍历数组：
    1.循环 7 次
    2.对 x = 1 处理 4 次
        （虽然 if (contains(x-1)) continue 会 让 后3次 跳过，但 仍做了 4 次 contains(x-1) 判断）
    3.对 x = 2 处理 2 次（同样，只有第一次可能进入主逻辑）
② 遍历 Set：
    1.set = {1, 2, 3}
    2.循环仅 3 次
    3.每个数只判断一次
✅ Set 自动去重，减少无意义的循环次数

2. 时间复杂度理论 vs 实际
① 理论时间复杂度：两者都是 O(n)
    （因为即使遍历数组，每个元素也只做 O(1) 工作）
② 实际运行时间：
    1.如果数组有 大量重复（如 [1]*100000），遍历数组会做 10⁵ 次判断，而 Set 只做 1 次
    2.虽然最坏情况（全不重复）两者一样，但平均情况 Set 更快
💡 LeetCode 的测试用例 通常包含 重复数据，所以 遍历Set 往往跑得更快。

3. 代码意图 更清晰
    // 遍历 Set：明确表示“我们只关心唯一的数字”
    for (int x : uniqueNumbers) {
        if (!uniqueNumbers.contains(x - 1)) {
            // ...
        }
    }
vs

    // 遍历数组：读者会疑惑“为什么要对重复数字做判断？”
    for (int x : nums) {
        if (!set.contains(x - 1)) {  // 注意：这里查的是 set，不是 nums！
            // ...
        }
    }
✅ 遍历 Set 让 “去重” 和 “唯一性” 成为 显式设计，而非 隐式依赖

4. 极端情况对比
输入	                        | 遍历数组的循环次数	| 遍历 Set 的循环次数
[1,2,3,...,10000]（无重复）	| 10000	            | 10000 → 相同
[5,5,5,...,5]（10000 个 5）	| 10000	            | 1 → Set 快 10000 倍
空数组	                    | 0	                | 0
⚠️ 虽然算法复杂度仍是 O(n)，但常数因子（constant factor）差异巨大

===
✅ 回到 LeetCode 128 题
你的写法：
    for (int x : st) {  // st 是 Set
        if (st.contains(x - 1)) continue;
        // ...
    }

这是最佳实践，因为：
① 利用了 Set 的去重特性
② 循环次数最少
③ 逻辑 聚焦于 “唯一数字的连续性”，而非 原始输入顺序 或 重复

===
✅ 总结：何时用哪种？
场景	                        | 推荐
需要去重 + 关注唯一值（如本题）	| ✅ 遍历 Set
需要 保留原始顺序 或 索引	    | ✅ 遍历数组
数组 天然无重复	            | 两者均可，Set 略优（语义清晰）
性能敏感 + 可能有重复	        | ✅ 遍历 Set

🌟 在“查找唯一元素性质”的问题中（如 最长连续序列、两数之和 去重版 等），优先遍历 Set。