✅ 正确做法：在每个位置使用 while 循环，直到当前位“稳定”
标准解法是：
    for (int i = 0; i < nums.length; i++) {
        // 只要当前数字在 [1, n] 范围内，且不在正确位置，就不断交换
        while (nums[i] >= 1 && nums[i] <= nums.length && nums[nums[i] - 1] != nums[i]) {
            swap(nums, i, nums[i] - 1);
        }
    }

为什么需要 while？
因为每次交换后，新来到 i 位置的数字可能仍然不在正确位置，需要继续处理，直到：
① 当前数字 无效（<1 或 >n）
② 或 已在 正确位置
③ 或 目标位置 已有 相同数字（防死循环）

