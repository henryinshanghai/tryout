你提供的代码实现中，为什么要维护 tempMax与 tempMin这两个变量呢?

===
你注意到了 LeetCode 第 152 题（乘积最大子数组）代码中一个看似“多余”但实则必不可少的细节：

为什么需要 tempMax 和 tempMin？
为什么不能直接更新 maxProd 和 minProd？

答案是：避免在计算 minProd 时 使用 已经被覆盖的 maxProd 值。

下面我用原理 + 图示 + 错误示例彻底讲清楚。

===
🎯 核心问题：变量覆盖导致逻辑错误
假设我们这样写（错误写法）：
    // ❌ 错误！不要这样做
    maxProd = Math.max(nums[i], Math.max(maxProd * nums[i], minProd * nums[i]));
    minProd = Math.min(nums[i], Math.min(maxProd * nums[i], minProd * nums[i])); // ← 这里出问题！

问题在哪？
① 第一行已经修改了 maxProd
② 第二行计算 minProd 时，用的是 新的maxProd，而不是 上一轮的旧值！
③ 但 正确的minProd 应该基于 同一轮的原始 maxProd 和 minProd
💥 这会导致 状态转移错误！

===
🔍 举个具体例子：nums = [2, -3, -2]
我们手动模拟 正确 vs 错误 的过程。

✅ 正确做法（用 temp 变量）
i	nums[i]	old_max	old_min	candidates	            new_max	new_min
0	2	    —	    —	    —	                        2	2
1	-3	    2	    2	    (-3, 2×-3=-6, 2×-3=-6)	    -3	-6
2	-2	    -3	    -6	    (-2, -3×-2=6, -6×-2=12)	    12	-2
✅ 最终最大乘积 = 12（来自 2 × -3 × -2 = 12）

❌ 错误做法（直接覆盖）
    // i=2 时，当前 maxProd = -3, minProd = -6
    maxProd = max(-2, -3*-2=6, -6*-2=12) = 12;  // maxProd 被改成 12
    minProd = min(-2, 12*-2=-24, -6*-2=12) = -24; // ⚠️ 用了新 maxProd=12！
→ 得到 minProd = -24（错误！正确应为 -2）

更严重的是：如果 后面还有正数，这个错误的 minProd 会 污染 后续计算！

===
🧠 为什么必须用临时变量？
因为状态转移要求：
    new_max 和 new_min 必须同时基于 old_max 和 old_min 计算

这就像解方程组：
    x' = f(x, y)
    y' = g(x, y)
你不能先算 x' 再用 x' 算 y'，而要用 原来的 x, y 同时算 x', y'。

===
✅ 总结
问题	                        | 答案
为什么要 tempMax/tempMin？	| 防止 在计算 minProd 时 使用 已被覆盖的 maxProd
本质原因？	                | 状态转移 需基于 同一时刻的旧状态，而非 部分更新的新状态
不加会怎样？	                | 逻辑错误，结果可能偏小 或 完全错误
哪些语言可省略？	            | 支持并行赋值的语言（如 Python），但显式用 temp 更清晰、通用

你现在 完全理解了 这个精妙的设计细节！
这也是为什么很多初学者 能写出 “看似正确”但实际 WA 的代码————忽略了 状态同步 的重要性。