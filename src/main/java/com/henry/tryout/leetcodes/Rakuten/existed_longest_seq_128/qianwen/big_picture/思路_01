===
❌ 方法 1：排序 + 扫描
先排序：[1,2,3,4,100,200]
然后遍历找最长连续段
✅ 简单
❌ 时间复杂度 O(n log n) → 不符合题目要求

===
❌ 方法 2：对每个数暴力扩展
    for (int num : nums) {
        int count = 1;
        while (contains(num + count)) count++; // 向上找
        while (contains(num - count)) count--; // 向下找
    }
① 用 HashSet 判断是否存在
② 但最坏情况下（如 [1,2,3,...,n]），每个数都遍历整个序列 → O(n²)
❌ 超时！

===
✅ 方法 3：智能跳过 + 哈希集合（O(n) 解法）
💡 核心思想：
    只从“连续序列的起点”开始扩展！

什么是“起点”？
→ 一个数 x 是起点，当且仅当 x - 1 不存在于 数组中。

例如：
[100, 4, 200, 1, 3, 2]
① 1 是 起点（因为 0 不在数组中）
② 2 不是 起点（因为 1 在数组中）→ 跳过！
③ 3 不是 起点（2 存在）→ 跳过！
④ 4 不是 起点（3 存在）→ 跳过！
⑤ 100 是 起点（99 不存在）
⑥ 200 是 起点（199 不存在）
这样，我们只对 每个连续序列的开头 做一次扩展，避免 重复工作。