递归地查找 父节点的根节点 我能理解，
但是 找到根节点后，为什么要 把找到的根节点 赋值 给 parent[currentNode]呢？

===
这是一个极其关键且深刻的问题！
你 已经理解了 “递归找根”，但疑惑的是：
    为什么 找到根 之后，还要 把 parent[currentNode] = root？
答案就是：为了“路径压缩”（Path Compression）———— 这是并查集 高效的 核心秘密！

我们用 一个生活化的比喻 + 技术解释，彻底讲清楚 它的必要性、作用和价值。

===
🌟 一、生活比喻：公司汇报链
想象一家公司，员工要向上级汇报问题：
① 员工 A → 组长 B → 经理 C → 总监 D（D 是最终决策人）

❌ 没有路径压缩（原始方式）：
每次 A 有问题，都要：
    A 找 B → B 找 C → C 找 D → D 回复 → C 转达 → B 转达 → A 收到
问题：每次都要走完整链条，效率低！

✅ 有了路径压缩（聪明做法）：
第一次汇报后，A 直接记下：“以后有问题 直接找 D！”
同时 B 也记下：“以后直接找 D！”
下次 A 再有问题：
    A → 直接找 D！一步到位！
💡 路径压缩的本质：把“中间传话的人”裁掉，让 所有人 直接对接 最终负责人。

===
🔧 二、技术解释：为什么要赋值？
看这行代码：
    groupLeader[x] = findGroupLeader(groupLeader[x]);
    //         ↑               ↑
    //      赋值给当前节点    递归找到的根

步骤分解（以 x = 0 为例）：
假设当前结构：
 → 1 → 2 → 3（3 是根）

1.调用 find(0)
    发现 groupLeader[0] = 1 ≠ 0 → 需要找 1 的根
2.递归调用 find(1)
    发现 groupLeader[1] = 2 ≠ 1 → 需要找 2 的根
3.递归调用 find(2)
    发现 groupLeader[2] = 3 ≠ 2 → 需要找 3 的根
4.递归调用 find(3)
    groupLeader[3] = 3 → 返回 3（找到根！）
5.回溯到 find(2)：
    执行 groupLeader[2] = 3 ← 关键！2 以后直接认 3 为组长
    返回 3
6.回溯到 find(1)：
    执行 groupLeader[1] = 3 ← 1 也直接认 3 为组长
    返回 3
7.回溯到 find(0)：
    执行 groupLeader[0] = 3 ← 0 也直接认 3 为组长
    返回 3
✅ 最终结构变成：
     → 3
     → 3
     → 3
     → 3

===
⚡ 三、不赋值会怎样？（反面例子）
如果只递归找根，但不赋值（即删掉 groupLeader[x] = ...）：
    // 错误写法！没有路径压缩
    public int find(int x) {
        if (parent[x] != x) {
            return find(parent[x]); // 只返回，不更新 parent[x]
        }
        return x;
    }
那么每次 find(0) 都要走 0→1→2→3，时间复杂度退化为 O(n)！

在 LeetCode 839 中，如果有 300 个字符串连成一条链：
    ① 第一次 find：走 300 步
    ② 第二次 find：还是走 300 步
    ③ ...
    ④ 总时间：O(n²m) → 可能超时！

而有了路径压缩：
    ① 第一次 find：走 300 步（但压缩后，所有节点直连根）
    ② 后续每次 find：1 步完成！
    ③ 均摊时间：接近 O(1)

===
✅ 五、总结：赋值的意义
表格
行为	                目的	                        效果
parent[x] = root	记录“最优路径”	            下次查询 x 时，一步直达根节点
递归回溯时逐层赋值	    压缩整条路径	                整条链上的 所有节点 都受益
看似多此一举的赋值	    实则是用空间换时间的经典优化	让 并查集 从“普通” 变成 “近乎常数时间”的神级数据结构

💡 记住：
“找到根 只是目的，压缩路径 才是智慧。”
所以，这个赋值 不是 “可有可无”，而是 并查集 高效的 灵魂所在！
没有它，并查集 就失去了 “近似常数时间”的优势。