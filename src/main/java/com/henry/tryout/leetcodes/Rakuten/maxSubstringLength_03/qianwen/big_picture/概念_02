===
✅ 你需要掌握的核心概念

1. 滑动窗口（Sliding Window）—— 核心思想
这是本题 最关键的算法范式。

💡 什么是滑动窗口？
① 用 两个指针 left 和 right 维护一个动态区间 [left, right]，称为“窗口”。
② 窗口会 根据条件 向右滑动：right 扩展，left 收缩。
③ 目标：在 所有合法窗口 中，找到 满足条件（如“无重复字符”）的最大/最小长度。

🌟 为什么适合本题？
① “子串” = 连续区间 → 天然适合 窗口模型
② “无重复” = 窗口 所需满足的约束条件
③ 我们要找“最长” → 典型的 滑动窗口 优化目标
✅ 记住：滑动窗口 适用于 连续子数组/子串 + 某种约束 + 最值问题。

2. 双指针（Two Pointers）———— 实现机制
滑动窗口 通常用 双指针实现：
① right（快指针）：负责 扩展窗口，探索 新元素
② left（慢指针）：负责 收缩窗口，修复 非法状态

🔁 移动规则（本题特例）：
① right 每次 +1（遍历每个字符）
当 s[right] 在当前窗口中已存在 → 移动 left 直到 无重复
⚠️ 注意：left 不会回退，只会 向右移动 或 不动 → 保证 O(n) 时间

3. 哈希表（Hash Table / Set）———— 快速判重
要判断“当前字符是否已在窗口中”，需要 O(1) 的查找。

两种常用方式：
方式	 | 数据结构	        | 用途
Set	 | set()	        | 只记录“字符是否存在”
Map	 | dict{char: index}| 记录“字符最后出现的位置”（用于优化 left 跳跃）
✅ 初学建议先用 Set，逻辑更清晰；进阶可用 Map 优化。

4. “合法窗口”的维护策略
滑动窗口的核心是：始终保持 窗口 处于 合法状态（或快速恢复合法）。

在本题中：
① 合法 = 窗口内无重复字符
② 非法触发 = 新加入的 s[right] 已在窗口中
③ 修复方法 = 不断移除 s[left]，直到 s[right] 不再重复
🧠 关键思维：不是 先加 再检查，而是“确保 加完 仍合法”。

5. 时间复杂度分析 ———— 为什么是 O(n)？
虽然有嵌套循环（for right + while），但：

① 每个字符 最多被 right 访问 1 次
② 每个字符最多被 left 移除 1 次
③ 总操作数 ≤ 2n → O(n)
✅ 这叫“均摊分析（Amortized Analysis）”————看似嵌套，实则线性。