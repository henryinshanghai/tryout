✅ 二、你需要掌握的核心概念

==
️⃣ 状态机思想（State Machine）
这是本题 最关键的 思维模型！

由于 存在 冷冻期，每一天 你所处的“状态” 会影响 下一步能做什么。
我们不能 只用 “是否持有股票” 来 描述，还要考虑 刚卖出后的限制。

于是，我们将 每天的状态 划分为 3 种互斥状态：

状态	    |   含义	                            | 能做什么？
hold	| 当前持有股票	                    | 可以 继续持有，或 卖出
sold	| 当前刚刚卖出股票（今天卖的）	        | 明天 进入冷冻期，不能买
rest	| 当前不持有股票，且不在冷冻期（可以买） | 可以 继续休息，或 买入

💡 注意：rest 包括两种情况：
① 一直没买过
② 上次卖出 ≥ 2 天前（已过冷冻期）

==
️⃣ 动态规划（DP）状态转移
我们用 三个变量（或数组）记录 到第 i 天为止，处于 每种状态时的 最大利润：
① hold[i]：第 i 天结束时持有股票的最大利润
② sold[i]：第 i 天结束时刚刚卖出的最大利润
③ rest[i]：第 i 天结束时空仓且可买入的最大利润

🔄 状态转移方程（核心！）
    hold[i] = max(hold[i-1], rest[i-1] - prices[i])
    // 要么昨天就持有（今天不动），要么今天从 rest 状态买入（花掉 prices[i]）

    sold[i] = hold[i-1] + prices[i]
    // 今天卖出 → 昨天必须持有，今天卖得 prices[i]

    rest[i] = max(rest[i-1], sold[i-1])
    // 要么昨天就是 rest（继续休息），要么昨天刚卖出（今天是冷冻期，自动变成 rest）
✅ 注意：rest 的来源 包括 冷冻期结束（即前一天是 sold）


===
️⃣ 初始条件
① 第 0 天（第一天）：
    1.hold[0] = -prices[0] （买入）
    2.sold[0] = 0 （不可能第一天就卖出，但设为 0 不影响）
    3.rest[0] = 0 （什么都不做）
⚠️ 有些实现会 把 sold[0] 设为 负无穷，但实际 用 0 更安全（因为 不会 选它 作为起点）

===
️⃣ 最终答案
最后一天，你肯定不想 还拿着股票（因为卖了 才能赚钱），所以答案是：
    max(sold[n-1], rest[n-1])