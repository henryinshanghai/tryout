步骤：
〇 方法参数 就是 两个子链表的游标指针；
① 记录 两个子链接中 游标指针的next节点；
② 把 两个游标指针的next链接 重新连接到 预期的节点上；
    l1Cursor -> l2Cursor;
    l2Cursor -> l1OriginalNext;
③ 移动 游标指针 到 （所指向的节点）；
    l1Cursor = l1OriginalNext;
    l2Cursor = l2OriginalNext;

循环结束的条件：
    任何一个子链接的游标指针 指向了 null，说明 某个子链接的节点 用尽，
    则：归并过程结束。

📌 注意：这个函数 通常不返回 新头，而是 原地修改 l1 的结构。
因为 l1 是 主链表，l2 被“穿插”进去。其所对应的originalNext指针

===
在 LeetCode 143 中：
① 通过找中点 + 反转，我们人为构造了 len(l1) ≥ len(l2)
② 且 len(l1) - len(l2) ≤ 1
③ 合并时，每次消耗 l1 和 l2 各一个节点
④ 当 l2 用完时，l1 最多剩 1 个节点
⑤ 这个剩余节点 已经 在主链末尾，无需移动！

✅ 所以 可以安全忽略 剩余 l1