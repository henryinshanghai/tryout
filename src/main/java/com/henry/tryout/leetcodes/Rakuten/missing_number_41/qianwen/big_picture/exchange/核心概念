🧠 你需要掌握的关键概念
要理解最优解，你需要掌握以下 3 个核心思想：

==
1. 答案的范围 是有限的（关键洞察！）
设数组长度为 n。那么：缺失的第一个正整数一定在 [1, n+1] 范围内！

为什么？
① 最理想情况：数组 恰好包含 1, 2, 3, ..., n → 答案是 n+1
② 如果 缺少 任何一个 1~n 中的数 → 答案 就是 那个 最小的 缺失正整数
③ 所有 ≤0 或 >n 的数 都不可能 成为答案，可以 忽略 或 重用
✅ 结论：我们只关心 1 到 n 这 n 个正整数是否出现！

==
2. 原地哈希（In-place Hashing）
既然 不能用 额外空间，就 把 数组本身 当作哈希表！

如何做？
① 利用数组下标 0 ~ n-1 来表示数字 1 ~ n
    即：下标 i 对应数字 i+1
② 如果数字 x（1 ≤ x ≤ n）存在，就在 nums[x-1] 做标记

标记方式（常见两种）：
方法	        |   操作               |	要求
置负	        | `nums[x-1] = -	  | nums[x-1]
交换到正确位置| 把 x 放到 nums[x-1]  | 更直观，推荐初学

我们重点讲 “交换到正确位置” 法，逻辑更清晰。

==
3. 循环置换（Cyclic Sort）思想
目标：把 每个 1~n的数 x 都放到 nums[x-1] 的位置上。

例如：[3,4,-1,1]（n=4）
理想排列：[1,2,3,4] → 但我们只关心 1~4 是否 在正确位置。

操作规则：
对每个位置 i：
① 如果 nums[i] 是 1~n 之间的数，且 不在 它该在的位置（即 nums[i] != i+1）
② 并且 目标位置的数 也不是 正确的（避免死循环）
③ 就把 nums[i] 和 nums[nums[i]-1] 交换
重复 直到 无法交换。

==
✅ 解题步骤（交换法）
步骤 1：将每个 1~n 的数放到正确位置
    for (int i = 0; i < n; i++) {
        // 当 nums[i] 是 1~n 之间，且 不在正确位置 时，尝试交换
        while (nums[i] >= 1 && nums[i] <= n && nums[i] != nums[nums[i] - 1]) {
            swap(nums, i, nums[i] - 1);
        }
    }
🔍 注意条件 nums[i] != nums[nums[i] - 1]：
    防止 nums[i] == nums[j] 时 无限交换（如 [1,1]）

步骤 2：遍历数组，找第一个 nums[i] != i+1 的位置
① 如果 找到 → 缺失的是 i+1
② 如果 都没缺 → 缺失的是 n+1

===
📊 复杂度分析
项目	            分析
时间复杂度	    O(n) —— 每个元素最多被交换到正确位置一次
空间复杂度	    O(1) —— 只用常数额外变量
是否修改原数组	是（题目允许）

💡 其他方法对比
方法	            | 思路	时间	空间	是否符合要求
暴力	            | 从1开始 逐个查	O(n²)	O(1)	❌
哈希表	        | 用 Set 存所有正数	O(n)	O(n)	❌（空间超）
排序	排序后扫描	| O(n log n)	O(1)	❌（时间超）
原地哈希（本解法）	| 利用 数组下标 做哈希	O(n)	O(1)	✅

✅ 总结：你需要理解的 3 个核心
概念	                 |      作用
答案范围有限性	     | 将问题 缩小到 1~n+1，忽略 无关数字
原地哈希	             | 用 数组下标 隐式表示 “数字是否存在”
循环置换（Cyclic Sort）| 通过 交换，把 数字 放到 “属于它的位置”

这道题是 数组原地操作 的经典范例。
掌握它，你 就掌握了 “用数组下标编码信息” 这一高级技巧，对后续做「数组中重复/缺失数字」类题目（如 LeetCode 442、448、287）大有帮助！