为什么没有 显式地维护 这个映射关系？它又是 怎么 被隐式维护的呢？

===
这是一个极其深刻的问题，触及了 算法设计中“隐式建模 vs 显式存储”的核心思想。

✅ 简短回答：
我们没有 显式维护「索引 → 区间」的映射表，是因为
这个映射关系 可以通过 前缀和数组 prefixSum 在 O(1) 时间内 动态推导出来。

换句话说：前缀和数组本身 就是 这个映射关系 的压缩、高效编码。

===
🔍 详细解释
一、什么是“显式维护映射”？
如果你真的去 显式存储 每个索引 所对应的区间，代码 可能像这样：

    // ❌ 显式维护（不推荐）
    class Interval {
        int left, right;
    }
    Interval[] indexToInterval = new Interval[n];

    // 初始化时计算每个区间的左右端点
    indexToInterval[0] = new Interval(0, w[0]);
    indexToInterval[1] = new Interval(w[0], w[0] + w[1]);
    indexToInterval[2] = new Interval(w[0]+w[1], w[0]+w[1]+w[2]);
    ...
这需要：
① 额外 O(n) 空间 存储 left 和 right
② 初始化时 重复计算 前缀和两次（一次算左边界，一次算右边界）
🚫 冗余！低效！不必要！

===
二、为什么 前缀和 能“隐式维护” 这个映射？

观察区间结构：

索引i	左边界	                右边界
0	    0	                    prefix[0]
1	    prefix[0]	            prefix[1]
2	    prefix[1]	            prefix[2]
i	    prefix[i-1]（i>0）或 0	prefix[i]

💡 右边界 = prefix[i]
左边界 = prefix[i-1]（或 0）

所以，整个映射 完全 由 prefix 数组 决定！

你不需要存 (left, right) 对，因为：
① 给定 i，你可以 用 O(1) 时间 算出 它的区间：
    int left = (i == 0) ? 0 : prefix[i - 1];
    int right = prefix[i];
✅ 前缀和数组 就是 映射关系的“生成器”。

===
三、在 随机选择 时，我们 甚至不需要 知道“左边界”！
这是最精妙的地方。

我们 要解决的问题 是：
给定 随机数rand ∈ [0, total)，找到 i 使得：
    left_i ≤ rand < right_i

但注意：
① right_i = prefix[i]
② 而 left_i = prefix[i-1]（对 i≥1），且 prefix 是严格递增的

所以条件 left_i ≤ rand < right_i 等价于：
    prefix[i] 是 第一个 大于 随机数rand 的前缀和值

为什么？
① 因为如果 prefix[i] > rand，而 prefix[i-1] ≤ rand（由单调性保证），那么
    rand 必然落在 [prefix[i-1], prefix[i]) 中！
✅ 我们 只需要找 “第一个 > rand 的 prefix 值”，根本不用 显式计算 左边界！

这就是为什么 二分查找 只依赖 prefixSum[mid] <= rand 这个比较 ———— 右边界信息 已足够 确定 归属。

===
四、类比理解：电话号码簿 vs 全名列表

想象你要查 某人的电话号码：
① 显式映射：你有一个表格，每行是 (姓名, 电话) —— 完整但占空间
② 隐式映射：你有一本 按姓名排序的电话簿 —— 只存姓名+电话，
    但通过顺序 隐含了 “名字 A 到 B 之间是谁”
📞 前缀和数组 就像 这本有序电话簿：
它不直接告诉你 “索引 2 的区间是 [4,6)”，但它 让你能 快速定位 任何随机数 属于谁。

===
五、算法设计哲学：Don’t Store What You Can Compute
这是计算机科学的一条黄金法则：
    如果一个值可以 在 O(1) 或 O(log n) 时间内 从 已有数据 推导出来，就不要 单独存储它。

在本题中：
① 区间左右端点 → 可从 prefixSum 推导（O(1)）
② 所属索引 → 可通过二分查找 prefixSum 得到（O(log n)）

因此，只存 prefixSum 是最优选择：
① 空间：O(n)
② 时间：初始化 O(n)，查询 O(log n)
③ 代码简洁，无冗余

===
✅ 总结：隐式维护的机制
问题          	答案
有没有显式存区间？	❌ 没有
那映射关系存在吗？	✅ 存在，且是 确定的
存在哪里？	    🧠 存在于 前缀和数组 的数学结构中
如何使用它？	    通过 prefix[i] 表示右边界，利用 单调性 + 二分查找 反推索引
为什么可行？	    因为 区间划分 是连续、无重叠、左闭右开的，且 前缀和 天然编码了 所有分割点
💡 前缀和数组 不是“辅助数据”，它 就是 概率空间的 离散化表示 本身。

这种“用 紧凑数据结构 隐式编码 复杂关系”的思想，广泛应用于：
① 累积分布函数（CDF）
② 线段树/树状数组
③ 离散化坐标
④ 抽样算法（如 Alias Method 的简化版）