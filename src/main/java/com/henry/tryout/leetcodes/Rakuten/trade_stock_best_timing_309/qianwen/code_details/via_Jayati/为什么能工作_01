✅ 结论先行
这段代码是正确的，因为它通过 “用 dp[i-2][0] 代替 rest[i-1]” 的方式，隐式地实现了 三状态机中的 冷冻期约束。

虽然它 只用了 两个状态（持/不持），但通过 时间延迟（i-2） 巧妙规避了 状态信息丢失 的问题。

===
🔍 一、核心思想：为什么 dp[i][1] = max(dp[i-1][1], dp[i-2][0] - price[i]) 是对的？
❓ 问题本质：
① 冷冻期规则：卖出后 第二天 不能买入
② 所以：买入的前提 是 “前一天没有卖出”

但在你的 DP 中：
① dp[i-1][0] 表示 “第 i-1 天不持股”，但它 可能是因为 第 i-1 天刚卖出（即处于冷冻期）
② 如果 从 dp[i-1][0] 买入，就 违反了规则！

✅ 解决方案：
跳过“昨天”，直接看“前天”的空仓状态

因为：

① 如果第 i-1 天卖出了 → 第 i 天是冷冻期 → 不能买
② 但如果我能从 前天（i-2）的空仓状态 买入，说明：
    1.第 i-2 天结束时 空仓（dp[i-2][0]）
    2.第 i-1 天什么都没做（可能是冷冻期，也可能是继续休息）
    3.第 i 天 就可以 安全买入！
🎯 dp[i-2][0] 天然排除了 “昨天刚卖出”的可能性

===
✅ 五、为什么这种解法能 work？—— 本质总结
关键点	    | 说明
状态压缩	    | 用 dp[i][0/1] 合并了 sold 和 rest
时间补偿	    | 用 i-2 替代了 显式的 rest 状态
冷冻期建模	| dp[i-2][0] 确保 买入时 跳过了 可能的冷冻期
数学等价	    | 与 三状态法 在数值上 完全等价
💡 这是一种 “用 时间维度 换取 状态维度” 的典型技巧。

🆚 六、两种方法对比
维度	     | 你的方法（二维 + i-2）   |	三状态法
状态数	 | 2	                  | 3
冷冻期处理| 隐式（通过 i-2）	      | 显式（sold → rest）
可读性	 | 中（需理解 i-2 含义）	  | 高（状态语义清晰）
扩展性	 | 较弱（如加手续费需调整）  | 强（新增状态即可）
面试推荐	 | ✅ 可接受，但需能解释 i-2 | ✅ 更推荐（展示状态设计能力）

===
✅ 最终回答
你的解法 之所以 能正确工作，是因为 dp[i-2][0] 在数值上等于 三状态法中的 rest[i-1]，从而确保了 买入操作 只发生 在非冷冻期。
这是一种 通过 “时间延迟” 来 隐式处理 状态约束 的聪明技巧。