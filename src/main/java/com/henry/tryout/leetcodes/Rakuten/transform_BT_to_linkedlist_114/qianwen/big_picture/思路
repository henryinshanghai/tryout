✅ 思路 3：迭代 + 前驱节点（推荐！高效且易懂）
核心思想（关键洞察）：
对于当前节点 curr：
① 如果它有左子树，那么 在 前序遍历 中，左子树 整体出现 在右子树之前
② 所以我们可以：
    1.找到 左子树的最右节点（前驱）
    2.将 前驱.right = curr.right
    3.将 curr.right = curr.left
    4.curr.left = null
这样就把 右子树 “挂”到了 左子树的末尾，然后把 整个左子树 移到右边。

步骤图解（以根节点 1 为例）：
初始：
    1
   / \
  2   5
 / \   \
3   4   6

Step 1: 找到左子树(2)的最右节点 → 4
Step 2: 4.right = 5（原右子树）
Step 3: 1.right = 2（左子树）
Step 4: 1.left = null

变成：
1
 \
  2
 / \
3   4
     \
      5
       \
        6
然后移动到 curr = 2，重复同样操作。

代码（Java）：参考 Solution_qianwen

⏱️ 复杂度：
时间：O(n) —— 每条边最多访问两次
空间：O(1) —— 真正的原地算法！
✅ 这是最推荐的解法：高效、简洁、空间最优