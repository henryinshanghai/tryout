第groupIndex个分组的 首位数字 是什么意思？
什么叫做 剩余可用数字？
为什么 组号 突然被用作 排名了?

===
🔷 问题 1：“第 groupIndex 个分组的首位数字”是什么意思？
✅ 精确定义：
在 当前决策阶段（比如正在确定排列的第 1 位），我们
将 所有可能的 完整排列 按 当前位的取值 划分为 若干连续块（称为“分组”）。

“第i个分组的 首位数字” = 字典序下 第i小的、尚未被使用的数字。

🧩 举例说明（n=4, 当前在选第 1 位）：
① 所有可能的排列 按 第一位 分组：
    所有以 1 开头的排列 → 第 0 个分组 → 首位数字是 1
    所有以 2 开头的排列 → 第 1 个分组 → 首位数字是 2
    所有以 3 开头的排列 → 第 2 个分组 → 首位数字是 3
    所有以 4 开头的排列 → 第 3 个分组 → 首位数字是 4
所以：
② “第 1 个分组的首位数字” = 2
💡 注意：“首位”是 相对于 整个排列 而言的，但在 递归子问题 中，它 其实是 “当前位”。

===
🔷 问题 2：什么叫做“剩余可用数字”？
✅ 精确定义：
“剩余可用数字” = 初始集合 {1, 2, ..., n} 中，尚未被放入排列中 的那些数字。

它们 构成了 当前 可以用于 填充下一位 的 所有候选。

📌 关键性质：
① 初始时：剩余可用数字 = [1, 2, 3, 4]（n=4）
② 每 确定一位，就 从中移除 一个数字
③ 我们始终 将 它们 按升序存储（如 使用ArrayList 来 初始化为升序，并 只做删除）

🧪 例子（构造 "2314" 的过程）：
步骤	    已选数字	剩余可用数字	    说明
初始	    ""	    [1, 2, 3, 4]	全部可用
选第1位	"2"	    [1, 3, 4]	    2 已用，剩下三个
选第2位	"23"	[1, 4]	        3 已用
选第3位	"231"	[4]	            1 已用
完成	    "2314"	[]	            无剩余

✅ 所以，“剩余可用数字” 是一个 动态缩小的、有序的 候选池。

===
🔷 问题 3：为什么“组号” 突然被用作 “排名”了？
这是最精妙 也最容易困惑的地方。答案是：
    “组号” 和 “剩余可用数字中的排名” 本质上 是 同一个东西，
    因为 ‘字典序’ 强制了 分组顺序 与 数字大小顺序 一致。

🔍 详细解释：
Step 1: 字典序 决定 分组顺序
字典序规则：当前位上的数字 越小，整个排列 就 越靠前
所以，分组 必须 按 当前位数字 从小到大排列：
    [以最小可用数字开头的组] → [以次小可用数字开头的组] → ...

Step 2: 剩余可用数字 是 升序的
① 我们维护 availableDigits = [a₀, a₁, a₂, ...]，其中 a₀ < a₁ < a₂ < ...
② 所以：
    1.第 0 小的可用数字 = a₀
    2.第 1 小的可用数字 = a₁
    3.第 i 小的可用数字 = aᵢ

Step 3: 分组 与 排名 一一对应
组号（groupIndex）	对应的当前位数字	    它在剩余可用数字中的排名（0-based）
	0               最小 可用数字	        第 0 小 → availableDigits[0]
	1               第二小 可用数字	    第 1 小 → availableDigits[1]
	2               第三小 可用数字	    第 2 小 → availableDigits[2]
    ...	            ...	                ...
    i	            第 (i+1)小 可用数字	第 i 小 → availableDigits[i]

✅ 因此，“组号 i” ⇨ “选 剩余数字中 第i小的” ⇨ availableDigits.get(i)

这不是 突然用作 排名，而是 字典序 + 升序存储 共同导致的 必然对应关系。

===
🧠 用 n=4, k=9 贯穿三个概念
① 目标：找第 9 个排列 → 0-based k=8
② 第一轮：
    1.剩余可用数字 = [1,2,3,4]
    2.每组大小 = 6
    3.groupIndex = 8 / 6 = 1 → 组号 = 1
    4.“第1个分组的首位数字” = 以 第二小的可用数字 开头 = 2
    5.而 availableDigits.get(1) = 2 ✅
② 为什么 组号=1 对应 排名=1？
    1.因为 字典序 要求：先排 1xxx（组0），再排 2xxx（组1）
    2.而 2 在 [1,2,3,4] 中 正好是 第 1 小（0-based）

===
✅ 终极总结：三者关系图
    字典序规则
        ↓
    分组 必须 按 “当前位数字 从小到大” 排列
        ↓
    “第 i 个分组” ⇨ “当前位 = 第i小的可用数字”
        ↓
    我们用 升序列表 availableDigits 存储 可用数字
        ↓
    第i小的 可用数字 = availableDigits[i]
        ↓
    所以：groupIndex（组号） = i ⇒ 选 availableDigits[i]

🌟 “组号”不是 突然变成 排名，而是从 一开始
就被 字典序 定义为 “按数字大小排序的组序号”，
而 这个序号 天然等于 数字在 升序列表 中的 索引。

你现在 完全掌握了 这个 看似“魔法” 实则严密的逻辑链条！👏