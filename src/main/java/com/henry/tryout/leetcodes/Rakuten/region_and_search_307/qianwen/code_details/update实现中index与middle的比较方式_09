leetcode 307题，update()方法的实现中，为什么 <= middle，就要在左子区间中递归更新呢？
把等于号 放在else中行不行呢?

这是一个非常关键且常见的疑问！
在 LeetCode 307. Range Sum Query - Mutable（使用线段树实现）中，
update() 方法的递归逻辑里，
判断 index <= mid 时进入左子树，这个“等于号”放在左边是必须的，不能随意移到右边（即 else 中）。
下面我们详细解释原因。

===
🔍 一、线段树的基本结构回顾
线段树通常用 完全二叉树 表示，每个节点 代表一个区间 [start, end]。
① 根节点：[0, n-1]
② 对于任意节点 [l, r]：
    1.左子节点：[l, mid]
    2.右子节点：[mid + 1, r]
    3.其中 mid = (l + r) / 2（向下取整）
✅ 关键点：
    左子区间 包含 mid，右子区间 从 mid+1 开始。
这是线段树 区间划分的 标准约定。

===
🧠 二、为什么 index <= mid 要 进左子树？
因为 mid 本身 属于 左子区间的右端点！

① 如果你 要更新的位置 index == mid，那么 它确实 在 左子树所代表的区间 内。
② 所以 必须进入 左子树 递归更新。

❌ 如果你把 等于号 放到 else（即 index > mid 才进右子树，否则进左子树 → 但写成 if (index < mid)）：
    // 错误写法！
    if (index < mid) {
        update(leftChild, start, mid, index, val);
    } else {
        update(rightChild, mid + 1, end, index, val); // 当 index == mid 时，错误地进了右子树！
    }
问题来了：
① 当 index == mid 时，会进入 else 分支，调用：
    update(rightChild, mid + 1, end, mid, val);
② 但 右子树的区间 是 [mid+1, end]，而 你要更新的是 mid，mid 不在 [mid+1, end] 中！
③ 递归下去 会发现 index 不在 当前区间，可能 直接返回（或报错），导致 更新失败！

==
✅ 正确逻辑（标准写法）
    int mid = start + (end - start) / 2; // 防止溢出

    if (index <= mid) {
        // index 在左子区间 [start, mid] 内
        update(leftChild, start, mid, index, val);
    } else {
        // index 在右子区间 [mid+1, end] 内
        update(rightChild, mid + 1, end, index, val);
    }
✅ 这样保证了：任何 index ∈ [start, end] 都会 被正确路由到 包含它的子区间。

===
📌 三、为什么区间 要这样划分？（左闭右闭 + mid 归左）
这种划分方式（左子树 [l, mid]，右子树 [mid+1, r]）有以下优点：
① 无重叠、全覆盖：两个子区间 不相交，且 并集 等于 父区间。
② 避免 死循环：每次 递归区间长度 严格减小（至少减少 1）。
③ 与 数组索引 自然对齐：适用于 0-based 数组。
④ 广泛采用的标准：几乎所有 线段树教程 和 实现 都如此。

⚠️ 如果你改成“左 [l, mid-1]，右 [mid, r]”，虽然理论上可行，但：
    ① 需要处理 mid = l 时 左区间无效的问题（如 [0,0] 的 mid=0，左区间 [0,-1] 无效）
    ② 增加 边界判断复杂度
    ③ 容易出错
所以 “mid 归左” 是最稳健的选择。

===
🔁 四、验证：举个例子
假设数组 nums = [1, 3, 5, 7, 9, 11]（n=6），构建线段树。
① 根节点：[0, 5], mid = 2
    1.左子：[0, 2] → 包含索引 0,1,2
    2.右子：[3, 5] → 包含索引 3,4,5

现在要 update(2, 10)（把索引 2 的值改为 10）：
① index = 2, mid = 2 → 2 <= 2 → 进入左子树 [0,2] ✅
② 若 错误地写成 if (index < mid)，则 2 < 2 为假 → 进入右子树 [3,5] ❌
③ 右子树区间是 [3,5]，不包含索引 2 → 更新失败！

===
✅ 结论
“等于号必须放在 <= mid 这一边（即左子树）”，不能移到 else 中。

因为：
① mid 属于 左子区间的右端点；
② 线段树的 区间划分约定 是：左 [start, mid]，右 [mid+1, end]；
③ 移动等于号 会导致 索引 mid 被错误地分配到 右子树，而右子树 根本不包含 该索引，造成 更新失败。

这是线段树实现中的 一个关键细节，务必理解 其背后的 区间划分逻辑，而不是 死记代码。
💡 记住口诀：
“左闭右闭，中点归左；小于等于走左，大于走右。”