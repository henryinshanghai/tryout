✅ 算法 核心思想 回顾
① 全排列 按 首位数字 分组，每组大小 = (n−1)!
② 通过 k/groupSize 找到 当前位 应该选哪个数字
③ 用 k % groupSize 更新 k，进入下一层（剩余数字）
④ 关键技巧：k 先减 1 转为 0-based 索引

===
步骤列表：
Step 1: 预计算 阶乘数组 fact[0..n-1]
Step 2: 初始化 可用数字列表 [1, 2, ..., n]
Step 3: 将 k 转换为 0-based 索引
Step 4: 构建 结果字符串
Step 5: 从左到右 逐位确定 排列的每一位（共 n 位）
Step 6: 返回 最终构造的 排列字符串

===
💡 关键细节再强调
① 为什么 k 要减 1？
    因为分组 是 从0开始编号的。第1个排列 对应 k0=0，属于 第0组。

② 为什么 每组大小 是 (remaining−1)!？
    固定一位后，剩下的 (remaining−1)个数 全排列，共 (remaining−1)! 种。

③ 为什么用 List 并 动态删除？
    确保每次调用available.get(index)时，拿到的都会是 剩余数字中 第index小的数字（保持 字典序）。

④ 时间复杂度？
    O(n²)（n 次循环，每次 remove 是 O(n)），但 n ≤ 9，完全够用。

===
✅ 总结一句话
通过 阶乘 来 预计算 每组大小，
使用 除法 和 取余 来 逐位确定 答案，
动态维护 可用数字列表，避免 生成所有排列。

你现在不仅知道 怎么写代码，更彻底 理解了 每一步背后的逻辑！