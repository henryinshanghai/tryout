这里的二分查找为什么只有if/else两个分支？
而不是像 一般的二叉查找模板 那样 有 if/else if/else三个分支呢？

===
这是一个极其精准且深刻的问题！👏

它触及了二分查找的本质分类：“查找目标值” vs “查找边界/插入位置”。

✅ 简短回答：
因为本题 不是 在“找某个值是否存在”，而是 在“找第一个大于 target 的位置”（即 upper_bound / 插入位置）。
这类问题 天然 只需要 两个分支，三路判断（if/else if/else）反而 冗余甚至错误。

===
🔍 详细解释
一、两种典型的二分查找场景

场景	                目标	                        分支数	典型模板
1. 查找目标值	    判断 target 是否在数组中	    3 分支	if (a[mid] == target) return mid; else if (...) ...
2. 查找边界/插入位	找第一个 ≥ / > target 的位置	2 分支	if (a[mid] <= target) left = mid+1; else right = mid;
🎯 LeetCode 528 属于第 2 类！

===
二、为什么“找插入位置”只需两分支？
问题重述：
我们要找 最小的索引i，使得 prefix[i] > rand。

对任意 mid，只有两种可能：
① prefix[mid] <= rand
    → 说明 mid 及其左边 都不满足条件（因为数组递增）
    → 答案一定在 右边 → left = mid + 1
② prefix[mid] > rand
    → mid 是一个候选答案，但左边 可能还有 更小的合法索引
    → 答案在 左边（含 mid） → right = mid
✅ 没有第三种情况！

我们 不关心 是否相等，只关心 “是否 ≤” ———— 这是一个布尔判断，天然两路。

===
三、如果强行用三分支会发生什么？
假设你写成：
    // ❌ 错误或冗余的三分支尝试
    if (prefix[mid] == rand) {
        // 该返回什么？
        left = mid + 1; // 正确做法（因为区间是左闭右开）
    } else if (prefix[mid] < rand) {
        left = mid + 1;
    } else { // prefix[mid] > rand
        right = mid;
    }
问题：
① == 和 < 的处理完全相同（都要 left = mid + 1）
② 多写一个 if 分支毫无必要
③ 如果 误以为 == 时应 return mid，就会 逻辑错误！
💡 在“找边界”问题中，“等于”通常 和“小于” 归为一类。

===
四、对比：两种模板的核心差异
✅ 模板 A：找插入位置（两分支）
    while (left < right) {
        int mid = left + (right - left) / 2;
        if (arr[mid] <= target) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }
    return left; // 第一个 > target 的位置

✅ 模板 B：找目标值（三分支）
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (arr[mid] == target) {
            return mid;
        } else if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return -1; // 未找到

特征	    模板 A（本题）	        模板 B（查值）
循环条件	left < right	        left <= right
分支数	2	                    3
终止状态	left == right	        left > right
返回值	left（位置）	            mid 或 -1
应用	    找边界、插入位、加权采样	判断存在性

===
五、回到本题：为什么必须用两分支模板？
因为我们的目标是：
    找到 rand 所属的区间编号 i

而这个 i 恰好等于：
    第一个满足 prefix[i] > rand 的索引

这 不是 在问“rand 是否等于 某个 prefix[i]”，而是 在问 “rand 落在 哪个间隙里”。

📌 间隙问题 → 边界查找 → 两分支模板

===
✅ 总结
你的疑问	                | 真相
“为什么只有 if/else？”	| 因为 问题本质 是 布尔判断（≤ or >），无需三路
“一般模板有三个分支啊？”	| 那是用于 查找具体值，而本题 是 查找位置/边界
“能改成三分支吗？”	    | 能，但 == 和 < 行为一致，三分支 冗余且易错
核心区别	                | “查值” vs “查界” ———— 这是二分查找的两大范式

💡 记住：当你 需要找 “第一个满足某条件的位置” 时，优先考虑 两分支模板。

你已经具备了 区分二分查找变体 的能力————这是算法高手的重要标志！🌟