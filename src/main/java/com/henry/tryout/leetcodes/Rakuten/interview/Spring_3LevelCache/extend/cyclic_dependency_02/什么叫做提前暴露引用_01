“循环依赖要求提前暴露引用” 是 Spring 解决循环依赖问题的核心思想。这句话看似抽象，但其实非常直观。下面我们从 问题场景 → 为什么需要提前暴露 → 什么是“引用” → 如何暴露 四个层面来彻底讲清楚。
🔁 一、先看一个具体例子（A ↔ B 循环依赖）
    @Service
    public class A {
        @Autowired
        private B b;  // A 依赖 B
    }

    @Service
    public class B {
        @Autowired
        private A a;  // B 依赖 A
    }

❓ Spring 创建过程 会卡在哪里？
1.开始创建 A：
    ① 调用 new A() → A 实例化 完成（但 b 还是 null）
    ② 接下来要 注入 B → 发现 B 还没创建
2.暂停 A，开始创建 B：
    ① 调用 new B() → B 实例化完成（但 a 还是 null）
    ② 接下来要 注入 A → 但 A 还在 “半成品”状态！

⚠️ 此时：
① A 没完全创建好（等 B）
② B 也没法完成（等 A）
→ 死锁！

===
💡 二、解决方案：让 B 能“提前拿到 A 的引用”

关键突破点：
    即使 A 还没 完全初始化 好，只要 它 已经new出来了，就可以 把 它的内存地址（引用）给 B 用！
因为 Java 是 引用传递，B 拿到的是 A 的内存地址，后续 A 完成初始化 后，B 手里的引用 自然就指向 完整的 A。

✅ 这就是 “提前暴露引用” 的含义：
    在 Bean 尚未完成 整个生命周期（属性未注入、初始化未执行）时，
    就 将 其对象引用 暴露给 其他正在创建的Bean 使用。

===
🧠 三、“引用”到底是什么？
① 在 Java 中，对象变量 存储的是 内存地址（reference），不是 对象本身。
② 例如：
    A a = new A(); // a 是一个引用，指向堆中的 A 对象
    B.b = a;       // 把 a 的引用赋给 B.b
③ 即使 此时 a的属性 还是 null，但 地址 是 有效的。
④ 后续 对a的修改（如 a.b = xxx），所有 持有该引用的地方 都能看到。
✅ 所以，提前暴露的 是 “不完整对象的引用”，但 它 是 合法且可用的。

===
🛠️ 四、Spring 如何“提前暴露引用”？
Spring 并不是 简单地 把 原始对象 直接丢出去，而是通过 三级缓存机制 安全地暴露：

步骤回顾（A ↔ B）：
1.创建 A：
    ① new A() → 得到 a_raw
    ② 将 a_raw的ObjectFactory 放入 三级缓存
        singletonFactories.put("a", () -> getEarlyBeanReference("a", a_raw));
2.创建 B 时需要 A：
    ① Spring 发现 A 正在创建中（通过 singletonsCurrentlyInCreation 集合）
    ② 于是 去 三级缓存 找 A 的工厂
    ③ 调用工厂 → 得到 A的早期引用（可能是 原始对象，也可能是 代理）
    ④ 将 这个引用 放入 二级缓存，供 后续使用
3.B 成功注入 A 的早期引用
4.A 继续完成 初始化，最终放入 一级缓存

✅ 整个过程，B 拿到的 A 引用，和 最终容器中的 A 是同一个对象（或代理）。

===
五、为什么不等 A 完全创建好 再给 B？
因为 那样就无法打破循环！
① 如果坚持“必须等 A 完全初始化好 才能被使用”，那么：
    Ⅰ A 等 B → B 等 A → 永远等下去
② 而 “提前暴露引用” 打破了 这个闭环：
    Ⅰ A 先把 自己的“半成品引用” 给 B
    Ⅱ B 用 这个引用 完成 自身初始化
    Ⅲ B 初始化完 后，A 再 完成 自己的初始化
    Ⅳ 循环 被解开！

===
✅ 总结：一句话理解
“循环依赖 要求 提前暴露 引用” 的意思是：
为了让 互相依赖的Bean 能够 完成创建，Spring 必须 在 某个 Bean还未完全初始化 时，
就 将 其对象引用（内存地址）提供给 依赖它的其他 Bean 使用，从而 打破 创建死锁。

🔑 关键点提炼

概念	                说明
为什么能提前暴露？	    Java 对象 是 引用传递，半成品对象的引用 依然有效
暴露什么？	        早期引用（可能是原始对象，也可能是代理）
如何安全暴露？	    通过 三级缓存 + ObjectFactory 延迟决策
不暴露会怎样？	    循环依赖 导致 创建失败（死锁）