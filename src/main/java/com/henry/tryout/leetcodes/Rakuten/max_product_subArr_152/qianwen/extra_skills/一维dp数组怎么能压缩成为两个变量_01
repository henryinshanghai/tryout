什么情况下 一维的dp[]数组 能够 被压缩成 两个变量的形式？压缩的原理是什么?

===
✅ 一句话答案
当 DP 的状态转移 只依赖于 “前一个（或前几个）固定数量的状态” 时，就可以 用 有限个变量 代替 整个 dp 数组。

压缩的原理是：滚动更新（Rolling Variables） —— 只保留 当前计算 所需的 最近历史值。


===
🔍 一、压缩的核心条件
✅ 能压缩的前提：
dp[i] 的计算 仅依赖于 dp[i-1], dp[i-2], ..., dp[i-k]（k 是常数）
并且 不需要 随机访问 更早的历史状态（如 dp[0], dp[i/2] 等）

换句话说：状态转移 具有 “局部依赖性”。


===
🧠 二、压缩原理：滚动变量（Rolling Variables）
想象你 只需要记住 “昨天” 和 “前天”的值，就能算出 “今天”的值。

那么你 根本不需要 一本记事本（dp 数组），只需要 两张便签纸（两个变量）！

示例：斐波那契数列
    # 原始 DP（O(n) 空间）
    dp = [0] * (n+1)
    dp[0], dp[1] = 0, 1
    for i in range(2, n+1):
        dp[i] = dp[i-1] + dp[i-2]

    # 压缩后（O(1) 空间）
    prev2 = 0  # dp[i-2]
    prev1 = 1  # dp[i-1]
    for i in range(2, n+1):
        curr = prev1 + prev2
        prev2 = prev1   # 滚动：prev2 ← prev1
        prev1 = curr    # 滚动：prev1 ← curr

💡 每次 只保留 最近两个值，旧值 被 “滚动覆盖”

===
📊 三、常见可压缩场景 vs 不可压缩场景
场景	                | 是否可压缩 	|   原因
斐波那契 / 爬楼梯	    | ✅ 是	        | dp[i] = dp[i-1] + dp[i-2]（只依赖前2项）
最大子序和（Kadane）	| ✅ 是	        | dp[i] = max(nums[i], dp[i-1]+nums[i])（只依赖前1项）
打家劫舍 I	        | ✅ 是	        | dp[i] = max(dp[i-1], dp[i-2]+nums[i])（只依赖前2项）
最长递增子序列（LIS）	| ❌ 否	        | dp[i] = max(dp[j]+1) for all j < i（依赖 所有 前面状态）
背包问题（01背包一维版）|	⚠️ 特殊	| 虽用 一维数组，但 不能压缩成 O(1) 变量（需整行状态）
编辑距离	            | ❌ 否	        | dp[i][j] 依赖 dp[i-1][j], dp[i][j-1], dp[i-1][j-1]（二维，且需整行）

✅ 关键判断：是否 只需 “滑动窗口”大小 的 固定历史？

===
🔁 四、压缩的通用方法（以依赖前 k 项为例）
假设 dp[i] 仅依赖 dp[i-1], dp[i-2], ..., dp[i-k]：

① 创建 k 个变量：v1, v2, ..., vk
    v1 表示 dp[i-1]
    v2 表示 dp[i-2]
    ...
    vk 表示 dp[i-k]
② 每次计算新值 curr
③ 滚动更新：
    vk = v_{k-1}
    v_{k-1} = v_{k-2}
    ...
    v2 = v1
    v1 = curr

示例：爬楼梯（k=2）
    int prev2 = 1; // dp[0]
    int prev1 = 1; // dp[1]
    for (int i = 2; i <= n; i++) {
        int curr = prev1 + prev2;
        prev2 = prev1; // 滚动
        prev1 = curr;  // 滚动
    }
    return prev1;

===
⚠️ 五、不能压缩的典型反例
❌ 最长递增子序列（LIS）
    dp[i] = max(dp[j] + 1 for j in range(i) if nums[j] < nums[i])
① 需要访问 所有 j < i 的 dp[j]
② 无法用 固定数量变量 保存全部历史
③ 必须保留 整个 dp数组（或 用 更高级数据结构 如树状数组）

❌ 背包问题（即使是一维数组）
for (int i = 0; i < n; i++)
    for (int j = W; j >= weight[i]; j--)
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
① 虽然用一维数组，但 dp[j] 依赖 dp[j - weight[i]]（可能是 任意位置）
② 不能 进一步压缩成 几个变量，因为 需要 整行状态 做决策

===
🧪 六、如何判断一道题能否压缩？
问自己三个问题：

① dp[i] 的计算 是否只依赖于 固定的前 k 个状态？（k 是常数，不随 i 增大）
② 是否 不需要 回溯访问 dp[0..i-k-1] 的值？
③ 最终答案 是否只依赖 最后一个（或最后几个）状态？

如果三个都是 ✅ Yes，就可以压缩！


===
✅ 七、总结：压缩的本质
概念	    | 说明
空间冗余	| dp 数组中 大部分值 在 计算完 dp[i] 后 就不再使用
滚动思想	| 只保留 “活跃”的 最近 k 个状态
时间不变	| 压缩 只减少空间，不改变 时间复杂度
适用范围	| 线性 DP 中 具有“马尔可夫性”（无后效性 + 局部依赖）的问题

🌟 记住：不是 所有一维 DP 都能压缩，只有“局部依赖型” 才可以。