构建 模式串的LPS[]的过程 就是一个 精简版的KMP，用模式串 自己匹配自己。

✅ 构建 模式串的LPS[] 数组的步骤（双指针法）
设模式串 为 pat，长度为 m，LPS数组 为 lps[0..m-1]。

lps[i]的含义：
模式字符串的 以位置i为结束位置的子串的 最长公共前后缀 的长度；

准备两个指针：
指针i，用于 指向 当前遍历到的位置/当前子串的末尾/当前子串的最长前后缀的 后缀字符序列的结束位置；
指针len，用于 指向 当前子串的最长公共前后缀的 前缀字符序列的 结束位置的‘下一个位置’；

1.初始化：
    ① lps[0] = 0（只有单个字符的子串，不存在有 真前后缀）
    ② len = 0（表示 当前子串的 前缀字符序列 还不存在）
    ③ i = 1：从 第二个字符 开始计算

2.循环处理 i 从 1 到 m-1：
    ① 若 pat[i] == pat[len]：
        Ⅰ 匹配成功 → len++
        Ⅱ lps[i] = len // 最长前后缀的长度
        Ⅲ i++ // 文本指针向后移动一个位置
    ② 否则（失配）：
        Ⅰ 如果 len > 0：// 说明 还可能存在 更短的公共前后缀
            → 不移动 i，而是回退 len指针（len = lps[len - 1]） // 利用已知 LPS 信息
        Ⅱ 如果 len == 0：// 说明 子串不存在 公共前后缀
            → lps[i] = 0，i++ // 计算下一个i的lps[i]

💡 核心思想
利用 已计算的LPS值 来 避免 重复比较，类似“模式串 自己和自己匹配”。