为什么遇到右括号时，就可以通过 检查 栈顶元素 是不是 其匹配的左括号 来 判断有效性？
原理是什么?

✅ 一句话回答原理：
因为 合法的括号结构 具有 “最近未闭合的左括号 必须 与 当前右括号 匹配”的性质，
而 栈的“后进先出（LIFO）”特性 正好能 追踪 这个“最近未闭合”的左括号。

===
🔍 深入解释：为什么是“栈顶”？

🧩 1. 括号的嵌套规则 决定了 “就近匹配”
考虑一个合法字符串：{ [ ( ) ] }

① 当 我们 读到第一个 ) 时，它 必须 和 离它最近的、尚未闭合的左括号 ( 匹配；
② 如果它 去匹配 更早的 [ 或 {，就会变成 { [ ) ] } → 非法！
✅ 右括号总是 优先关闭 “最新打开但尚未关闭”的左括号
这就是所谓的 “最近未闭合原则”


📦 2. 栈 天然记录 “未闭合的左括号”，且 顺序正确
① 每遇到一个 左括号（(, [, {），我们就 把 它 压入栈；
② 此时 栈中保存的是 从外到内、按打开顺序排列的 未闭合左括号；
③ 栈顶就是 最新打开、最内层的那个左括号

示例：处理 "{[()]}"

字符	操作	        栈状态（栈顶在右）	说明
{	push	    {	            最外层
[	push	    {, [	        中间层
(	push	    {, [, (	        最内层 ← 栈顶
)	需要匹配	    ——	            必须匹配 (（栈顶）✅
]	需要匹配	    ——	            必须匹配 [（此时栈顶）✅
}	需要匹配	    ——	            必须匹配 { ✅
💡 每次 右括号出现 时，栈顶 就是 它唯一合法的 匹配对象！


❌ 3. 如果 不匹配，说明什么？
有两种非法情况：
情况 A：栈为空 → 没有左括号可匹配
① 输入：")" 或 "())"
② 说明：右括号多于左括号，或出现在开头

情况 B：栈顶 ≠ 匹配的左括号 → 类型错误
① 输入："(]"
    1.读到 ( → 栈：(
    2.读到 ] → 栈顶是 (，但 ] 应该匹配 [
    3.所以 (] 是交叉嵌套 → 非法

✅ 这正是 "([)]" 被判为 无效的原因：
① 读到 ) 时，栈顶是 [（因为 ( 先入，[ 后入，栈顶是 [）
② ) 应该匹配 (，但栈顶是 [ → 不匹配 → 返回 false


🧠 4. 为什么不用队列（FIFO）？为什么必须是栈（LIFO）？
假设用队列（先进先出）：
① 输入："([)]"
② 遇到 ( → 入队：[ ( ]
③ 遇到 [ → 入队：[ (, [ ]
④ 遇到 ) → 队首是 ( → 匹配成功 → 出队 → 队列：[ [ ]
⑤ 遇到 ] → 队首是 [ → 匹配成功
→ 队列 会错误地 认为 "([)]" 是 合法的！

❌ 但现实中 "([)]" 是非法的，因为它 不是 properly nested（正确嵌套）。
✅ 只有 栈（LIFO） 能保证 “后开的括号 先闭”，从而验证 嵌套结构的合法性。

===
📐 数学本质：上下文 无关文法（Context-Free Grammar）
括号匹配语言 属于 上下文无关语言，其文法规则为：
    S → (S) | [S] | {S} | SS | ε
而 栈 是 识别 上下文无关语言 的 标准计算模型（下推自动机，PDA）。
所以，用 栈 解决 括号匹配，不仅是 工程技巧，更是 理论必然。

===
✅ 总结：核心原理三要素

要素	                说明
1. 嵌套性	        括号 必须“后开先闭”，不能交叉
2. 最近匹配	        右括号 必须匹配 最近未闭合的左括号
3. 栈的 LIFO 特性	完美模拟 “最近未闭合”的 追踪过程
因此，检查 栈顶 是否为 匹配的左括号，就是 在验证“当前右括号 是否遵守了 嵌套规则”。

一旦你理解了这一点，不仅能做 LeetCode 20 题，还能举一反三解决：
① HTML/XML 标签匹配
② 编译器中的 作用域分析
③ 表达式求值（如计算器）
这就是算法之美！