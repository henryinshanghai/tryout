✅ 简短回答：

因为 优先队列（堆）的比较器 定义的是 “谁更小（优先级更低）”，
而 题目要求的 是 “谁更大（应该排在前面）”。

我们用 最小堆 维护 Top-K 时，
希望 堆顶 是当前 K 个中最“差”的（最该被淘汰的），
所以 比较器 要按 “淘汰顺序” 来写————这自然 与 最终输出顺序 相反。

===
🎯 对比：比较器 vs 输出顺序

场景	                    比较逻辑	            代码写法
最终输出排序（从优到劣）	频次降序，字典升序	    sort((a,b) -> freq[b]-freq[a] != 0 ? freq[b]-freq[a] : a.compareTo(b))
最小堆比较器（谁该淘汰）	频次升序，字典降序	    pq = new PriorityQueue<>((a,b) -> freq[a]-freq[b] != 0 ? freq[a]-freq[b] : b.compareTo(a))
💡 堆比较器 = 输出 排序规则 的“逆序”


✅ 总结一句话：
优先队列的比较器 定义的是 “淘汰顺序”（谁更差），
而 题目要求的 是 “展示顺序”（谁更优）————两者 天然相反。

这就是为什么 你在堆里写的规则 看起来 和题目要求 “反着来”，但结果却是 正确的！