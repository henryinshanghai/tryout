导致的问题：预选择的两个‘假定众数’可能相同；
而 Booyer-Moore投票算法 要求 两个假定众数 必须代表不同的元素。

正确手段：不预选择‘假定众数’，而是 在遍历的过程中 动态选择；
特征：
    ① ‘假定众数’ 不是预先固定的，而是 在遍历过程中 动态选择的；
    ② 只有 当 某个候选者的票数 归零 时，才会 被新元素替换；
    ③ 这样保证了 两个候选者 始终代表 不同的元素；

具体做法（保证机制）：
① count1 == 0 和 count2 == 0 是互斥的（else if 链）；
② 同一个元素 不会 同时设置 两个候选者；
③ 只有 当候选者 票数为0 时，才会被替换；
④ 新候选者 一定是 当前元素，与 现有候选者 不同；

===
可视化对比

错误方式（count=1）：
┌─────────────┐
│ c1=1, c2=1  │ ← 一开始就相同！
└─────────────┘

正确方式（count=0）：
┌─────────────┐
│ c1=空,c2=空 │ ← 都是空位
└─────────────┘
      ↓ 遍历开始
┌─────────────┐
│ c1=1, c2=空 │ ← 第一个元素填 c1
└─────────────┘
      ↓ 继续遍历
┌─────────────┐
│ c1=1, c2=2  │ ← 不同元素填 c2 ✓
└─────────────┘

===
✅ 总结

问题	                        答案
为什么 count=0 能解决问题？	延迟选择‘候选者’，避免 预先固定
核心机制是什么？	            count=0 表示空位，动态填充
如何保证候选者不同？	        else if 链式判断 + 空位检查
有什么好处？	                更鲁棒，处理边界情况更好

核心要点：
‘count=0 初始化’的本质 是 延迟选择候选者，
让 候选者 在遍历过程中 动态确定，而不是 预先固定。
这样通过 逻辑 保证了 两个候选者 始终代表 不同的元素！