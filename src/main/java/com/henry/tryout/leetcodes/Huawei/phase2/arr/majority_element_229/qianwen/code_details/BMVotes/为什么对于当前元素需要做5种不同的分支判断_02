🧩 这 5 种情况是互斥的吗？
✅ 是的！它们是 严格互斥 且 按顺序判断的。
① 使用的是 if - else if - else 结构
② 一旦 某个条件 满足，后续条件 不再检查；
③ 每个 num 只会进入 其中一种情况
💡 这就像一个“决策树”，从上到下地匹配 第一个成立的分支。


📐 它们覆盖了所有可能的情形吗？
✅ 是的！这 5 种情况 构成了一个 完备划分（complete partition）。

我们可以从逻辑上证明：
对任意 num，考虑它 与 当前 cand1, cand2 的关系 以及 count1, count2 的状态：

条件	                                                是否被覆盖
num == cand1	                                    ✅ 情况1
num == cand2（且 ≠ cand1）	                        ✅ 情况2
num ≠ cand1 且 ≠ cand2，但 count1 == 0	            ✅ 情况3
num ≠ cand1 且 ≠ cand2，count1 > 0，但 count2 == 0	✅ 情况4
num ≠ cand1 且 ≠ cand2，且 count1 > 0 且 count2 > 0	✅ 情况5
✅ 所有可能组合 都被覆盖，无遗漏！


🎯 为什么需要这 5 种情况？设计思想是什么？
这是 Boyer-Moore 投票法的精髓：用 “抵消”思想 来 找出 潜在多数元素。
① 情况1 & 2：遇到 已知候选人，支持票 +1
② 情况3 & 4：有空缺席位（count=0），把当前 num 设为新候选人
③ 情况5：三个不同元素（num, cand1, cand2）互相抵消（各 -1）

💡 关键洞察：
如果 一个元素出现次数 > n/3，那么 即使 在最坏抵消情况下，它 也不会 被完全抵消掉，
最终 会留在 cand1 或 cand2 中。


⚠ 重要提醒：投票法 只给出 “候选者”，必须 二次验证！
因为 BM 投票法 可能选出 非众数（例如 [1,2,3,4,5] 会选出两个候选，但都无效），所以最后必须：

    // 重新遍历，统计 cand1 和 cand2 的真实频次
    List<Integer> result = new ArrayList<>();
    if (count(cand1) > n/3) result.add(cand1);
    if (cand2 != cand1 && count(cand2) > n/3) result.add(cand2);
✅ 投票法的作用是 将 O(n)空间 降为 O(1)，但不能 跳过验证！

===
✅ 总结

问题	            答案
有哪 5 种情况？	1. 等于 cand1
                2. 等于 cand2
                3. count1=0 → 替换 cand1
                4. count2=0 → 替换 cand2
                5. 都不等 且 count>0 → 全部抵消
是否互斥？	    ✅ 是，if-else if 保证 只进一个分支
是否覆盖所有情形？	✅ 是，逻辑完备，无遗漏
为什么这样设计？	基于“三元抵消”思想：任何 >n/3 的元素 必能 存活到最后
是否需要验证？	✅ 必须！投票结果 只是 候选，需 二次计数 确认