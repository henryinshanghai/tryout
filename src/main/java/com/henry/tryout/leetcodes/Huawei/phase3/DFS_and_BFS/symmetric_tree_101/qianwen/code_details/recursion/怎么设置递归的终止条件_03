一、问题回顾
判断一棵二叉树是否是镜像对称的。
核心思想：
    整棵树对称 ⇨ 左子树 与 右子树 互为镜像
因此，我们设计一个辅助递归函数：
    boolean isMirror(TreeNode left, TreeNode right)
用于判断 两棵树 是否 互为镜像。

二、终结条件的设计（核心！）
我们要问：在什么情况下，无需递归 就能直接判断 “两棵树是否镜像”？

✅ 策略 1：考虑“空节点”组合（最基础、最可靠）
两棵树的根节点 可能有 以下三种情况：

left	right	是否镜像？	原因
null	null	✅ 是	    两棵空树天然对称
null	非空	    ❌ 否	    结构不对称
非空	    null	❌ 否	    结构不对称
💡 这就是所有 “无需递归” 的原子情况！

✅ 对应的终结条件代码：
// Base Case 1: 两个都为空 → 对称
    if (left == null && right == null) {
        return true;
    }

    // Base Case 2: 一个为空，另一个非空 → 不对称
    if (left == null || right == null) {
        return false;
    }
🔑 注意：这两个条件 必须先于 值比较！否则 会触发 NullPointerException。

✅ 策略 2：不要把 “值相等” 当作 终结条件！
有人误以为：
    // ❌ 错误！这不是 终结条件，而是 递归继续的条件
    if (left.val == right.val) return true;
为什么错？
① 即使 根节点 值相等，子树结构 可能不对称（如左子树有孩子，右子树没有）
② “值相等” 只是 继续递归的前提，不是 终止条件

✅ 正确做法：
① 先处理 null 情况（终结条件）
② 再检查 值是否相等（决定 是否继续递归）
③ 最后 递归检查 子树

===
四、遵守的设计策略总结

策略	                在本题中的体现
1. 从“空状态”入手	    优先处理 left == null 和 right == null 的所有组合
2. 覆盖所有原子情况	(null, null)、(null, X)、(X, null) 全部覆盖
3. 避免访问空指针	    先判空，再访问 .val
4. 终结条件必须无递归	这些情况的答案 可以直接得出，无需进一步分解

===
五、为什么 这样设计 是安全的？

我们用归纳法验证：
① 基础：空树对称（base case 成立）
② 归纳：若所有 深度 ≤ k 的子树 都能正确判断，则
    深度 k+1 的树 也能通过 比较根值 + 递归子树 来 判断
③ 终止：每次递归 都 向叶子靠近，最终必达 null，触发 base case
✅ 所以递归 必然终止，且 逻辑完备。

✅ 总结：LeetCode 101 终结条件设计口诀
“先 判空，再 判值；
两空 为真，一空 为假；
值不等 即假，否则 递归查。”