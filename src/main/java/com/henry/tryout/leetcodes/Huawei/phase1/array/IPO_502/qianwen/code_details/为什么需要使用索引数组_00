已知：
    项目 -> 项目所需投资的数组；
    项目 -> 项目所能赚取的利润的数组；
目标：
    快速获取到 所需最小投资的项目；
隐含条件：
    不能打乱 原始profits数组 与 原始capital数组 的对应关系。

==
手段1：对 projectToItsCapital 数组中的元素 进行排序；
评估：不可行；
原因：对 投资数组 排序后，会破坏 数组元素 之间 原有的对应关系。
分析：
    原始数组中：
        capital[0] 表示 项目0的所需投资；
        profit[0] 表示 项目0的利润；
    对 capital[]数组 排序后，这种对应关系 就不存在了。

==
手段2：我们不移动 原始数据，而是 对索引排序；
步骤：
    ① 为 capital[]数组 建立一个 索引数组(projectNoArr)；
    ② 然后 对 索引数组 按需排序（按照 项目成本 从小到大地 对 项目编号 进行排序）；
有意义的命名：projectNoArrSortByCostInAsc[];
效果：原始数组 未发生变化，但是 逻辑上 项目 已经 按照capital排序了；

===
✅ 总结：indices 的作用

问题	                                        indices如何解决
需要按 capital 排序项目	                    对 索引 排序，而非 原始数组
必须保持 capital[i] 与 profits[i] 的对应关系	能够 通过 capital[indices[i]] 和 profits[indices[i]] 来
                                            同时访问同一项目
避免修改输入数组	                            原始 capital 和 profits 不变
高效且节省内存	                            只用一个 Integer[] 存索引

💡 indices 是 “间接排序（indirect sorting）”的经典应用，在 需要保持 多数组同步 时 非常有用。
如果你看到类似题目（如任务调度、多维排序），记住这个技巧：
当 多个数组 逻辑上 属于同一记录 时，排序索引 而非 数据本身。
