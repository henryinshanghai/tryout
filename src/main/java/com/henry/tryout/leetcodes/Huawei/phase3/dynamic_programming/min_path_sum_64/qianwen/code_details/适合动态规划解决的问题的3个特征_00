所有适合 DP 的问题，几乎都具备以下 3 个核心特征：

===
✅ 特征 1：最优子结构（Optimal Substructure）
① 问题的最优解 可以通过 子问题的最优解 构造出来。
② 例如：
    Ⅰ 最短路径 → 子路径 也是最短的
    Ⅱ 最长公共子序列 → 子序列 的LCS 可组合
    Ⅲ 背包问题 → 前i个物品 的最优解 基于 前 i-1 个
❌ 反例：找“最长简单路径”（无环）——子路径最优 ≠ 全局最优（因为可能形成环）

===
✅ 特征 2：重叠子问题（Overlapping Subproblems）
① 递归求解时，大量子问题 被重复计算。
② 如果 子问题 彼此独立（如归并排序），则 用 分治 即可，无需 DP。
③ DP 的价值 就在于 用空间换时间，缓存 子问题结果。
🔍 判断技巧：画 递归树，看 是否有 重复节点。

===
✅ 特征 3：无后效性（Principle of Optimality / No Aftereffect）
    一旦某个状态 确定，后续决策 只与 当前状态 有关，与 如何到达该状态 无关。
① 在 LeetCode 64 中：
    Ⅰ 到达 (i,j) 的最小和是 X，
    Ⅱ 无论你 是 从 (i-1,j) 还是 (i,j-1) 来的，
    Ⅲ 从 (i,j) 到终点的最优策略 只取决于 X，不取决于 路径历史。
② 这使得我们 可以用 dp[i][j] = X 完全代表 该状态。

❌ 反例：如果 题目要求 “路径不能连续向右超过 2 次”，
那么 状态 就需要额外记录 “上一步是否向右”，
此时基础 dp[i][j] 不足以 描述状态 → 需要 扩展状态定义（如 dp[i][j][k]）。

===
DP 问题的共同特征：
1. 最优子结构
2. 重叠子问题
3. 无后效性
💡 记住：
“能 分解为 相似子问题 + 子问题 重复出现 + 子问题最优 可组合” = 动态规划适用！