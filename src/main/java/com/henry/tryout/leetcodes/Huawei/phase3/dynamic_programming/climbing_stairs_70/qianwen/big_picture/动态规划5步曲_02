✅ 动态规划五步曲（完整版）

第一步：确定 dp 数组（dp table）以及下标的含义
问自己：dp[i] 或 dp[i][j] 到底代表什么？
① 必须给出明确、无歧义的定义
② 例如：
    Ⅰ dp[i] 表示 爬到第 i 阶楼梯的方法数
    Ⅱ dp[i] 表示 以 nums[i] 结尾的最长递增子序列长度
💡 关键：定义错了，后面全错！


第二步：确定递推公式（状态转移方程）
问自己：dp[i] 如何由前面的状态推导出来？
① 找出 当前状态与之前状态的关系
② 例如：
    Ⅰ 爬楼梯：dp[i] = dp[i-1] + dp[i-2]
    Ⅱ 最大子数组和：dp[i] = max(nums[i], dp[i-1] + nums[i])
💡 技巧：画图、举小例子模拟推导过程。


第三步：dp 数组如何初始化
问自己：哪些 dp 值是已知的？边界条件是什么？
① 通常初始化 dp[0]、dp[1] 或首行/首列
② 注意：初始化必须符合第一步的定义
③ 例如：
    Ⅰ 斐波那契：dp[0]=0, dp[1]=1
    Ⅱ 爬楼梯：dp[1]=1, dp[2]=2
⚠ 常见错误：初始化值 与定义不符（如把 dp[0] 设为 1 但定义是“第 0 阶方法数”）。


第四步：确定遍历顺序
问自己：应该从前往后遍历？还是从后往前？二维数组是先遍历行还是列？
① 取决于 递推公式 依赖 哪些方向的状态
② 例如：
    Ⅰ 一维 DP（如斐波那契）：从前向后
    Ⅱ 背包问题：外层物品，内层背包容量倒序
    Ⅲ 编辑距离：从左到右、从上到下
💡 原则：计算 dp[i] 时，它所依赖的状态必须已经计算过。


第五步：举例推导 dp 数组（Debug 用）
问自己：手动模拟一个小例子，看 dp 数组是否按预期变化？
① 例如：输入 n=5，手算 dp = [0,1,1,2,3,5]
② 如果 代码结果 不符，打印 dp 数组，对比哪里出错

🔑 Carl 强调：
    “如果代码没通过，一定要打印 dp 数组！90% 的问题能通过这一步发现。”

🎯 为什么“五步曲”有效？

传统误区	        五步曲解决方案
凭感觉猜状态转移	强制 先明确定义 dp[i] 含义
初始化随意	    要求根据定义 严格初始化
遍历顺序混乱	    分析 依赖关系 确定顺序
调试靠猜	        用第五步 手动验证

===
📌 经典例题套用（LeetCode 70. 爬楼梯）
1.dp[i] 含义：爬到第 i 阶的方法数
2.递推公式：dp[i] = dp[i-1] + dp[i-2]
3.初始化：dp[1] = 1, dp[2] = 2
4.遍历顺序：i 从 3 到 n（从前向后）
5.举例验证：n=5 → dp=[0,1,2,3,5,8] → dp[5]=8 ✅


💡 总结
动态规划五步曲 = 定义 → 推导 → 初始化 → 遍历 → 验证
它不是 魔法公式，而是一个 思维脚手架，帮你把 模糊的“最优子结构” 转化为 可编码的逻辑。

正如 Carl 所说：
“动规题目，写代码前 不把 状态转移 模拟清楚，就是在 浪费时间。”