① 原始问题：判断 给定的二叉树本身 是不是 镜像对称的；
② 相似子问题：判断 该二叉树的左子树 与 该二叉树的右子树 这两棵树 是不是镜像对称的；
③ 子问题的答案 能够 用于帮助解决原始问题吗？
答：如果 左子树 与 右子树 是镜像对称的，则 原始二叉树本身 就是 镜像对称的。

因此，可以使用递归实现。
但是 子问题并不是简单地 把参数规模缩小，而是 一个双参的相似问题。

===
二、为什么能用递归？———— 核心原因

✅ 1. 问题 具有 自相似性（Self-similarity）
判断整棵树是否对称，等价于：
    “左子树” 和 “右子树” 是否互为镜像
而判断两棵树 是否 互为镜像，又可以 递归地 定义为：
① 它们的根节点值 相等
② 左子树的左孩子 与 右子树的右孩子 对称
③ 左子树的右孩子 与 右子树的左孩子 对称
👉 这就是一个 递归定义！

✅ 2. 存在 明确的 递归终止条件（Base Case）
递归必须有出口，本题的 base case 很清晰：

情况	                        是否对称
两个节点都为 null	            ✅ 对称
一个为 null，另一个非 null	❌ 不对称
两个都不为 null，但值不等	    ❌ 不对称
这些条件 天然适合 作为 递归终止判断。

✅ 3. 子问题独立且规模更小
每次递归调用 都在处理 更靠近叶子的子树，问题规模 不断缩小，
最终会到达 叶子 或 空节点，保证 递归会结束。

===
✅ 总结：为什么 LeetCode 101 能用递归？
因为 “判断一棵树 是否对称” 可以精确地 转化为 “判断 其左右子树 是否 互为镜像”，
而 “判断 两棵树 是否镜像” 又是一个 结构相同、规模更小的子问题，
并且有 清晰的终止条件。

这 完美符合 递归的三大要素：
① 自相似性（问题 可分解为 同类子问题）
② 终止条件（base case 明确）
③ 规模递减（子问题 越来越小）

💡 记住：
“对称（symmetrical）” = “左子树 与 右子树 镜像”
“镜像（mirror）” = “外侧对称 且 内侧对称”