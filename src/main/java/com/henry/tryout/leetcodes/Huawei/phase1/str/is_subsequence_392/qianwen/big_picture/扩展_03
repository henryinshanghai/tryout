三、进阶思考：如果有多次查询？
题目有个 Follow-up：
    如果有 大量 s 需要查询 同一个 t，如何优化？
这时 双指针 每次都要 O(m)，效率低。
可以 预处理t，构建 字符位置的索引表，然后 用 二分查找 加速。

需要的新概念：
① 哈希表 + 列表：记录每个字符 在t中出现的 所有位置。
② 二分查找（Binary Search）：快速找到 大于某个位置的 最小索引。

示例预处理：
    t = "ahbgdc"
    indexMap = {
      'a': [0],
      'h': [1],
      'b': [2],
      'g': [3],
      'd': [4],
      'c': [5]
    }

查询过程：
① 维护 当前字符 在 t 中的位置 pos = -1。
② 对 s 中每个字符 ch：
    1.在 indexMap[ch] 中 二分查找 第一个 > pos 的位置。
    2.如果找不到，返回 false；否则更新 pos。
时间复杂度：
① 预处理：O(m)
② 单次查询：O(n log m)
③ 适合 多次查询 场景。

🔍 这部分涉及：前缀索引、二分搜索、离线/在线查询优化。