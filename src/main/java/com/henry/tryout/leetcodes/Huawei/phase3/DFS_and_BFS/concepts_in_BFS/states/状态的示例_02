不同难度的“状态”示例

Level 1: 基础状态（仅位置）
题目：迷宫最短路径、岛屿数量。
① 场景：只要知道坐标 (x, y)，就知道 能不能走，下一步去哪。
② 状态定义：(x, y)
③ 队列元素：int[] {x, y}
④ Visited 数组：boolean[x][y]
⑤ 含义：只要到达过 (x, y)，无论怎么来的，效果都一样。


Level 2: 进阶状态（位置 + 步数/时间）
题目：LeetCode 1091 (二进制矩阵中的最短路径)。
① 场景：你 需要记录 路径长度。
② 注意：其实步数 通常不作为 visited 的判重依据
    （因为 BFS 第一次到达某点 必然是 步数最少的），
    但它是 状态的一部分，需要传给下一层。
③ 状态定义：(x, y, distance)
④ 队列元素：int[] {x, y, distance}
⑤ Visited 数组：boolean[x][y] (依然是 只使用坐标 就能去重)
⑥ 含义：distance 是状态的属性，用于 计算结果，但 不用于 定义“是否访问过”。


Level 3: 高级状态（位置 + 额外维度）
这是 BFS 最难也最精彩的地方。
当 “到达同一地点的不同方式” 会导致 “未来的可能性不同” 时，必须 把 额外信息 加入状态。

案例 A：带钥匙的迷宫 (LeetCode 864)
① 场景：你在 (x, y)，但如果你手里有钥匙 A，你可以打开门；
    如果没有，你就过不去。
② 问题：如果你 第一次空手走到 (x, y) 标记为 visited，
第二次 拿着钥匙走到 (x, y) 时，因为 被标记了 就不能走了，这就错了！
③ 状态定义：(x, y, key_mask)
    key_mask 是一个二进制数，表示 手里有哪些钥匙。
④ 队列元素：int[] {x, y, mask}
⑤ Visited 数组：boolean[x][y][1 << k] (三维数组)
⑥ 含义：
    (x, y, 无钥匙) 和 (x, y, 有钥匙) 是 两个 完全不同的状态，互不干扰。

案例 B：滑雪/冲浪 (只能向低处流)
① 场景：从高处往低处滑。
② 状态定义：
    其实只需要 (x, y)，因为 能否移动 取决于 当前高度 和 邻居高度的关系，
    这个关系是 固定的，不需要 记录在状态里。
    但如果是 “最多能滑 K 步”，状态 可能是 (x, y, remaining_steps)。


案例 C：消除游戏 (LeetCode 1210 移除盒子变体)
① 场景：不仅 看位置，还要看 连续消除了多少个。
② 状态定义：(x, y, count)