🧠 两种主流解题思路

===
✅ 思路一：哈希集合（HashSet）———— 简单直观
思路：
① 遍历链表，将每个 访问过的节点 存入 Set；
② 如果 遇到 已存在的节点 → 存在环；
③ 如果 到达 null → 无环

✅ 优点：逻辑清晰，易于理解
❌ 缺点：空间复杂度 O(n)
参考：Solution_qianwen_hashmap


===
✅ 思路二：快慢指针（Floyd's Cycle Detection）—— 最优解
核心原理：
① 初始化 两个指针：slow（每次走1步）、fast（每次走2步）
② 如果无环：fast 或 fast.next 会 先到达 null
③ 如果有环：fast 会 在环内 不断循环，最终追上 slow


🎯 为什么一定能追上？
设 环长 为 L，当 slow 进入 环时，fast 已在 环内某处。
两者 相对速度 为 1 步/轮，因此 最多 L 轮后 相遇。

✅ 时间复杂度：O(n)
✅ 空间复杂度：O(1) ← 面试推荐！