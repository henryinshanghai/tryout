伪代码：
for (int i = 0; i < k; i++) {
    int maxProfitForCurrentRound = 0;

    while (projectIndex < n && capital[indices[projectIndex]] <= w) {
        int profit = profits[indices[projectIndex]];
        maxProfitForCurrentRound = Math.max(maxProfitForCurrentRound, profit);
        projectIndex++;  // ⚠ 关键问题在这里
    }

    w += maxProfitForCurrentRound;
}

核心问题：在projectIndex 前进后，未选项目 会 永久丢失！

===
问题演示：
项目：
  A: 成本=10, 利润=50
  B: 成本=10, 利润=80
  C: 成本=100, 利润=1000

初始：w=10, k=2

你的写法：
  第1轮：A和B都可做，选B(80)，w=90
         ⚠️ A被丢弃
  第2轮：C成本100>90，不可做
         没有项目可选，结束
  最终：w=90 ❌

最大堆写法：
  第1轮：A和B入堆[50,80]，选B(80)，w=90
         ✅ A保留在堆中
  第2轮：C不可做，但堆中有A(50)
         选A(50)，w=140
  最终：w=140 ✅

===
为什么最大队列 能够 解决这个问题？

最大堆的本质：**可做项目的"待选池"**

while 循环：把 "新解锁"的项目 加入 待选池
poll 操作：从 待选池 选最好的
堆中剩余：之前没选的，继续保留

┌─────────────────────────────────┐
│  待选池（最大堆）               │
│  ┌───┬───┬───┬───┐            │
│  │ 50│ 30│ 20│ 10│  ← 累积保留 │
│  └───┴───┴───┴───┘            │
└─────────────────────────────────┘
     ↑           ↑
  之前没选    新解锁加入

===
总结

| 问题 | 答案 |
|-----|------|
| 你的写法问题？       | 未选项目 被永久丢弃，后续轮次 无法选择 |
| 为什么需要堆？       | 保存 所有"可做但未选"的项目 |
| projectIndex 作用？ | 只控制"新项目"入堆，不控制"未选项目" |
| 核心区别？           | 你的写法 每轮清空，堆写法 累积保留 |

核心要点：
① projectIndex 只负责 把 新解锁的项目 加入待选池，
② 但 之前没选的项目 必须保留在池中 供后续轮次选择。// 最大堆 正好提供了 这个"累积待选池"的功能！
