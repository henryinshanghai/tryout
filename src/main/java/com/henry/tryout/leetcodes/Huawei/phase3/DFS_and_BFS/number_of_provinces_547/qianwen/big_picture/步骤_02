✅ 解法一：深度优先搜索（DFS）
🧠 思路
1.用一个 visited[] 数组记录哪些城市已被访问。
2.遍历每个城市 i：
    ① 如果 i 未被访问 → 发现一个新省份，计数 +1
    ② 从 i 出发 DFS，标记所有与 i 连通的城市为已访问
3.最终计数 即为 省份数量。

💡 为什么有效？
① 每次 DFS 会 完整遍历 一个连通分量
② 有 多少次 “未访问节点触发 DFS”，就有 多少个 连通分量


===
✅ 解法二：广度优先搜索（BFS）
🧠 思路
① 与 DFS 类似，但 用 队列 代替 递归
② 从一个 未访问城市 开始，将 其所有连通城市 加入队列，逐层 扩展

===
✅ 解法三：并查集（Union-Find）
🧠 核心思想
① 初始时，每个城市 是一个 独立集合（parent[i] = i）
② 遍历 矩阵，如果 isConnected[i][j] == 1，就将 i 和 j 合并（union）
③ 最终，集合的数量 = 省份数量

🔧 并查集 关键操作
1.find(x)：查找 x 的根（代表元）
2.union(x, y)：合并 x 和 y 所在集合