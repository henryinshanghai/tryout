这是一个非常精准的观察！你问到了 控制流设计的本质。

在你提到的 风格 A 的 DFS 实现中：
void dfs(int x, int y, boolean[][] res) {
    res[x][y] = true;
    for (int[] di : dirs) {
        int nx = x + di[0], ny = y + di[1];
        if (nx < 0 || nx >= m || ny < 0 || ny >= n) continue;     // ← 用 continue
        if (res[nx][ny] || g[nx][ny] < g[x][y]) continue;        // ← 用 continue
        dfs(nx, ny, res);
    }
}
确实使用的是 continue，而不是 return。原因如下：

===
✅ 核心答案：
    因为这里是 在 for 循环 内部处理 “某个邻居不合法”，而不是 “整个函数要终止”。
    continue 跳过 当前邻居，继续检查 下一个方向；
    return 会直接退出 整个 DFS 函数，导致 漏掉其他方向！

🔍 详细解释
🧩 场景：当前点 (x, y) 有 4 个邻居（上下左右）
DFS 的任务是：尝试向所有 4 个方向扩展。
① 如果 某个方向（比如“上”）不合法（越界 / 已访问 / 高度不够）→ 我们应该：
    1.跳过 这个方向
    2.继续尝试 其他方向（下、左、右）
✅ 这正是 continue 的作用：结束 本次循环迭代，进入 下一次循环。

==
❌ 如果错误地使用 return 会发生什么？
    // 错误示范！
    if (nx < 0 || ...) return;  // ← 一旦某个邻居非法，整个 DFS 立刻终止！
后果：
① 假设 先检查 “上方”邻居 → 发现越界 → return
② “下方”、“左方”、“右方”邻居 完全不会 被检查！
③ 导致 搜索不完整，结果错误 ❌

💥 例如：一个格子只能往右走，但代码 先检查了 上方（非法）就 return，永远找不到 右边的路径。

==
📌 对比：continue vs return 在循环中的行为

语句	        作用范围	            效果
continue	当前循环体的一次迭代	跳过 本次循环 剩余代码，进入下一次循环
return	    整个函数	            立即 退出函数，不再执行 任何代码（包括后续循环）

==
🎯 什么时候用 return？
在 风格 B（传统 DFS） 中，return 用在 函数开头，用于 拒绝非法输入：
    void dfs(int x, int y, ...) {
        if (x < 0 || x >= m || ...) return;  // ← 整个函数无效，直接退出
        if (visited[x][y]) return;
        // ... 正常处理
    }

这里 return 是合理的，因为：
① 整个 (x, y) 就是非法的
② 没有必要 继续执行 函数体

但在 风格 A 中：
① (x, y) 是合法的（由调用者保证）
② 我们 只是 在遍历 它的邻居
③ 某个邻居非法 ≠ 整个函数要终止

===
✅ 总结

问题	                回答
为什么用 continue？	因为 只是跳过 当前不合法的邻居，还要 继续检查 其他方向
能用 return 吗？	    ❌ 不能！会导致 提前终止 DFS，漏掉 其他可行方向
continue 的作用域？	仅作用于 当前 for循环的一次迭代
这是良好实践吗？	    ✅ 是的！在“多方向探索”类 DFS/BFS 中，continue 是标准写法


💡 记住口诀：
“邻居不行？跳过它（continue）；
自己不行？退出吧（return）。”