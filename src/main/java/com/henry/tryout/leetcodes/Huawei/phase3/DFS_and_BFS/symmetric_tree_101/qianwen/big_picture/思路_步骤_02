✅ 解题思路一：递归（推荐，简洁优雅）
🧠 核心思想
定义一个辅助函数 isMirror(left, right)，判断两棵树 是否 互为镜像：
1.若两者 都为空 → 对称 ✅
2.若一个 为空、另一个 非空 → 不对称 ❌
3.若 值 不相等 → 不对称 ❌
4.递归检查：
    ① left.left 与 right.right 是否镜像
    ② left.right 与 right.left 是否镜像


===
✅ 解题思路二：迭代（用队列模拟递归）
🧠 核心思想
① 使用 队列（或栈）同时存储 需要比较的 两个节点
② 每次 取出 一对节点，检查 是否对称
③ 然后将 它们的子节点 按镜像顺序 入队：
    1.(left.left, right.right)
    2.(left.right, right.left)