这里dfs()方法的具体含义是什么？返回的值又是什么含义呢?

===
这是一个极其关键且深刻的问题！
理解 dfs() 方法的语义（含义） 和 返回值的意义，是掌握 LeetCode 第 463 题 DFS 解法的核心。


✅ 简短回答：
dfs(i, j) 的含义是：
    “从 位置 (i, j) 开始，探索 它所属的岛屿部分，并 返回 这部分岛屿的周长贡献。”
    它的返回值 表示：以 (i, j) 为起点 的 连通陆地区域的周长（即所有 暴露在外的边数）。
但 这个“简短回答” 还不够直观。
下面我们从 递归设计思想、函数契约、执行过程 三个层面深入剖析。

===
🔍 一、dfs(i, j) 的精确语义（函数契约）
我们可以把 dfs(i, j) 看作一个有 明确输入输出规范 的 黑盒函数：

项目	说明
前提条件（Precondition）	调用时，(i, j) 必须是 未访问过的陆地（grid[i][j] == 1）
功能（What it does）	    1. 标记 (i, j) 为已访问
                        2. 向四个方向探测
                        3. 累加 所有“暴露边”的数量
返回值（Postcondition）	以 (i, j) 为根的 整个连通陆地区域 的周长

💡 注意：虽然 函数名 是 dfs，但它 不是返回 “是否访问过”或“路径”，而是 直接返回 周长数值！

===
🧠 二、为什么返回值 能代表 “周长”？———— 递归分解思想

DFS 的核心是 “分而治之”：
    一个格子的周长 = 它在四个方向上 “暴露边”的 数量之和
而 每个方向的 “暴露边”数量，由 递归调用的结果 给出：
    return dfs(up) + dfs(down) + dfs(left) + dfs(right);

但这里有个 精妙设计：base case 直接返回 “该方向 是否暴露”。
Base Case 的语义：
    if (越界 || 是水) {
        return 1;   // ← 这条边暴露，贡献 1
    }
    if (已访问) {
        return 0;   // ← 内部边，不贡献
    }
所以，递归树 的 叶子节点（base case）直接提供 “边的贡献”，内部节点 只是累加。

===
❓ 常见疑问解答
Q1: 为什么 dfs 不返回“当前格子的周长”，而是 整个连通区域的？
    因为我们 只需要 整个岛屿的周长，而 题目保证 只有一个岛。
    从 任意一个陆地 出发，DFS 自然会遍历 整个岛，并 累加所有暴露边。
Q2: 如果有多个岛怎么办？
    本题保证 只有一个岛。
    如果有 多岛（如第 200 题），你需要 在外层循环中 对每个 未访问的1 调用 dfs，
    并 累加 返回值。
Q3: 为什么 base case 返回 1，而不是 在 当前格子 判断？
这是递归设计的优雅之处：
    ① 统一处理 所有方向（无需 在 当前格子 写 if 判断 上下左右）
    ② 把 “边界/水” 视为 “贡献源”，逻辑 更清晰
    ③ 避免重复代码

===
✅ 总结：dfs(i, j) 的完整含义

层面	        说明
函数名	    dfs 表示 使用 深度优先搜索 策略
参数	(i, j)  是 当前要处理的 陆地坐标
副作用	    将 grid[i][j] 标记为 已访问（防止重复计算）
返回值	    从 (i, j) 出发所能到达的 所有陆地 所组成的 连通区域的周长
核心机制	    通过 base case（水/边界）返回 1 来 统计暴露边，内部节点 累加

🌟 一句话记住：
dfs(i, j) 返回的是 “以 (i,j) 为入口的 整个岛屿片段的 周长”。