🔍 关键差异详解
1. 处理连续 无效字符的效率
假设字符串是 "......a........b"（大量标点）：
① 你的写法（lingshan）：每次循环 只移动 一个指针，需要 多次迭代 才能跳到 'a' 和 'b'
② 我的写法：两个内层 while 一次性跳到 有效字符，外层循环 只执行一次
💡 虽然总体仍是 O(n)，但在 极端情况 下（如全是标点），你的写法 会多做 很多次 无意义的循环判断。


2. 代码结构 与 意图表达
① 你的写法 把 “跳过”、“比较”、“失败” 混在一个 if-else 链中，职责 不够单一。
② 我的写法 分两步：
    1.清理阶段：确保 left 和 right 都指向 有效字符
    2.验证阶段：直接比较，失败就返回
    ✅ 这符合 “关注点分离” 原则，更容易理解、调试和修改。

3. 边界条件 安全性
① 你的写法 依赖 left < right 在每次 charAt 前成立，
    但由于 if-else 是顺序判断，只要进入 else if 分支，就说明前两个条件为假
    → 指针仍在有效范围，所以 实际是安全的。
② 但我的写法 在内层 while 中 显式检查 left < right，防御性 更强，尤其 在 后续修改 时 不易引入 越界 bug。

===
✅ 结论：哪种更好？
    推荐使用 “内层 while 跳过”的写法（即我提供的版本），原因如下：
① 意图 更清晰：先 定位 有效字符，再 比较
② 效率 略高：避免 在 连续无效字符 上 反复循环
③ 更易 维护：跳过逻辑 集中，未来 若要支持 Unicode 或 自定义 过滤规则，只需 改一处
④ 行业惯例：LeetCode 官方题解、多数教材 都采用 这种结构