为什么回退‘前缀指针’时，是 len = lps[len-1]，而不是 len=lps[i-1]呢？

这是一个非常关键且深刻的问题！理解这一点，就真正掌握了 KMP 的精髓。

===
✅ 简短回答：
因为 len 表示的是 “当前已匹配的前缀长度”，
它 对应的是 模式串的 前len个字符（即 pat[0..len-1]）。

当 pat[i] != pat[len] 时，我们要
在 pat[0..len-1] 这个 已经匹配好的前缀 中
找一个 ① 更短的、② 但仍然能 与后缀对齐的 公共前后缀————而这个长度正是 lps[len - 1]。

而 lps[i-1] 是 整个子串pat[0..i-1] 的最长公共前后缀的长度，
与 当前失配位置 无关，因此 不能用于 指导 前缀指针回退。

===
🔍 详细解释（配合图示思想）
假设我们正在计算 lps[i]（子串pat[0..i]的最长公共前后缀），
已知 lps[i-1] = len（子串pat[0..i-1]的最长公共前后缀的 长度为len）：
    ① 前缀所对应的区间：[0..(len-1)]；
    ② 后缀所对应的区间：[i-1-(len-1)..i-1] = [i-len..i-1]；
由于 前缀 与 后缀相等👇
    pat[0..len-1] == pat[i-len..i-1]（已匹配）

现在 在尝试扩展（比较 前缀指针的下一个位置len 和 子串末尾指针的下一个位置i）时👇
发现：pat[len] != pat[i] → 字符失配！

此时，我们希望找到一个 更短的长度 k < len，使得：
    pat[0..k-1]（前缀） == ‘pat[i-k..i-1]’（后缀）
这样 就可以 继续尝试匹配 pat[k] 和 pat[i]。// 核心目的！

💡 注意：
    ① pat[i-k..i-1] 是 pat[0..i-1] 的后缀字符序列，
    ② 而 pat[0..k-1] 是 pat[0..len-1] 的前缀字符序列（因为 k < len）。

由于 '''pat[0..len-1]'''（前缀字符序列） == “pat[i-len..i-1]”（后缀字符序列），
而且 ‘pat[i-k..i-1]’（更短的子序列） 一定是 “pat[i-len..i-1]”的后缀，
所以 ‘pat[i-k..i-1]’ 同时也会是 '''pat[0..len-1]''' 的 后缀！

因此，问题转化为：
    在 子串pat[0..len-1] 中，找到 其最长的真前后缀的长度
    → 按照lps[]数组的定义，也就是 lps[len - 1]
✅ 所以：len = lps[len - 1]

===
🚫 为什么不是 len = lps[i - 1]？
① lps[i-1] 表示的是 整个 pat[0..i-1]子串 的最长公共前后缀长度。
② 但我们 已经知道 pat[0..len-1] 匹配了 pat[i-len..i-1]，
现在 只是在 len 处失配。
③ 我们 要利用的是 已匹配部分（前缀 0..len-1）的内部结构，而不是整个 0..i-1。

===
✅ 总结

表达式	        含义	                                            是否用于回退
lps[len - 1]	当前 已匹配前缀pat[0..len-1] 的最长公共前后缀长度	✅ 正确！
lps[i - 1]	    整个子串 pat[0..i-1] 的最长公共前后缀长度	        ❌ 错误！

💡 核心思想：
KMP 的回退 是 “局部自相似性”的利用，不是 全局信息的跳跃。
所以必须用 len = lps[len - 1]，而不是 lps[i - 1]。