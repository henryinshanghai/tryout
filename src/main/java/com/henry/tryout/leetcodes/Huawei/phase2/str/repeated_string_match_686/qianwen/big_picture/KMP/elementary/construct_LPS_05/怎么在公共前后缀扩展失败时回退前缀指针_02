为什么回退前缀指针时，是 len = lps[len-1]，而不是 len=lps[i-1]呢？

这是一个非常关键且深刻的问题！理解这一点，就真正掌握了 KMP 的精髓。

===
✅ 简短回答：
因为 len 表示的是 “当前已匹配的前缀长度”，
它 对应的是 模式串的前 len 个字符（即 pat[0..len-1]）。

当 pat[i] != pat[len] 时，我们要在 pat[0..len-1] 这个已经匹配好的 前缀内部
找一个 更短的、但仍然能与后缀对齐的 公共前后缀 ———— 而这个长度正是 lps[len - 1]。

而 lps[i-1] 是 整个子串 pat[0..i-1] 的最长公共前后缀长度，和 当前失配位置 无关，
不能用于 指导 前缀指针回退。

===
🔍 详细解释（配合图示思想）
假设我们正在计算 lps[i]，当前状态是：
    pat[0..len-1] == pat[i-len..i-1]（已匹配）

现在比较 pat[len] 和 pat[i]（尝试扩展）时👇
结果：pat[len] != pat[i] → 失配！

此时，我们希望找到一个 更短的长度 k < len，使得：
    pat[0..k-1]（前缀） == pat[i-k..i-1]（后缀）
这样 就可以 继续尝试匹配 pat[k] 和 pat[i]。// 核心目的！

💡 注意：
    ① pat[i-k..i-1] 是 pat[0..i-1] 的后缀，
    ② 而 pat[0..k-1] 是 pat[0..len-1] 的前缀（因为 k < len）。

由于 pat[0..len-1] == pat[i-len..i-1]（相同的字符串），
而且 pat[i-k..i-1] 一定是 pat[i-len..i-1]的后缀，
所以 pat[i-k..i-1] 同时也是 pat[0..len-1] 的 后缀！

因此，问题转化为：
    在 pat[0..len-1] 中，找最长的真前后缀 → 长度就是 lps[len - 1]
✅ 所以：len = lps[len - 1]

===
🚫 为什么不是 len = lps[i - 1]？
① lps[i-1] 表示的是 整个 pat[0..i-1]子串 的最长公共前后缀长度。
② 但我们 已经知道 pat[0..len-1] 匹配了 pat[i-len..i-1]，现在 只是在 len 处失配。
③ 我们 要利用的是 已匹配部分（前缀 0..len-1）的内部结构，而不是整个 0..i-1。

===
✅ 总结

表达式	        含义	                                            是否用于回退
lps[len - 1]	当前 已匹配前缀pat[0..len-1] 的最长公共前后缀长度	✅ 正确！
lps[i - 1]	    整个子串 pat[0..i-1] 的最长公共前后缀长度	        ❌ 错误！

💡 核心思想：
KMP 的回退 是 “局部自相似性”的利用，不是 全局信息的跳跃。
所以必须用 len = lps[len - 1]，而不是 lps[i - 1]。