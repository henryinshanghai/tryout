要理解这道题的解法，建议先了解以下基础概念：

1. 子序列 vs 子串
① 子串（Substring）：必须连续。
    "ab" 是 "abc" 的子串。
② 子序列（Subsequence）：不要求 连续，但 顺序 必须一致。
    "ac" 是 "abc" 的 子序列，但 不是 子串。
✅ 本题 考察的是 子序列 匹配，关键在 保持顺序。


2. 双指针技巧（Two Pointers）
这是解决本题 最直观的方法：
① 用 两个指针 分别遍历 s 和 t。
② 当 s[i] == t[j] 时，i++（表示 s 中 当前字符 已匹配）；
③ 无论 是否匹配，j++（继续扫描 t）。
④ 最终 如果 i 走完了 s，说明 s 是 t 的子序列。

这是典型的 贪心匹配：一旦在 t 中 找到了 s的当前字符，就立即 “消耗”它，不再 回头。


3. 贪心思想
① 我们总是 尽可能早地 在 t 中 匹配 s 的字符。
② 因为只要 顺序 对，越早匹配 越不会影响 后续匹配（没有“后悔”的必要）。
③ 所以 贪心策略 是 最优 且 正确的。


4. 时间复杂度分析
① 双指针法：O(n + m)，其中 n = len(s), m = len(t)。
② 空间复杂度：O(1)。