方法一：哈希表统计（直观但非最优）
思路：
① 遍历数组，用 Map<Integer, Integer> 记录每个数字的出现次数
② 一旦某个数字的次数 > n/2，立即返回

===
方法二：排序（利用性质）
思路：
① 将数组排序
② 由于 多数元素 出现 > n/2 次，它 必定占据 中间位置
③ 直接返回 nums[n/2]

===
方法三：分治（递归）
思路：
① 将 数组 分成 左右两半
② 递归 求 左右的 “候选多数元素”
③ 合并时 统计 这两个候选 在整个区间的出现次数，返回 真正的多数元素

===
方法四：Boyer-Moore 投票算法（⭐ 最优解）
核心思想：
    多数元素 的数量 > 所有其他元素 数量之和
所以可以用“抵消”策略：
① 遇到 相同元素，计数 +1
② 遇到 不同元素，计数 -1
③ 计数归零 时，更换 候选者
最终 剩下的候选者 就是 多数元素！

为什么正确？
想象 多数元素 和 其他元素 “一对一抵消”，
最后剩下的 一定是 多数元素（因为它数量 > 一半）