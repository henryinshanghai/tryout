一、为什么 LeetCode 64 可以用动态规划？

🎯 题目回顾（LeetCode 64. Minimum Path Sum）
给定一个 m x n 的非负整数网格 grid，
从左上角 (0,0) 出发，每次只能 向右或向下 移动，
求到达右下角 (m-1, n-1) 的路径上 数字总和 最小值。

✅ 它满足动态规划的两大核心条件：
1. 最优子结构（Optimal Substructure）
    全局最优解 包含 子问题的最优解。
① 要得到从 (0,0) 到 (i,j) 的最小路径和，
    必然经过 (i-1,j) 或 (i,j-1)。
② 所以：
    minPath(i,j) = grid[i][j] + min( minPath(i-1,j), minPath(i,j-1) )
③ 这意味着：只要我们知道 上方和左方的 最小路径和，就能推出 当前位置的最优解。
✅ 这就是 典型的 最优子结构！

2. 重叠子问题（Overlapping Subproblems）
    在 递归求解过程中，同一个子问题 会被多次计算。
① 如果用暴力递归：
    Ⅰ 计算 minPath(m-1,n-1) 需要 minPath(m-2,n-1) 和 minPath(m-1,n-2)
    Ⅱ 而 minPath(m-2,n-1) 又需要 minPath(m-2,n-2)，minPath(m-1,n-2) 也需要 minPath(m-2,n-2)
    Ⅲ → minPath(m-2,n-2) 被重复计算！
网格越大，重复越严重（指数级爆炸）。
✅ 使用 DP 表（dp[i][j]）记忆化存储 每个子问题结果，避免 重复计算。

===
✅ 总结
为什么 LeetCode 64 能用 DP？
✅ 有 最优子结构：minPath(i,j) 由 左/上最优解 推出
✅ 有 重叠子问题：暴力递归 会重复计算 同一格子
✅ 满足 无后效性：只需知道 最小和，无需 路径细节
