首先查看 该01背包问题 所属的分类：
① 求 背包的’最大价值‘；
② 求 填满背包的’方案数量‘；

===
如果是类型①，则 对应的递推公式为：
    dp[j] = max(dp[j],
                dp[j - nums[i]] // 腾出 该物品所需要的空间
                    + nums[i]); // 添加 该物品的价值

===
如果是类型②，则 对应的递推公式为：
    dp[j] += dp[j - nums[i]]; // 累计方案数量

dp[5]：凑出5 的方案数量；
nums[i]：当前物品选项；
dp[5-nums[i]]：凑出(5-nums[i])的方案数量；

如果 已知：
① 当前物品选项为2，
② 凑出3的方案数量为dp[3]，
则：
    对于每一个 能够凑出3的方案，
    在该方案中 再添加上 当前物品2，
    就得到了 一个 能够凑出5的方案；
也就是说：由于当前物品为2，所以 dp[3] 可以完全累计到 dp[5]中；
推广可知，由于当前物品为nums[i]，所以 dp[5-nums[i]] 可以完全累计到 dp[5]中。

再度推广：
由于当前物品为 nums[i]，
所以 dp[j-nums[i]] 可以完全累计到 dp[j]中；

dp[j] += dp[j-nums[i]]; Bingo!
