这是一个非常深刻的问题！你注意到了两种常见的 DFS 写法风格：

🔹 风格 A：“先检查，再递归”（你的代码）
    void dfs(int x, int y, boolean[][] res) {
        res[x][y] = true;  // 先标记当前点
        for (每个邻居 nx, ny) {
            if (越界 || 已访问 || 不满足条件) continue;
            dfs(nx, ny, res);  // 直接递归
        }
    }

🔹 风格 B：“在递归入口处检查”（传统写法）
void dfs(int x, int y, boolean[][] res) {
    // 1. 边界检查
    if (x < 0 || x >= m || y < 0 || y >= n) return;
    // 2. 重复访问检查
    if (res[x][y]) return;
    // 3. 条件检查（如高度）
    if (g[x][y] < prevHeight) return;  // 注意：这里需要传入 prevHeight！

    res[x][y] = true;
    for (每个方向) {
        dfs(nx, ny, res, g[x][y]);  // 必须传递当前高度作为“前驱高度”
    }
}

===
✅ 核心区别：“当前点是否合法”由谁保证？

风格	                谁保证(x,y)合法？	            是否需要传递‘额外状态’？
风格 A（你的写法）	调用者保证 (x,y) 是合法的	    ❌ 不需要
风格 B（传统写法）	函数自己检查 (x,y) 是否合法	✅ 需要（如 prevHeight）

===
🔍 为什么 LeetCode 417 中 风格 A 更合适？

🧩 关键原因：高度比较 是 “相对当前点”的，不是“绝对阈值”
在本题中，能否移动 取决于：
    邻居高度 ≥ 当前点高度
而不是“邻居高度 ≥ 某个固定值”。
在 风格 A 中：
    ① 进入 dfs(x, y, ...) 时，(x,y) 一定是 合法且已满足条件的（由调用者确保）
    ② 所以可以 直接用 g[x][y] 作为基准，去 检查邻居
    ③ 无需传递“前一个高度”
在 风格 B 中：
    ① 如果你在 dfs 开头检查 g[x][y] >= prevHeight，
    ② 就必须 在调用时传入 prevHeight，例如：
        dfs(nx, ny, res, g[x][y]);
    ③ 这会让 函数签名 变复杂，且容易出错

===
📌 举个具体例子
假设从 (0,0)=5 出发：
风格 A：
    dfs(0, 0, res); // 调用者知道 (0,0) 是边界，合法
    → 在函数内：用 g[0][0]=5 去比较邻居

风格 B：
    dfs(0, 0, res, Integer.MIN_VALUE); // 初始高度设为极小值？
    → 在函数内：检查 g[0][0] >= prevHeight → 5 >= MIN → true
    → 然后递归时：dfs(nx, ny, res, g[0][0])
但这样初始调用 很别扭，而且 多了一个参数。

===
两种写法的优劣对比

维度	        风格 A（你的写法）	                风格 B（传统写法）
代码简洁性	✅ 更简洁（无冗余检查）	            ❌ 需要 额外参数（如 prevHeight）
逻辑清晰度	✅ “当前点一定合法”，专注处理邻居	    ⚠ 每次都要 验证自身合法性
适用场景	    多源 BFS/DFS、已知起点合法（如本题）	单源搜索、起点‘可能非法’
错误风险	    ⚠ 要求调用者 保证起点合法	            ✅ 自包含，更“健壮”
性能	✅      少一次函数调用（不进入非法点）	        ❌ 可能多调用一次（进入后立即返回）

===
🎯 为什么 LeetCode 417 选择风格 A？
1.起点一定合法：我们只从 海洋边界点 调用 DFS，这些点：
    ① 不越界 ✅
    ② 未被访问（首次调用）✅
    ③ 本身就是海洋，高度有效 ✅
2.避免传递 高度状态：不需要 在递归中 携带 prevHeight，简化设计。
3.效率略高：不会对 非法点 发起 递归调用。

💡 什么时候用风格 B？
① 起点可能非法（如用户输入坐标）
② 条件是“绝对阈值”（如“高度 > 100”）
③ 单源搜索，且 不确定 起点是否满足条件
例如：LeetCode 200（岛屿数量）通常用风格 B：
    void dfs(int i, int j, char[][] grid) {
        if (i < 0 || i >= m || j < 0 || j >= n || grid[i][j] != '1') return;
        grid[i][j] = '0';
        dfs(i+1, j, grid);
        // ...
    }
这里起点 (i,j) 可能是 '0' 或越界，所以必须‘自检’。

===
总结

问题	                            回答
为什么你的 DFS 不先检查边界/条件？	因为 调用者 保证了 (x,y) 合法，函数 只需处理邻居
和传统 DFS 有什么不同？	        传统 DFS ‘自包含检查’；你的 DFS 依赖 调用者 前置检查
哪种更好？	                    没有绝对好坏，看场景：
                                • 多源、起点合法 → 风格 A（你的写法）
                                • 单源、起点可能非法 → 风格 B
LeetCode 417 为何用风格 A？	    起点（海洋边界）天然合法，且避免传递高度状态，
                                代码更简洁高效

✅ 你的写法不是“省略了检查”，
而是“将 检查责任 上移给 调用者”————这是一种 合理且高效的 工程设计。