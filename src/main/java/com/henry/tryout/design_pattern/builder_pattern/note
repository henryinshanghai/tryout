Builder Pattern - 建造者模式

作用：构建复杂的对象；
特征：
    #1 构建复杂对象的过程是分步骤进行的，对于开发者来说，构建的过程会非常清晰。
    #2 存在一个指挥者角色 - 用于 创建出不同类型/形式的对象。
    #3 （高层次）解耦了 所构建的产品 以及 产品的构建步骤。
是：一种创建型的设计模式。
类比：
    产品 是工人生产出的零件；
    产品的构建步骤 是工人操作板上的SOP；

===
怎样建造一所房子？
#1 打好地基；
#2 砌起来围墙；
#3 封顶；
#4 安装门窗、地板、家具等

如果想要建造定制化的房子要怎么做呢？（比如不同的装修风格、房间布局等）
手段1：以House作为 基类，扩展它 来 实现不同的House；
特征：
    #1 这一般会导致 相当多数量的子类 - 子类膨胀；
    #2 如果在父类中添加新的属性，则：会导致所有House实现都需要 所有的属性（即便某个House实现可能不需要某个属性 比如公寓就不需要车库）
    #3 可能会产生参数数量很多的构造方法，而且多数参数在使用时可能只会传入null

手段2：建造者模式；
做法： 把“对象的构造代码” 从对象所属的类中拿出来，然后放在一个 叫做“建造者”的独立对象中。
特征：
    #1 所有的构造步骤 会被定义成为 一组步骤;
        打地基 buildBasis()、垒墙 buildWalls()等等
    #2 创建对象时，开发者 需要使用 建造器 来 执行#1中的一系列步骤；
    #3 #2中所需要执行的步骤，开发者可以自行配置 - 这样就可以跳过某些对当前对象不必须的步骤了

做法延伸：把 创建产品的步骤调用，抽取成一个单独的 “指挥者类”。
作用： 指挥者类 用来 规定步骤的执行顺序； 而 生成器/建造器 则只用来 提供步骤的具体实现；
特征：
    #1 这个 “指挥者类”是可选的，客户端开发者 完全可以在客户端代码中指定步骤的执行顺序。
        因此，指挥者类存在的意义是：复用 被高频使用的构造流程。
    #2 对客户端开发者来说，指挥者类 隐藏了产品/对象的建造细节。
        客户端开发者因此能够方便地创建对象 - 只需要生成一个建造者 来 与指挥者关联

===
建造者模式的结构

#1 产品（Products） 用于表示最终所生成的对象；
    特征： 不同生成器 所构造的产品， 不需要属于同一个 类层次结构或者接口。
#2 生成器/建造器（Builder） 用来 声明构造产品的 通用步骤
#3 具体生成器（Concrete Builders）用来 提供构造过程的具体实现；
    特征： 具体生成器 也可以构造 不遵循通用接口的产品。
#4 指挥者（Director）用来定义/规定 产品构造步骤的顺序；
    特征： 主要是为了 复用 被高频使用的构建步骤流程。

===
代码实现 - 生产一辆车

===
适用场景：
#1 如果 构造函数中存在有10个可选择参数，开发者调用这样的构造函数会非常不方便。则：
    可以适用 建造者模式 来 避免 “重叠构造函数”的出现？
#2 如果业务上需要各种形态的产品，并且这些个产品的制造过程相似（直摇头细节上的差异），则：
    可以使用 建造者模式
#3 如果开发者希望能够 使用多个步骤来逐步地构造产品，或者希望 能够延迟某些步骤而不会影响最终的产品
或者 通过递归调用 来 生成复杂对象时，则： 可以使用建造者模式。

===
总结：
优点：
#1 开发者能够分步骤地创建对象，从而 暂缓创建步骤 或者 递归地运行创建步骤；
#2 当开发者需要不同细节的产品时，可以 复用相同的构建步骤；
#3 符合单一职责原则： 把 产品的构造代码 从 产品的业务逻辑中，拆分出来了

缺点：
#1 增加了整体的复杂性；
#2 只能用于同一产品的不同形态 - 如果产品之间的差异太大，则不适用
#3 如果产品本身有很多种形态，会产生很多个 建造者类。

🐖 建造者模式 与 工厂模式之间的区别 - 建造者模式 更加关注 零件装配的顺序。








