Strategy Pattern: 策略模式

特征：
    #1 要求开发者 -
        #1 定义一系列的算法(Strategy),并把这些个算法放到其单独的类中【也就是 策略类】。
        #2 #1中所有的类 都要求实现“相同的策略接口”；
        #3 定义一个原始类【名字叫做上下文 Context】，它包含一个成员变量 来 存储对每一种策略的引用；
    #2 属于 行为型模式；
作用：对于client代码(使用接口类型进行编写代码)，能够在不改动代码的情况下，动态地替换所使用的算法；
启示：所谓“动态地”，基本等同于“不需要手动改代码”。

模型高层级用法：
    #1 开发者 添加一个新的 行为会随着策略对象改变而改变的context对象；
    #2 只要替换了策略对象，就能够 - 改变context对象的执行算法。

需求场景：
制作一个导航应用（类似于百度地图），用户能够输入出发地(A)与目的地（B），然后软件能够 根据不同的策略 来为游客规划不同的路径。
比如，“开车”、“公共交通”、“步行”...

应对 不同的个性化需求的策略
直接思路：维护if/else - PASS
思路2：策略模式；
上下文：
    #1 持有一个成员变量 来 存储每一种策略的引用；
    #2 上下文不执行工作，只委派工作；
    #3 上下文不负责选择策略，而是由客户端把自己需要的策略传给它；
    #4 上下文只通过接口与所有策略进行交互；
模型设计图：

Navigator
-routeStrategy
+buildRoute(A, B)   ->      <interface>
                            RouteStrategy
                            + buildRoute(A, B)
                                  |
                              |   |                 |
                            Road PublicTransport    Walking

结构说明：
#1 上下文(Context): {维护“具体的策略引用”;  特征：通过策略接口与策略实现类进行交互}
#2 策略接口：{提供给上下文一个方法，用于执行策略； 特征：所有的策略实现类都要实现它}
#3 具体策略类：{实现一个具体的策略； 特征：会有多个实现类，用来支持不同的策略变体}
#4 客户端：{使用具体的策略类 与 上下文类，来实现 在代码中动态地切换策略 特征：上下文中，需要提供一个setter 来 给client设置策略}

代码参考：StrategyPatternClient

适用场景：
场景1：开发者想要在代码运行时能够动态地切换算法时；
原理：上下文的方法调用会委托到具体的策略类。

场景2：如果存在有许多类，它们只在执行某些行为时会表现得略有不同。则：可以使用策略模式
原理：策略模式中，开发者将不同的行为抽取到独立的类中，而把原始的类组合成为同一个。 // 呀，这不跟模板模式怪像来？

场景3：如果想要把 类的业务逻辑 与 算法的实现隔离开来，则：可以使用策略模式
原理：策略模式中，所有具体的策略类都实现了统一的接口，aka，对client提供了唯一的方法。因此client编写时不需要关心具体算法

场景4 开发者想要避免因为选择算法而产生的if/else语句时。

优点：
#1 可以在运行时，切换代码背后所使用的算法；
#2 实现 算法 与 使用者 之间的隔离；
#3 开发者使用 组合（上下文类） 来 替代继承；
#4 符合开闭原则 - 不需要修改上下文，就能够为体系引入新的策略。

缺点：
#1 需要引入策略接口、上下文类等，增添了类结构的复杂度；
#2 客户端需要自行选择 合适的策略；

🐖：许多现代编程语言提供了 对函数类型功能的支持(如 Java)，这
允许开发者在一组匿名函数中，实现不同版本的算法 - 因此，也就不再需要使用策略模式了（相对而言，更见重量级）。【除非是为了可读性】

