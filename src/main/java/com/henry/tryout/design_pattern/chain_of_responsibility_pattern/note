Chain of Responsibility Pattern

特征：
    #1 存在一条 由请求的接收者 组成的链条；
    #2 能够将 请求沿着处理者链条 进行移动；
    #3 收到请求后，处理者可以： #1 处理请求； #2 并/或 将请求传递给下一个处理者。
作用：对 请求的发送者 与 请求的处理者 进行解耦。 - 属于 行为型模式

需求场景：
开发一个日志打印组件，要求：
    #1 把不同等级的日志，打印到不同的渠道（比如 终端、文件、告警渠道等）
    #2 请求必须要 经过不同的组件处理后，再决定是否需要打印？？？
流程模型：
    请求 -> 【日志等级校验 链条】 -> 打印渠道

设计#1：使用if/else 结构 来 判断日志的等级，然后根据等级 来 决定输出渠道；
特征：不灵活，一旦需求有变动，就必须得要改代码

设计#2：责任链模式
行为设计模式的特征： 会把特定的行为 转化成 一个独立对象 - 在责任链模式中，被叫做 处理者；
具体到日志场景中的用法：
    #1 日志等级检查的步骤 就可以被抽取成为 一个类 - 单方法类，方法用来执行检查操作?
    #2 把 请求相关的数据 作为参数传递给 #1中的方法；

设计关键点：
    #1 所有的处理这类 都必须要 实现同一个接口；
    #2 当前具体处理者 只需要关系 下一个包含 execute()执行方法 的处理者；
作用：
    #1 开发者能够在运行时，使用不同的处理者 来 创建出链条。 而client代码 不会与 具体的处理者类 相耦合。
推荐用法：
    #1 把所有的处理者 连接成一个链条；
    #2 链条上 每一个处理者中 都会 持有 下一个处理者的引用。
    #3 处理者的任务 - {#1 处理请求； #2 传递请求到下一个处理者(optional)}

接口设计：定义一个 日志写入接口，其中包含 checkLevel()方法 & writeTo()方法
实现类设计： 不同的渠道 实现此接口 来 判断是不是需要打印 & 需要打印到什么地方；
client用法： 使用责任链；

===
责任链模式组件构成：

#1 处理者(Handler):
作用：声明 具体处理者所需要实现的通用接口；
特征：
    #1 一般会包含一个 用来处理请求的方法；
    #2 可能会包含一个 设置链条上 下一个处理者的方法；

#2 基础处理者(base Handler)
作用：放置 所有处理者会共用的样本代码；
特征：
    #1 Optional
    #2 通常会 持有一个 链条中下一个处理者的引用（作为成员变量）
    #3 client代码中 可以使用它 来 设置链条 - 手段：把 当前处理者 传递给 上一个处理者的构造方法/设定方法；
    #4 可以实现常见的默认行为 - 如果下一个处理者存在的话，则：将请求传递给它。

#3 具体处理者（concrete handlers）
作用：编写请求的具体处理逻辑；
特征：
    #1 在接收到请求之后，需要先决定自己是不是要进行处理；
    #2 然后再决定是不是要 把请求沿着链条向下传递。
    #3 通常是不可变的，需要通过构造函数 来 一次性地获取到 所有必要的数据。

#4 客户端（client）
作用：根据开发的需求 来 一次性或者动态地生成 处理器链条；
特征：请求可以 直接发送给任何一个处理者（不一定是链条上的第一个处理者）

<interface> Handler     <-      client
    +setNext(h: Handler)        伪代码： h1.setNext(h2); h2.setNext(h3); ... h1.handle(request);
    +handler(request)
    ↑
BaseHandler
    - next: Handler
    + setNext(h: Handler)
    + handle(request)
    ↑
ConcreteHandlers
    + handler(request)

======
代码实现过程：

#1 创建 Handler 接口类型，添加 handle()方法的签名；
    作用：指明 客户端要怎么 把请求数据传递给方法；
    实践：比较好的做法是 - 把请求转换成为对象，然后把对象作为参数 传给handle()方法；

#2 根据 Handler接口 来 创建抽象处理者基类；
    作用：消除具体处理者中的样板代码；
    特征：
        #1 需要持有一个 指向 链条上的下一个处理者 的引用（成员变量）；
        #2 可以设计为 不可变类；
        #3 为了能够 在运行时对链条进行改变，需要 定义一个 set方法 来 修改成员变量的值；
        #4 可以实现 handle()方法的默认行为（optional）；
        #5 如果链条上还存在 下一个处理者，则：可以把请求传递给下一个处理者（optional）

#3 创建具体处理类，并实现处理方法；
    特征：处理方法的实现中必需包含下面两点；
        #1 是否要处理这个请求；
        #2 是不是要把此请求传递给链条上的下一个处理者；

#4 client 编写代码自行组装 处理者链条 / 或者从其他地方获取到预先组装好的链条（工厂类）。

#5 client 编写代码，来 触发处理者链条中的任意处理者
    作用：请求会沿着 处理者链条往下传递 - 直到某个处理者拒绝传递，或者到达链条的末尾

#6 client需要针对处理以下情况
    #1 链条中可能只有单个处理者；
    #2 部分请求 可能无法到达链条尾部；
    #3 有些请求 可能到达了链表尾部，仍旧没有被处理过

===
代码参考： 见代码；

===
适合场景：
#1 程序 需要 使用不同的方式 来 处理不同类型的请求，并且 client发起请求的顺序 不确定时；
    原理：链条中的每一个处理者 都会有机会对请求进行处理。

#2 当程序 必需按照顺序 来 执行多个处理者时；
    原理：请求 会严格地 按照链条上排定的顺序，以此通过 链条上的处理者；

#3 当 请求所需要的处理者 以及 处理者的执行顺序 会在运行时发生变化时；
    原理：处理者类中 有一个 对成员变量(对下一个处理者的引用)的set方法，所以 可以动态调整处理者

本质上：链表能做到什么，责任链模式就能做到什么。

===
优缺点

优点：
#1 client代码 能够根据需要 来 动态调整 请求处理的顺序；
#2 符合单一职责原则 - 发起操作者（client类） 与 执行操作者（handler类）完全解耦；
#3 符合开闭原则 - 能够在不改动现有代码的情况下，新增处理者类

缺点：
#1 可能会出现 请求经历了整个链条，但仍未被处理的情况；
#2 可能会出现 循环调用的情况；
#3 链条如果太长的，可读性会降低

