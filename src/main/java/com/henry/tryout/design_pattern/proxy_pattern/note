Proxy Pattern：代理模式

手段：开发者 创建持有既有对象的代理对象；
作用：使用代理对象 来 替代既有对象，向外提供功能接口。
延伸作用：
    #1 代理对象控制着 对原始对象的访问；
    #2 代理对象能够在请求交送给原始对象的前后，做一些额外的处理。
是：一种结构型 设计模式；

追问：为什么开发者会想要 控制外界对于某个对象的访问呢？
因为 直接访问原始对象可能会有一些麻烦：
#1 对象创建的开销很大；
#2 某些操作需要安全控制；
#3 可能会需要进程外的访问...
解决手段： 为原始对象 添加一个 访问层；

实例：客户端 用于连接数据库的连接对象，就是一个会消耗大量系统资源的巨型对象。
但客户端也不是一直使用这个对象。
这种情况下，开发者就会想要能够 延迟初始化此对象 - 等到有实际需要时，再创建出此对象。
结果：对象的所有客户端，都需要执行 “延迟初始化的代码” -> 这会导致客户端代码中出现很多重复代码
预期：把这些重复着的代码，直接放入到某个对象所属的类中；
窘境：对象所属的类，是某个第三方封闭库所提供的。无法查看和编辑。
解决方案：
    新建一个与原始服务对象拥有相同接口的代理类，然后更新应用，使用代理对象替换掉 所有的原始对象。
    作用：这样代理类接收到应用的请求后，会创建实际的服务对象，并把具体的工作委托给实际对象。
具体到数据库连接对象的例子：
    代理对象 把自己伪装成为 数据库对象，从而能够 在客户端或者实际数据库对象不知情的情况下，来 处理延迟初始化、缓存查询结果等
模型结构：
[客户端集合] <-> 代理 -> 数据库

好处：
#1 对于客户端来说，使用代理对象 与 使用原始对象没有任何差异；
#2 当需要在类的主要业务逻辑前后执行一些工作的时候，开发者只需要 在代理类中修改即可，而不需要改动客户端 或者 原始类。

===
模式结构

服务接口（Service Interface）：声明 原始类 与 代理类都需要遵守的服务接口，从而完成平替；
服务类：提供一些使用的业务逻辑；
代理类：
    应用： {#1 延迟初始化； #2 记录日志； #3 访问控制； #4 缓存...}
    特征：
        #1 持有一个 指向服务对象的成员变量；
        #2 在完成自己的任务后，会把请求传递给 真实的服务对象；
        #3 会管理 服务对象的整个生命周期；
客户端：使用服务接口，来 实现业务功能。

Client -> Service Interface - {Proxy, RealService}

===
代码实现：
#1 创建一个服务接口 来 实现代理类 与 服务类之间的可交换性。
手段1：从既有的服务类中抽取接口； 特征：不算很可行，因为需要修改客户端中的每一处 occurrence 为 使用接口类型;
手段2：把代理处理成为 服务类的子类 - 这样代理就会继承到 服务类的所有接口了。

#2 创建代理类；
    特征：
        #1 代理类中，持有一个指向服务类的成员变量；
        #2 代理类会负责 创建服务 并 管理其整个生命周期；
        #3 对于客户端怎么为代理 传递服务类，有时候会使用构造方法
#3 按照实际的需要来 实现代理方法；
    特征：多数情况下，代理在完成自己的任务后，会把 请求/工作 委派到服务对象；
#4 考虑新增一个构建方法， 用来判断client获取到的 是代理还是实际服务。
    手段：这里在代理类中添加了一个静态方法
#5 在代理类中，支持 延时初始化服务对象。

--- 代码流程 ---
#1 定义服务接口；
#2 定义真实服务；
#3 定义代理类；
#4 定义client

===
适用场景：
#1 如果存在一个偶尔才会使用到的重量级服务对象(一直保持此对象运行会消耗额外的系统资源)时，则：
    可以使用代理模式 来 延迟初始化（就是在需要的时候才new，而不是在程序启动时就创建出对象）

#2 如果开发者希望 只有特定的客户端才能使用服务对象(比如操作系统的核心部分)，则：
    可以使用代理模式 来 验证客户端身份通过后，才把请求传递给服务对象。

#3 如果开发者 想要在本地电脑上直接执行一个远端的服务（比如服务对象在远程服务器中），则：
    可以使用代理模式 - 这种情况下，代理会通过网络 来 把请求传递给服务对象

#4 如果开发者 想要记录下 所有对真实服务对象的请求记录，则：
    可以使用代理模式 来 在向真是服务传递请求之间，记录下日志

#5 如果开发者 想要缓存下来 客户端请求的结果，并对缓存进行生命周期管理时，则：
    可以使用代理模式 - 以请求参数作为 缓存的键，以返回结果 作为缓存的值。

===
优缺点

优点：
#1 代理类 与 真实服务类 分离，职责清晰；
#2 开发者能够方便地 在代理类中扩展功能；
#3 客户端不需要做任何改动，开发者就能够 控制服务对象；
#4 即使服务对象还不存在，代理也能够正常工作；
#5 符合开闭原则 {对扩展开放，对修改封闭} - 能够在不改动client的条件下，添加新的代理。

缺点：
#1 类结构的复杂性；
#2 代理的存在，可能会引入延迟。。