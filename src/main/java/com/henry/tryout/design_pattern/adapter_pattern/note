作用：作为两个接口不相互兼容的组件之间的桥梁，来支持这样两个组件交互。
是：结构型设计模式；
现实中的实例：
    #1 读卡器，作为内存卡 与 笔记本之间的适配器。支持 笔记本读取内存卡的内容
    #2 电源适配器，作为 家用220V交流电 与 电子设备之间的适配器。支持 连接220V家用电源，来直接对设备充电

开发场景：
开发一款股票市场的检测程序。
特性：从不同来源下载 XML格式的股票数据，然后向用户呈现出美观的图表。
开发决策：在程序中整合一个第三方只能分析函数库。
特征：这个分析函数库，只兼容 JSON格式的数据。
解决手段：使用适配器，来 实现JSON与XML之间的相互转换。

适配器/转换器：
是：一个设备/组件；
作用：在两个原本不兼容的设备之间，引入一个转换桥梁，使得两者之间，能够正常交互。
特征：
    #1 通过封装对象 来 把复杂的转换过程隐藏起来；
    #2 被封装的对象 甚至感觉不到适配器的存在。
工作原理：
    #1 定义适配器，持有组件B，并实现 与组件A相兼容的接口；
    #2 组件A因此可以调用 适配器中的方法；
    #3 组件A调用 适配器方法，在方法被调用后，会把请求委托给组件B。

===
模式结构

对象适配器
# 客户端： 用于包含当前程序的业务逻辑 的组件；
# 客户端接口（广义interface，表示模型之间的交互协议）：用于描述其他组件与客户端交互时，必须要遵守的协议。
# 服务端： 一些功能类；
    特征：#1 一般来自于第三方或者遗留系统； #2 与客户端所需要的接口极有可能不兼容；
# 适配器（Adapter）：一个用于适配 客户端与服务端的组件；
    特征：#1 它在实现客户端接口的同时，封装了服务端对象。
    原理：接受客户端 对适配器接口所发起的调用，然后将其转化为 对服务对象的调用。

特征：
    #1 客户端代码 只需要通过接口 与适配器进行交互即可（而不需要与具体的适配器类耦合） - 符合开闭原则；

结构图：
client -> client interface
            ^
            |
          Adapter -> Service

Adapter
- adaptee: Service
+ method(data)

======
适配器模式具体的实现方式：
#1 类适配器；
适配器类，同时继承两个对象（要求编程语言要能够支持多继承，比如C++）
特征：
    #1 适配器类不需要封装任何对象 - 因为它已经继承了 客户端&服务端的行为了
    #2 适配的过程，在重写的方法中完成

===
代码实现

经典问题： 圆孔与方钉 - 判断方形的钉子 能够打进 圆形的空中？

圆孔 RoundHole
圆形钉子 RoundPeg
方形钉子 SquarePeg
方形钉子的适配器（适配圆形的孔）SquarePegAdapter

===
适用场景

#1 如果开发者想要使用某一个类，但是这个类的接口 与 其他代码不兼容时，则：可以使用适配器类；
    原理：适配器模式 允许开发者创建一个中间层类 - 开发者可以在这个类中，完成 业务类 与 第三方类之间的接口转换

#2 如果开发者手上有一堆的类有如下特征： {#1 处于同一个继承体系； #2 其中某几个类引入了相同的额外的方法（这个方法不是所有子类共有的）}，
则：开发者可以引入适配器模式，来 复用这些类？？？

===
Java核心程序库中的适配器

Arrays.asList()
Collections.list()

XmlAdapter.marshal()

===
优缺点：

#1 优点：
# 符合单一职责原则： 客观上，把接口转换的代码，从业务程序中分离到一个新的中间层中了；
# 符合开闭原则：客户端代码 只需要通过客户端接口 来 与适配器进行交互，因此
    开发者能够在不改变先有客户端代码的情况下，引入新的适配器；
    语法：AdapterOfXxxForOoo

#2 缺点：
# 增加代码整体的复杂度（因为需要引入新的接口与类），在能够修改Service的情况下，最好直接修改Service。

