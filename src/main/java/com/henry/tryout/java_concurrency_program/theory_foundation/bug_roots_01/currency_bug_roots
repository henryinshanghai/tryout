硬件的核心矛盾： CUP > 内存 > IO设备

平衡硬件速度的差异；
手段：
    #1 CPU中增加了缓存，以 平衡与内存的速度差异；
    #2 操作系统中，添加了进程、线程，以 分时复用CPU - 平衡CPU与IO设备之间的速度差异；
    #3 编译器优化了 指令执行次序，以 更加合理地使用缓存。

正是这些 平衡硬件速度差异的手段，引发了 并发编程的N多问题；

------
#1 缓存 导致的可见性问题

可见性：一个线程对于共享变量的修改，其他的线程能够马上看到。
问题：由于每个CPU中都有自己的缓存，所以 线程A对变量x的修改，对线程B并不是马上可见的。
代码demo: CacheVisibleIssue

#2 线程切换 导致的原子性问题
操作系统为了充分使用CPU
    手段：多进程，分时复用CPU； CPU的执行时间被分成了很多小的时间片
    原理：
        1 进程A如果需要IO操作，则：主动让出CPU的使用权，进入休眠状态；
        2 等IO操作完成，操作系统再来 唤醒休眠状态的进程 - 进程A就有机会再次获得CPU使用权了。
        3 如果多个进程都在读取IO，那：这些操作就会排队 - IO的使用率也因此提高

fact：现代操作系统中，任务切换 等价于 线程切换。

原子性：一个操作或多个操作，在CPU执行过程中不被中断的特性。
线程切换导致原子性问题的原理：
    某些不具有原子性的操作，可能因为 线程切换而被中断 - 从而导致非预期的结果。

#3 编译优化 导致的有序性问题
由于 CPU 与 内存速度的差异，编译器会 对读写指令做优化。从而减少交互次数
代码demo： 使用双重检查锁 来 创建单例对象 的issue - Singleton
根本原因：
    1 new实例对象不是一个原子性操作(事实上有3步)；
    2 这3步的执行其实没有固定的顺序。
直接问题： user可能会获取到一个未被真正初始化的引用,进而NPE



