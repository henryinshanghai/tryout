当创建一个新的FutureTask时，它的任务状态 会初始化为NEW；
当 把任务提交到线程/线程池 之后，会有一个线程来执行 这个FutureTask任务 - 手段：运行线程的run()方法。

在任务执行的过程中，如果有其他的线程(比如说main线程)调用 FutureTask的get()方法 - 来获取任务执行的结果。
    若 当前任务还在执行中，则：调用get()方法的线程会被阻塞，然后被放进 FutureTask中内部持有的阻塞链表队列；
        如果多个线程同时调用get()方法，则：这些线程都可能 被阻塞，然后被添加到 阻塞队列中。

    任务执行完毕后，会：
    - 1 把执行结果或异常信息 添加到 outcome变量中；
    - 2 移除并唤醒 FutureTask的阻塞队列中的线程节点 - 这些被阻塞的线程随之而被激活。

===
FutureTask的局限性：
1 不能清楚地表示 多个FutureTask之间的关系；
2 获取任务的执行结果时，main线程会被阻塞 - 这是我们所不想要的；

---
期望：
1 能够把多个异步计算 结合成为一个（不管这些个异步计算之间是不是相互独立的）；
2 支持 反应式编程；
    特征：
        - 1 当任务计算完成后能够进行通知；
        - 2 任务的计算结果可以 作为一个参数 传递给下一个任务(继续运算)；
        - 3 调用线程有更灵活的方式来 获取任务的执行结果 - 而不只是会导致阻塞的get()方法；
3 能够通过编码的方式来 手动设置Future的结果；

解决方案：CompletableFuture