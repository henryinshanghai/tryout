如何设计模型？
概念：实体、值对象、聚合、领域服务、应用服务等
故事三要素：{背景、角色、事件}

---
角色的实现：{实体、值对象}
实体：能够通过 唯一标识符 来识别出来的对象；
特征：在业务过程中，有完整的生命周期；
示例：电商平台上的订单；

值对象：用来表示一个值；
示例：订单地址；
特征：
    #1 在判等时，只有当两个值对象的所有属性都相等时，才会认为它们相等；
    #2 值对象是不可变的 —— 一旦某一个属性发生了变化，则：会生成一个全新的值对象。
用法：把值对象 设置成 一个不可变的对象；
应用：真实代码场景中，很多本来应该使用一个值对象的地方 开发者使用了基本类型；
    示例：价格字段使用double类型、手机号码字段使用String类型；
    问题：基础类型本身是没有任何行为的，因此开发者为了业务而手动添加的行为会遍布到client代码的四处
    原则：好的封装 应该是基于行为的 -> 没有行为的对象是贫血的

---
设定不同角色之间的关系
一个问题：对于那些包含对象属性的对象，在取出时，是不是应该把它的对象属性一并取出呢？
等价问题：在介绍某一个角色时，要不要把它周围其他的角色都介绍一遍呢？
答：对于一对多的对象场景，
    #1 如果对象之间存在聚合关系(作为一个整体，同生共死)，则：一次性取出所有属性；
    #2 如果对象之间不存在聚合关系，则：使用ID取出顶层对象即可。

---
角色之间的发生的事件 - 领域事件
动词： 领域服务
名词： 领域对象/聚合根
常用结构： v. + n.

示例：
#1 创建对象；
原则：聚合中的所有子对象，都应该从聚合根中创建 - 以此保证它们的关联关系；
示例：
    #1 创建订单项；
    预期手段：调用 订单类中的"订单项工厂方法"；
    #2 创建聚合根对象；
    预期手段：有领域服务 来 充当工厂的角色。

#2 存储领域对象；
手段：使用 Repository进行持久化(CRUD)的操作。

===
目标：表示软件系统的核心业务；
手段：构建出 业务对应的领域服务；

目标：连接 系统用户 与 系统的核心业务；
手段：应用服务；

---
应用服务：
作用：协调不同的领域对象 与 领域服务，从而完成客户端所需要的业务动作。
用法：把所有与业务逻辑无关的内容放进应用服务中 - 监控、身份认证等
特征：不会包含业务服务；

图书： 《领域驱动设计精粹》 《实现领域驱动设计》

Recap:
战术设计的六个步骤：
    #1 识别出实体与值对象；
    #2 根绝角色之间的关系，来创建聚合；
    #3 角色所发出的动作 - 领域服务；
    #4 动作的结果/目的 - 领域事件；
    #5 对象的创建与存储 - 工厂 与 仓库；
    #6 应用服务 - 通用的、与业务无关的额外动作

