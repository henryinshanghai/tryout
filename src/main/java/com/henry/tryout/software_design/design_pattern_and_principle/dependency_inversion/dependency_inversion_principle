什么叫做依赖？
如果实现组件A时，使用到了组件B提供的能力，则称：组件A 依赖于 组件B。

鉴于开发者编写代码就是需要站在其他人的肩膀上，所以依赖不可避免。
但是怎么能够更好地管理依赖呢？
答：依赖倒置原则 Dependency Inversion;

===
依赖倒置原则描述：
#1 “高层模块”不应该依赖于"低层模块"，两者都应该依赖于 “抽象”；
#2 “抽象”不应该依赖于“细节”，“细节”应该依赖于“抽象”。

术语：{高层模块, 低层模块, 抽象, 细节}

---
#1 “高层模块”不应该依赖于"低层模块"，两者都应该依赖于 “抽象”；

常见问题1（正常的依赖方式）：高层模块 会依赖于 低层模块；
代码示例：CriticalFeature

常见问题2：代码直接耦合在具体实现上；
使用Kafka发送消息的代码示例 Handler
Kafka虽然很好，但却不是系统中最核心的部分 - 将来可能会被替换掉的。
为什么Kafka这种好东西都可能被替换掉呢？
原理：软件设计关注长期，所以那些不在自己掌控之内的东西，都是可能被替换掉的。
像是Kafka这种中间件，就有被替换掉的可能。
因此，系统依赖于一个可能会变得东西，设计上讲，不是一个好的做法。

所以，怎么办呢？
答：对于系统所需要依赖，倒置它们；
啥叫倒置？
答：不同于习惯性的做法，倒置时，高层模块不再依赖于底层模块。- 解除了高层模块/组件 与 低层模块/组件 之间的耦合。
追问：但高层模块如果不依赖于低层模块，要怎么实现自己的功能呢？比如上面的case，不依赖于Kafka，要怎么发出消息呢？
答：计算机科学中的所有问题，都可以通过引入一个中间层来解决；
All problems in computer science can be solved by another level of indirection.

对于 依赖倒置原则来说，它的“中间层”就是：在高层模块 与 低层模块中间，引入一个“抽象”/模型；
手段：在系统中，设计一个新的模型 - 模型的作用就是 低层模块在高层模块中所承担的角色。
示例：对于上述的case, Kafka在高层模块中的角色/作用为 消息发送者，则：我们需要引入/设计一个 消息发送者的模型；
代码demo: new_design_and_client_usage

新设计的好处：
#1 高层模块(NewDesignHandler) 不再直接依赖于 低层模块(KafkaProducer);
#2 低层模块(KafkaProducer) 会依赖于 由高层模块定义好的抽象(MessageSender); => 高层模块 与 低层模块之间解除耦合。
#3 高层模块不直接依赖于低层模块所衍生的好处 - 替换低层模块时，高层模块不会受到影响

原设计的依赖图：
Handler -> KafkaProducer

新设计的依赖图：
NewDesignHandler -> MessageSender[引入的抽象]
                        ^
                        |
                    KafkaMessageSender

---
#2 “抽象”不应该依赖于“细节”，“细节”应该依赖于“抽象”。
简单来说，代码应该 “依赖于抽象”。

以此推导出的更具体的编码原则（How?）：
#1 任何变量 都不应该 指向一个具体的类；
#2 任何类 都不应该 继承自具体类；
#3 任何方法 都不应该 改写父类中已经实现的方法(算是一个抽象?)。

===
#1 使用设计原则，开发者可以设计出一个个具体的业务模型；
#2 根据DIP的设计原则，client code应该尽可能地依赖于抽象；
疑问：{开发者要怎么使用具体实现类(毕竟它们才是真正完成工作的实体)}
答：开发者需要 把设计出的业务模型给拼装起来 - 拼装时，所拼装的就是具体实现类了。
具体到Java的世界，拼装的工作不是开发者手动完成的，而是 DI容器。

DI(Dependency Injection)容器 = IoC(Inversion of Control)容器
为什么 依赖 是可以注入的？
答：在进行设计时，遵守了 {依赖倒置原则 - 客户端使用抽象编程，而组装时使用具体实现类进行组装}。
由于高层模块 与 低层模块没有直接的依赖，因此 可以使用注入的方式 来 注入低层模块。

DIP的解读：don't call us, we'll call u.
框架的特性：
    #1 框架 提供了稳定的抽象(定义了接口)；
    #2 框架会调用 有开发者提供的各种代码实现；比如Spring
工具的特性：
    #1 工具 提供了具体的实现；
    #2 开发者使用工具时，会直接调用工具提供的各种API； 比如Junit

回顾 interface_segregation章节：
新的设计中，业务类(TransactionHandler)不再依赖于具体实现类(TransactionRequest)，而是依赖于接口(TransactionRequest)；

评估项目中的依赖关系的好坏：
#1 使用工具 来 生成项目的依赖关系图；
#2 以DIP作为标准，衡量项目中的类 在依赖关系上的表现怎么样；

===
recap:
#1 DIP = Dependency Inversion Principle; 依赖倒置原则
    #1 高层模块 不应该 依赖于低层模块，两者都应该依赖于抽象；
    #2 细节(具体实现类) 应该依赖于抽象；
#2 DIP的推论 - {变量不该指向具体类, 类不应该继承自具体类, 子类不该改写父类中的方法}
