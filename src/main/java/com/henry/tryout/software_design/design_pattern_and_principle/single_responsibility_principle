指导编写代码的一些具体原则 - SOLID原则

是：一些推荐性的规范；
作用：
    #1 指导开发者进行模块设计 - 对于OOP来说，模块设计指的就是类的设计；
    #2 用来评估开发者设计结果的有效性；
具体拆解：
    #1 S for Single responsibility principle(单一职责原则); SRP
    #2 O for Open-Closed principle(开放封闭原则); OCP
    #3 L for Liskov substitution principle(Liskov替换原则); LSP
    #4 I for Interface segregation principle(接口隔离原则); ISP
    #5 D for Dependency inversion principle(依赖倒置原则); DIP

单一职责原则的解释：
    版本1：一个模块应该 有且仅有 唯一一个变化的原因;
    版本2：一个模块应该 对某一类且仅对此一类行为者负责；
解读：一个模块最理想的情况是不改变，其次是少改变；
推论：如果一个模块频繁地发生变化，则：必然是因为有很多导致它变化的原因。

======
单一职责原则的应用
当前存在的类：User
依据单一职责原则，最终分解得到的类：User + Member;

需求*1：增加电话号码；
这其实是一个用户管理的需求，类似的需求有：用户实名认证、用户组织归属等

需求*2：查看用户参与了多少项目；
这其实是一个项目管理的需求，类似的需求有：团队管理、项目权限

这是两类完全不同的需求，但却被丢到了同一个模块/类中。
解决手段：分离需求的不同类型，然后把不同类型的需求所引起的变动 拆分到不同的模块中。
用户管理需求 -> User类
项目管理需求 -> Member类

对于开发者来说，需要识别变化的不同来源 aka 分离关注点；
原则上讲，关注点分离地越细致,得到的小类就会越多,稳定的类也会越来越多。

什么样的内容应该被组织到一个类中呢？
第二版中对单一职责原则的定义 - 一个模块应该且仅应该 对单一的某一类行为负责。
也就是说，提出变化需求的应该是同一类人。而不应该是不同group的人

真实场景中，需求的来源：提出需求的人可能来自于不同的部门；
特征：不同的人提出需求时，需求本身的关注点是不同的。
定律：一个组织所设计出的软件系统，系统的结构会受限于组织自身的沟通结构。
推论：一个软件系统的最佳结构，高度依赖于使用此软件的组织的内部结构(不同的部门)。

单一职责原则的推广应用：把高层级的职责分配到不同的子系统中/利用子系统来承接不同的职责；
实例：对于一个交易平台软件系统
    #1 它的核心模型是：手续费率 - 会频繁地发生变化
    #2 基于单一职责设计原则，设计如下：
        交易子系统：只负责读取手续费率；
        运营子系统：负责设置/更新手续费率；
正确使用单一职责原则的条件:
    #1 理解封装 - 把哪些信息放在一起；
    #2 理解拆分关注点； - 把哪些信息拆分开来；
    #3 理解变化的来源； - 如果代码A与代码B所负责的行为者不同，则：把代码A与代码B放在不同的地方。

===
Recap:
#1 单一职责原则 Single Responsibility Principal;
    版本1：一个模块应该 只有一个 导致它变化的原因；
    版本2：一个模块应该 只负责 某一类行为者的需求；
#2 单一职责原则的应用：
    #1 衡量函数设计；
    #2 衡量类的设计；
    #3 衡量系统设计；
单一职责作为一把尺子，能够衡量出现有设计的好坏。