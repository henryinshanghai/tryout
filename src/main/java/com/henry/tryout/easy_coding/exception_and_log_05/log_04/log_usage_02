日志的正确用法：
1 开发者需要 先预判 日志的级别(代码层面)；
    对于 debug或者info级别的日志，必须使用 条件输出 或者 使用 占位符的方式 打印。
    原因：
        #1 使用 占位符的方式 能够避免 字符串拼接的操作；
        #2 如果 在应用中 配置了 日志的打印级别 为 warn，则：
            在代码中添加的 debug级别的日志 就不会被打印。- 就只会 白白地浪费 系统资源

2 避免 日志语句 被重复打印(项目配置 层面)；
    - 生产环境 禁止输出 Debug级别的日志 & 有选择地输出 info级别的日志；
    控制 debug或者info级别的日志 输出量，避免 磁盘空间不足的问题。

    目标：避免 日志重复输出；
    手段：在 日志配置文件 中添加 additivity=false???
==
✅ 六、总结
配置	                        |       行为
additivity="true"（默认）	|   日志 会同时输出 到 当前logger的appender 和 所有祖先logger的appender
additivity="false"	        |   日志 只输出到 当前logger的appender，不向上传递

💡 记住一句话：
“设为 false，日志不冒泡；设为 true，日志会叠加。”
合理使用 additivity="false"，可以避免 日志重复、实现 精细化 日志路由，是 生产环境日志配置 的重要技巧。
==

3 正确的使用 日志级别(代码层面)；
    fact:
        1 对于 user输入参数错误 的场景，记录日志 是为了 在user咨询时 可以 还原现场；
        2 error级别的日志 表明：需要 人为介入(设计初衷) - 所以(用法)Error级别 只记录 系统逻辑错误、异常 或者 违反重要的业务规则；
    其他的情况 都可以归为 Warn级别。

4 保证日志 记录足够多的内容(代码层面)
    - #1 现场的上下文信息；
    - #2 异常堆栈信息；logger.error("xxx"+e.getMessage, e)
    好的做法：如果在日志中 输出了对象实例，一定要确保 对象重写了 toString()方法。否则 打印hashCode结果，没有意义

wrap up:
使用好日志的几个实践：
#1 代码层面：
    ① 使用 正确的日志级别;
    ② 使用 占位符方式 编码;
    ③ 日志message中包含 方法名 与 关键对象;
#2 项目配置层面：
    添加 additivity的配置 来 避免日志 被重复打印???