JDK中所定义的 完整的异常机制：

1 所有的异常 都是 Throwable的子类；
2 简单分类： Error（致命异常） + Exception(非致命异常)

Error表示系统 发生了 不可控的错误，比如 StackOverflow 或者 OutOfMemoryError
特征：这类异常 程序 无法处理，只能 人工介入。

Exception又分成 checked异常 与 unchecked异常；
checked异常：
    是：需要在代码中 进行显式处理 的异常 - 否则代码会 编译出错。
    用法：
        1 如果能够 自行处理，则：在 当前方法 中 捕获异常；
        2 如果 无法处理，则：向调用方抛出 这个异常对象。
    应用：
        SQLException、ClassNotFoundException等；
    分类：
        1 无能为力、引起注意型；
            比如 字段超长所引起的SQLException，程序 没办法 做任何操作。
            处理方式：完整地 保存异常现场，以供 开发人员 介入解决。
        2 力所能及、坦然处置型；
            比如 未授权异常(UnAuthorizedException),程序 可以跳转至 权限申请页面。

unchecked异常：
    是：运行时异常；
    特征：
        1 继承自 RuntimeException；
        2 不需要程序进行 显式的捕捉 与 处理；
    分类：
        1 可预测异常(Predicated Exception);
            如 IndexOutOfBoundsException, NullPointException等；
            这类异常 不应该 被产生或者抛出；
            手段：提前做好 边界检查、空指针判断；
        2 需要捕获的异常(Caution Exception)；
            如 Dubbo框架 进行RPC调用时 所产生的 远程服务超时异常 DubboTimeoutException。
            特征：这类异常 客户端 需要进行 显式的处理；
            手段：
                ① 友好提示(服务繁忙，请稍后重试)；
                ② 重试(仅限于 幂等的场景)；
                ③ 或者 降级处理(也就是返回空数据 或者 缓存数据)
            💡 记住：超时异常 是 症状，不是病因。代码处理是“止血”，但必须通过 监控和日志 找到 服务端性能瓶颈 才能根治。
        3 可透出异常(Ignored Exception);
            是：框架和系统产生的、并且 会自行处理的异常；
            特征：程序本身 不需要关心 这类异常。
            如 Spring框架抛出的 NoSuchRequestHandlingMethodException异常 - 这个异常 Spring框架会 自己处理掉。
            处理方式：把 异常 映射到 合适的状态码。

======
warp it up:
异常：Error + Exception；
Exception：checked + unchecked；
checked：必须在程序中显式的处理，否则程序会有编译报错；
unchecked:
    - 可预测异常(Predicated Exception); 好的编码习惯
    - 需要捕获的异常;
    - 可以忽略的异常；