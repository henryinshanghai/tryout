异常的处理原则：
    1 抛出的异常 与 捕获到的异常 应该是 完全匹配的；
    2 或者 捕获的异常 是 被抛出异常 的父类。

怎么传递 异常信息？
手段1：抛出 异常对象；
手段2：把 异常信息 转成 信号量，然后 封装在 特定的对象 中。
推荐做法：
    #1 如果是 对外提供的开放接口，则：使用 错误码 的方式；
    #2 如果是 公司内部 跨应用的 远程服务，则：使用 Result对象 来 封装 错误码、错误描述信息；
    #3 如果是 应用内部，则：直接抛出异常。

分析：
#1 为什么作为 远程服务 调用时，要使用 Result对象 封装异常信息？
答：
    1 如果是用 抛出异常的方式，万一调用方 没有 对异常进行捕获，则：会产生 运行时错误，导致 程序中断。
    2 如果在 抛出的异常对象 中 没有添加 栈的信息，则：对于调用端 解决问题 没什么帮助；
    3 而如果 添加了栈信息，频繁出错 时，则：信息的序列化与传输 也可能会有 性能损耗问题。

---------
NPE的规范

避免NPE；
手段1：提供方 可以返回 null值，而 调用方 在使用前 必须进行 非空判断；
手段2：服务方 保证 不会返回null值，而是 返回 Optional、空对象、空集合，调用方 不做任何处理。
这是 契约式编程 与 防御式编程的斗争：
    防御式编程胜利 - 防止NPE一定是 调用方的责任，需要 调用方 在使用前 进行判断。
