try代码块 与 锁的关系

===
有问题的代码片段：

Lock lock = new XxxLock();
preDo();
try {
    // 无论加锁成功与否，unlock都会执行
    lock.lock(); // 🐖 这行代码 应该移动到 try代码块的上方
    doSomething();
} finally {
    lock.unlock();
}

已知：
#1 调用 lock()方法 时，可能会抛出 unchecked异常；
#2 如果 lock()方法 放在了try代码块中，则：
    必然 会触发 finally代码块中的 unlock()方法 执行。
#3 如果 对 没有加锁的对象 进行解锁操作，则：
    会抛出unchecked异常 - 如 IllegalMonitorStateException

基于以上3个事实，上述代码 会导致如下结果👇：
    ① 如果 由于 加锁失败(aka 调用lock()方法) 导致了 程序中断[root cause];
    ② 但程序抛出的错误原因，却是 解锁失败(因为 finally总是会执行，而 其中调用 unlock()方法);
    最终 root cause被覆盖。

解决办法：
    在try代码块之前 调用lock()方法；
    这样如果 调用lock()的时候就失败了，finally{}不会被执行。

✅ 总结
问题	                            |       解答
lock() 放 try 外面有用吗？	    | 有！防止未加锁 就 unlock
finally 中 unlock() 会不会总执行？| 只有成功 lock() 后，才会执行到 finally
为什么不是“写了也没用”？	        | 因为 lock() 失败时，根本不会进入 try-finally 结构

所以，“lock() 在try外，unlock() 在finally内” 是 经过深思熟虑的 最佳实践，既保证了 异常安全，又避免了 非法解锁。

启示：
#1 lock() 在try外，unlock() 在finally内；
#2 对于Lock、ThreadLocal、InputStream这些个 需要 强制释放与清除 的对象，都需要
    程序员在 finally代码块中 进行 显式的清除 - 以此避免 内存泄漏，或者 资源消耗。