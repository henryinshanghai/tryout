实践：相比于 HashMap，优先推荐使用 ConcurrentHashMap;
原因：两者性能相差无几，但是后者解决了高并发下的线程安全问题。

HashMap潜在的问题：
1 死链问题；
2 扩容时可能引起数据丢失；

问题场景复现：
    用法：程序中 init()方法初始化了 static的HashMap集合对象，从数据库中获取数据到集合中。
    分析：如果应用启动过程中，只是单线程调用了一次初始化方法，应该能够正常存取数据；
    可如果 init()由于某种原因被执行了两次，就可能引起 HashMap死链的情况。
    原理：HashMap中出现了环形链表 - 这会使得 get()的操作进入无限循环中。
解决方案：
    1 使用 ConcurrentHashMap 来 替换 HashMap；
    2 使用 Collections.synchronizedMap()把 hashmap对象 包装成 同步集合；
    3 对init()方法添加同步的约束，避免多个线程同时执行init()

案例2：CPU使用率100%, 大量请求超时（监控平台）；
方案1：对服务器进行扩容 - 没管用
方案2：jstack命令查看？？？
    大量 RUNNABLE状态的线程都在执行 HashMap的put与get操作；
    基本判定与 HashMap的get、put操作相关。

HashMap中三个与存储相关的概念：
1 table - 用于存储所有的节点数据；
2 slot - 哈希槽，也就是数组中的一个方格 table[i]；
3 bucket - 哈希桶，由table[i]位置上所有元素形成的表/树的集合。

hashmap's size = 所有哈希桶中的元素的总和。

死链问题来源： JDK1.7中的 HashMap源码；

------
HashMap 新增元素的过程：
    put()
    addEntry()
    createEntry()
    新添加的元素直接放在 slot槽上，使新添加的元素 能够在下次提取时，可以被更快地访问到。
    分析：如果两个线程同时执行的话，在createEntry()方法中，会出现 线程之间的赋值覆盖 - 这就是对象丢失的原因。

usage demo：HashMapSimpleResize

与扩容相关的概念：
#1 length - table数组的长度；
#2 size - 通过put方法添加到 HashMap中的所有元素的个数
#3 hashCode - Object.hashCode()返回的int值。 要求：尽可能数学上离散分布
#4 hash - hashCode与 当前集合的table.length 进行位运算的结果，用来确定hash槽的位置

