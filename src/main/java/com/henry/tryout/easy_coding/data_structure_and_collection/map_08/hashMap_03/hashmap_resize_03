与扩容相关的概念：
#1 length - table数组的长度；
#2 size - 通过put方法添加到 HashMap中的所有元素的个数
#3 hashCode - Object.hashCode()返回的int值。 要求：尽可能数学上离散分布
#4 hash - hashCode与 当前集合的table.length 进行位运算的结果，用来确定hash槽的位置


扩容机制：
当容器中的元素数量 > 默认容量大小 * 负载因子时，就会进行扩容。

resize操作：
    在第4次元素复制完成后，哈希桶内的元素被逆序排列到新表中。

    为什么会逆序排列呢？
    resize() + transfer()数据迁移 [JDK7]

    分析：
    #1 transfer()数据迁移方法，如果数组非常大，那么：方法会非常消耗资源；
    #2 多线程条件下，当前线程迁移过程中，其他线程新增的元素可能就已经落到 已经遍历过的哈希槽中了；
    #3 遍历完成后，table的数组引用 会指向newTable - 这时新增元素就会丢失，然后被作为垃圾回收。

    如果resize完成, aka, 执行了 table = newTable, 则：
        后继的元素 就可以在新的表上执行插入操作。
    但如果多个线程同时执行resize操作, aka, 每个线程 都会 new Entry[newCapacity].
    这是线程的局部数组对象，不同线程之间是不可见的。

    在迁移完成后，resize的线程就会赋值给 table这个线程共享变量。
    结果：覆盖其他线程的操作 - 在新的表中插入的对象就会被丢弃掉。