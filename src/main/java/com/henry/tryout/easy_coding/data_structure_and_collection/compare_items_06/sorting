Arrays.sort() 使用的排序方式 - TimSort

TimSort = Merge Sort + Insertion Sort；

归并排序；
    归并操作：对于两个已经排好序的数组a与数组b，通过归并操作，能够得到一个完全排序的数组c。
    步骤：
        #1 n个元素的集合 等价于 n个长度为1的有序数组；
        #2 对有序的子数组进行两两归并，这样会得到 n/2个 长度为2的有序数组；
        #3 重复步骤2，直到得到一个 长度为n的有序数组。
    特征：主要的耗时都在归并操作上。

插入排序；
    #1 维护一个有序的区域，然后把下一个待处理的数据插入到该有序区域中。
    #2 扩展该有序区域，直到所有的元素都已经有序。

Tim Peters/Sort;
    相对于 传统的归并排序，它减少了归并次数；
    相对于 传统的插入排序，它引入了二分排序的概念。
特征：
    1 对于部分排序的数组，时间复杂度为 O(n);
    2 对于随机排序的数组，时间复杂度为O(nlogn);
具体优化手段：
    #1 归并排序的分段动作 不再是从单个元素开始，而是：
        1 先查找当前排序好的最大数组片段run;
        2 对run进行扩展，并使用二分排序；
        3 再把当前run 与 其他已经排序好的run 进行归并，产生排序好的更大的run。
    #2 引入二分排序；
        二分排序是对插入排序的优化：
            不再是从后向前逐个地对比元素，而是使用二分查找的思想。
            这样查找合适的插入位置的时间复杂度 从O(n) -> O(logn);

======
hashCode 与 equals

作用：标识对象；
    这两个方法协同工作来判断两个对新啊给是否相等；
原理：
    1 调用Object.hashCode()生成hash值时，很有可能会产生哈希冲突；
    2 所以在 hashCode相同的情况下，还需要再调用equals() 进行一次值的比较。
规则：
    #1 如果两个对象的 equals()是相等的，那么 两个对象调用hashCode()返回的结果也必须是相同的；
    #2 任何覆写 equals 的时候，都需要同时覆写 hashCode.
应用：
    1 HashMap get()方法；