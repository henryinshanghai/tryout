Junit测试框架

Java世界的测试框架：Junit, TestNG

Junit:
早期作者： Kent Beck & Erich Gamma.
第一版： 1997年；
2017.09 Junit5.0稳定版本
特征：
    Junit5 对 JDK8 及 更新的版本 提供了 更好的支持 -
        1 比如 对 lambda表达式 的支持
        2 更多的测试形式 - 重复测试、参数化测试等

Junit5的3个主要模块：
#1 JUnit Platform:
    作用：用于 在JVM上 启动 测试框架；
    特征：在 命令行、Gradle、Maven 上，执行测试的入口 是一样的。
#2 Junit Jupiter:
    作用：包含有 JUnit5.0所提供的 全新的 编程模型 与 扩展机制。
#3 JUnit Vintage:
    作用：兼容运行 JUnit3与JUnit4的 测试用例。

用法：为了 使开发者 能够 专注于 编写测试，而不用关心 测试的执行流程、结果展示 这些东西，JUnit 提供了 一些辅助测试的注解👇
① @Test - 声明 这是一个 测试方法
② @ParameterizedTest - 声明 这是一个 测试方法，并且 支持传入 不同的入参，使 当前方法 运行多次
③ @BeforeEach - 作用 类似于 JUnit4中的@Before, 在 每个测试方法 运行之前 都 运行一个 指定的方法
④ @BeforeAll - 在 每个测试类 运行之前，都 执行一个 指定的方法
⑤ @Disabled - 声明 测试方法 不再运行
⑥ @Tag - 为 方法 添加 分组标签，以便 选择性地 执行分组

代码Demo: TicketSellerTest

======
当 测试用例 比较多的时候，为了能够 更好地组织 测试的结构 - 可以使用 JUnit的 @Nested注解
作用：表达 有层次关系的 测试用例；
代码Demo： TransactionServiceTest
特征：
    1 Junit本身 没有限制 嵌套的层级数量 - 但是 一般不要超过 3级嵌套，否则 测试用例代码 会很难看懂

======
单元测试中的其他技巧：
1 分组测试；
2 数据驱动测试。

分组测试：
    对 不同特性的单元测试 进行分组 - 抽象来说，实现 测试 在 运行频率 维度上的 分层。
    demo：
        1 把 所有单元测试用例 分为：
            ① 执行很快 且 重要的 冒烟测试用例、
            ② 执行很慢 且 比较重要的 日常测试用例、
            ③ 数量很多 但是 不太重要的 回归测试用例。
            手段：@Tag注解。
        2 根据 某个维度 进行分组 后，就能够 - 在 不同的场景 下 选择性地执行 对应分组的 测试用例。
            手段：在Maven中 配置 maven-surefire-plugin
            如果 使用的管理工具 是 Gradle，Gradle 也提供了 专用的配置项 来 支持 选择执行 特定的分组
            参考：<artifactId>maven-surefire-plugin</artifactId>
    示例代码： TicketSellerTest_03
    怎么验证 分组 是 已经生效了的呢？母鸡~

======
数据驱动测试
使用场景：计算密集类型的算法单元；
特征：
    1 计算单元的 内部逻辑 复杂；
    2 对于 不同的输入，会得到 截然不同的输出。
        - 如果使用 传统的方式 编写单测，会需要 重复编写 大量模板式的 数据准备 与 方法调用代码，才能够 cover到 所有的测试场景
    怎么办？
    思路：把 数据的输入和输出 与 测试逻辑 分开 - 这样测试代码 只需要写一段，就能够 针对 各种不同的输入 进行验证。
    手段：@TestFactory
    代码 Demo: ExchangeRateConverterTest_04