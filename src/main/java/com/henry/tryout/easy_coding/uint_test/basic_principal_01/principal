宏观规则：AIR

新增的代码应该同步添加测试用例。
修改代码逻辑时，也应该同步保证 测试用例成功执行。
AIR：
    - 自动化；
    - 独立性；
    - 可重复性。

自动化：
    1 执行地自动化；   // 这样才能方便地在 CI中添加自动化测试的步骤
    2 执行结果验证的自动化； // 这样才能保证代码本身的正确性
单元测试中不允许使用 System.out,而应该使用 断言来验证结果

独立性：
    是：
        1 用例之间不允许相互调用；
        2 用例之间不允许出现执行次序的先后依赖。
    作用：使单元测试 稳定可靠且能够维护；
    如果 testMethod02 会调用 testMethod01,则：
        1 执行 testMethod02时，testMethod01会被再次执行；
        2 testMethod01如果验证失败，会导致 testMethod02也跟着失败。

fact：主流的测试框架中， Junit的用例执行顺序就是无序的。
而 TestNG则支持测试用例的顺序执行。

可重复性：
    是：单元测试可以重复执行，不应该受到外部环境的影响。
    应用：单元测试 通常会被添加到持续集成中 - 因此 每次有代码提交时，单元测试都会被触发执行。
    所以，如果单元测试存在有对外部的依赖(比如网络、可用的服务、中间件等)，则：很有可能导致 持续集成的机制不可用

======
微观上，单元测试需要遵守以下几个原则：
- B: 边界值测试；
    常见边界：循环边界、特殊取值、特殊时间点、特殊顺序；
- C：正确的输入，得到正确的预期输出
- D：与设计文档相结合，以此来编写单元测试。
- E：
    单元测试的目标是，证明程序存在错误。
    因此，为了发现代码中潜在的错误，在编写测试用例时需要
        用一些强制的错误输入，来得到预期的错误结果
        常见的错误输入： 非法数据、异常流程、非业务允许输入

单元测试不负责检查 跨类或者跨系统的交互 - 这是集成测试的工作。
单元测试针对于很小的模块，因此有可能代码的执行条件不具备 - 这时候就需要mock

可能不具备的条件：
1 功能因素； 被测试的方法中，存在不可用的功能；
2 时间因素； 双11还没到，很难测试与时间有关的功能；
3 环境因素；
4 数据因素；
5 其他因素；

Mock的几种方式：
1 硬编码；
2 配置文件；
3 Mock框架：EasyMock

作用：隔离依赖，帮助开发者编写出 稳定的单元测试。