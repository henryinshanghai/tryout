信号量同步？
    使用信号量这种手段 来 协调多个线程的执行次序。

分类：时间维度 + 信号维度；
具体类型： CountDownLatch、Semaphore；

业务场景：
    翻译平台，收到 某一语言翻译成多种语言的请求。
    把目标语种拆分成为多个子线程，使用线程对翻译引擎发起请求。
    翻译完成后，把结果同步给调用方。
报错：由于 countDown()方法抛出异常，引发故障
Demo: CountDownLatchTest

======
线程同步三宝

Ⅰ CountDownLatch：
作用：同步多个线程的执行顺序；
特征：
    1 基于执行时间；
    2 在实际编码中，可能会需要处理 基于空闲信号的同步情况。
用法：
    step1 准备一个 countDownLatch对象
    step2 作为参数传入自定义线程的构造器中
    step3 依次启动三个线程 - 在线程的run()方法中，操作 CountDownLatch对象
    step4 调用 countDownLatch对象的await()方法 - 以等待所有的线程执行完成

Ⅱ Semaphore：
    1 信号量(取票窗口)可以设置多个，只要有空闲的信号量，就可以处理线程；
    2 如果信号量大小等于1，则：所有线程只能排队等待一个窗口。aka, 互斥锁
类比：
    海关安检的场景：
        出国时，需要走海关的查验通道。
        机场海关通道有3个窗口，有一批需要出关的人排成一个长队（为什么要拍成一队呢？）。
        当有窗口出现空闲的时候，工作人员指示队首的人出列 到空闲窗口接收查验。
    JDK对此场景的实现：
        Semaphore类
            作用：用于线程同步；
            原理：
                1 只有在调用 Semaphore对象的acquire()方法成功后，才可以继续往下执行。
                2 完成后执行 release()方法 来 释放掉线程所持有的信号量 - 这样下一个线程就能够获取到信号量(走到窗口前)开始执行。
        Usage Demo:
            CustomCheckWindow


Ⅲ CyclicBarrier;
    原理：当同步达到某个条件时，触发???
    作用：用于支持多线程的同步/协作；
    特征：
        1 可以循环使用；
        2 通过添加屏障的方式 来 强制多个线程之间的同步。
    类比安检场景：
        3个人同时被安检，只有3个人都安检完成，才会放下一批人进来。- 这不是批处理吗？不应该更快吗？

高层用法：
    开发者要尽量使用 并发包中提供的信号同步类，避免使用 对象本身的wait()与notify()方法实现多线程之间的同步。
