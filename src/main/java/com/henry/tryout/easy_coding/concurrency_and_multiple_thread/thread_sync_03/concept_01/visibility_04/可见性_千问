为什么多线程条件下 需要保证共享变量的可见性？

在多线程环境下，必须保证共享变量的可见性（Visibility），否则会导致程序行为错误、数据不一致甚至系统崩溃。
这背后的根本原因在于：
    现代计算机体系结构和编译器优化会破坏“一个线程写、另一个线程读”的直观预期。

下面我们从 硬件、JVM、代码逻辑 三个层面深入解释：
===
一、问题根源：为什么“看不见”？
🧠 直观假设（错误！）
// 线程 T1
flag = true;  // 写

// 线程 T2
if (flag) { ... }  // 读

你可能认为：T1 写完 flag = true 后，T2 下次读 flag 就一定能看到 true。
❌ 但在多核 CPU + 缓存 + 编译器优化下，这并不成立！

===
二、三大导致“不可见”的原因

==
️⃣ CPU 缓存不一致（硬件层）
每个 CPU核心 有 自己的高速缓存（Cache）。
    ① T1 在 Core 0 上修改 flag → 只更新 Core 0 的缓存。
    ② T2 在 Core 1 上读 flag → 从 Core 1 的缓存读，仍是旧值！
💡 缓存一致性协议（如 MESI） 虽然存在，但 不保证 立即同步，且 Java 内存模型（JMM） 不能依赖 具体硬件行为。

==
️⃣ 编译器 / JIT 优化（软件层）
编译器或 JVM 的即时编译器（JIT）可能进行 激进优化：

示例：寄存器缓存

    // 线程 T2 的循环
    while (!flag) {
        // do nothing
    }
JIT 可能将 flag 读入寄存器，后续 不再访问 内存 → 即使 T1 修改了主内存，T2 也永远看不到！

示例：指令重排序
    // 初始化对象（伪代码）
    obj = new MyObject(); // 1. 分配内存；2. 初始化；3. 引用赋值
    CPU 或编译器可能重排为：1 → 3 → 2
其他线程看到 obj != null 时，对象可能尚未初始化 → 读到“半成品”对象！

==
️⃣ Java 内存模型（JMM）的抽象规定
Java 为屏蔽 硬件差异，定义了 自己的内存模型：
    ① 每个线程有工作内存（Working Memory）（可理解为缓存+寄存器）。
    ② 共享变量存储在主内存（Main Memory）。
    ③ 线程 对变量的操作 必须 先拷贝到 工作内存，再写回 主内存。
⚠️ 默认情况下，JMM 不保证 写操作 何时刷新到 主内存，也不保证 读操作 何时 从主内存加载！

===
三、真实案例：没有可见性保障的灾难

🌰 经典“停止标志”失效
    public class StopThread {
        private static boolean stop = false; // 非 volatile！

        public static void main(String[] args) throws InterruptedException {
            new Thread(() -> {
                int i = 0;
                while (!stop) { // 可能永远看不到 stop = true！
                    i++;
                }
                System.out.println("线程结束, i=" + i);
            }).start();

            Thread.sleep(1000);
            stop = true; // 主线程 设置 停止标志
            System.out.println("已发送停止信号");
        }
    }
✅ 期望结果：子线程很快退出。
❌ 实际结果：子线程可能永远运行下去（尤其在 服务器模式 JVM 或 多核 CPU 上）！

🔍 原因：子线程 将 stop 缓存在 寄存器 或 本地缓存 中，从未读取 主内存的新值。

===
四、如何保证可见性？—— 解决方案
机制	                    |      原理                        |	适用场景
volatile 关键字	        |   - 写操作立即刷新到主内存
                            - 读操作强制从主内存加载
                            - 禁止相关指令重排序	          | 状态标志、单次写多读
synchronized	        |   - 释放锁前：刷新工作内存到主内存
                            - 获取锁时：清空工作内存，重新加载 | 保护临界区（同时保证原子性+可见性）
final 字段	            | 安全发布：构造完成后 对所有线程可见  |	不可变对象
原子类（如 AtomicBoolean）|	内部使用 volatile + CAS	      | 需要原子更新的布尔/整数

✅ 修复上面的例子（加 volatile）：

    private static volatile boolean stop = false; // ✅ 保证可见性
→ 子线程能立即看到 stop = true，正常退出。

===
五、可见性 vs 原子性 —— 别混淆！
特性	    |       作用          |	是否被 volatile 保证？
可见性	| 修改对其他线程立即可见 |	✅ 是
原子性	| 操作不可分割（如 i++）|	❌ 否！volatile 不能保证 复合操作的 原子性
💡 例如：volatile int count; count++; 仍是线程不安全的！
因为 count++ 是“读→改→写”三步，中间可能 被其他线程打断。

===
✅ 总结：为什么必须保证可见性？

因为① 硬件缓存、② 编译器优化 和 ③JVM 内存模型，会导致 一个线程 对共享变量的修改，无法及时（甚至永远无法）被其他线程看到。

如果 不显式同步（通过 volatile、锁等），程序将：
    ① 陷入 无限循环（如 停止标志 失效）
    ② 读到 过期 或 部分初始化的数据
    ③ 表现出 不可预测、难以复现的 bug

🧠 记住：
“共享可变状态 + 多线程 ⇒ 必须保证可见性！”
这是编写正确并发程序的最基本要求之一。