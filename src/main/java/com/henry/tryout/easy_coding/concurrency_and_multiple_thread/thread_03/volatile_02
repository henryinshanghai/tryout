Java内存模型

happen before规则：
a happen before b -> hb(a, b)
如果 hb(a, b), 并且 hb(b, c),则：hb(a, c).这是一种传递性

fact:
1 线程的执行 与 线程的切换都是纳秒级别的。
2 由于CPU执行速度 与 CPU读取缓存速度 之间存在巨大差异，因此缓存必不可少。
    CPU访问一次内存，就相当于去一趟滴水湖了

指令优化：
有些指令放在一起执行效率会更高，且不会影响最终结果。

你要去还书，然后再借一本；
你室友请你帮忙换一本 Easy Coding,再借一本 《码出高效：Java开发手册》；
如果 先办你自己的事情，再去办你室友的事情，就属于单线程的死板行为。
不自觉的指令优化：把你自己要归还的书 与 Easy Coding一起归还，然后再一次性借出需要的书。
合并了数据的存 与 取操作。
fact： CPU在处理指令时，也会进行指令优化。分析哪些取数据的动作可以合并，哪些读数据的动作可以合并

可见性：
一个线程对变量做出的改动，其他线程能够即时察觉到。

fact：JVM中，每个线程都有其自己独占的内存区域（如虚拟机栈 = 局部变量表 + 操作数栈...）;
线程本地内存 VS. 堆内存(线程共享区域)
线程本地内存会保存一个 在堆内存中的引用变量 的副本 - 线程对此变量的所有操作都是对此副本完成的，执行结束后再把变量值同步回到堆内存中。
在此之前，线程对自己副本的操作，对其他线程都是不可见的。

晴空一声巨响，volatile闪亮登场！
作用：保证了变量的可见性；
原理：使用 volatile修饰变量时，意味着 此变量不会产生线程本地副本,
aka 所有对此变量的操作都是发生在堆内存中的。

指令重排的案例：双重检查锁 的失效
demo： LazyInitDemo






