线程的 不同状态 的转换条件：
                    阻塞状态
新建状态 NEW -> 就绪状态 <-> 运行状态 -> 终止状态

用法：
    #1 NEW, 新建状态, 是线程 被创建且未启动的状态；[出生]
    创建新线程的三种方式：
        ① 继承自 Thread类；
        ② 实现 Runnable接口；
        ③ 实现 Callable接口。

    Callable 与 Runnable：
    特征：
        ① Callable 可以通过 call()获取返回值。
        前两种方式的 共同缺陷👇
            在 任务执行完成 后，无法直接获取 执行结果(需要 借助 共享变量等 获取)。
            而 Callable 和 Future则 很好地解决了 这个问题。
        ② call() 能够抛出 异常。
        而Runnable 只有通过 setDefaultUncaughtExceptionHandler()的方式 才能 在主线程中 捕捉到 子线程异常。

    #2 RUNNABLE, 就绪状态。[大学毕业 有毕业证]
    aka 开发者 在代码中 调用start()之后、运行之前的状态。
    线程的start() 不能 被多次调用，否则 会抛出 IllegalStateException。

    #3 RUNNING，运行状态。[就职状态 签了合同 纳税]
    aka run() 正在执行时 线程的状态。
    线程可能会 由于某些因素 而退出RUNNING，如 时间、异常、锁、调度等

    #4 BLOCKED 阻塞状态。[离职状态]
    有以下几种情况：
        - ① 同步阻塞：[岗位被印度人抢走了]
            锁 被 其他线程 占用；
        - ② 主动阻塞：[辞职了]
            调用 Thread的某些方法，主动让出 CPU执行权，比如 sleep()、join()等
        - ③ 等待阻塞; [留岗待业]
            执行了 wait()

    #5 DEAD, aka, 终止状态。[死翘翘了]
        是run()执行结束,或者 异常退出后的状态。这个状态 不能逆转

类比：
    用 医生坐诊 的例子说明；
    医生 并发地处理 多个病人的询问、开化验单、查看化验结果、开药等工作；
    因为 各个线程 轮流占用 CPU的计算资源，所以 可能会出现 某个线程 没有执行完成 就不得不中断 的情况。- 这会导致 线程不安全

这些个状态，恰如人的一生呀！