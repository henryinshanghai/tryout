addWorker()解析

第一处：
    配合 循环语句中所出现的label，作用类似于goto。
    语法：label 在定义时 必须要 把 标签和冒号的 组合语句 紧紧挨着 循环体 - 否则 会有 编译出错。
    作用：在 实现 多重循环 时，能够 快速地退出到 任意一层循环。
    特征：如果 滥用，会导致 很多问题；
    此处的用法：
        retry下面,有 两个无限循环；
        在 workerCount加一成功 后，则：直接退出 两层循环。

第二处：
为了 方便阅读代码，更可读的编写方式 如下 - 引入一个 名字有意义的boolean变量：
Boolean isNotAllowedToCreateTask =
    runStateAtLeast(c, SHUTDOWN) && (runStateAtLeast(c, STOP)
        || firstTask != null || workQueue.isEmpty());

if(isNotAllowedToCreateTask) { // 不允许创建任务
    ...
}

第三处：
语法作用：与 第一处的标签 相呼应；
特征：AtomicInteger对象的 +1操作 是 原子性的。
break retry 意思是说, 直接跳出 与retry相邻的 这个循环体。

第四处：
continue retry表示 跳转到 标签处，继续执行循环。
作用：
    如果 条件为false，则说明：线程池 还处于 运行状态。aka, 会继续 在for(;;)循环中执行

第五处：
fact：
    1 compareAndIncrementWorkerCount方法 执行失败的概率 非常低。
    2 即使失败，再次执行时 成功的概率 也非常高。- 类似于 自旋锁的原理
手段：
    先加一，创建失败时，再减一。
特征：
    这种 并发创建线程的方式 比较轻量级。
    并发创建线程 的另一种方式：
        先 创建线程，成功后 加一。
        如果 创建线程 后，发现 超出了 限制，则：再来 销毁线程，再把 线程数量 -1.
    特征：这种方式，相比于👆的方式。代价要大得多

第六处：
fact：Worker对象是 工作线程 的 核心类实现。
部分源码：
    // 特征：① 实现了 Runnable接口；
    // ② 会 把 本对象 当作参数 传入给 run()方法中的 runWorker(this)
    // 因此 内部属性线程thread 在 调用start() 的时候，就会调用到 runWorker()方法
    private final class Worker extends AbstractQueueSynchronizer
        implements Runnable {
        Worker(Runnable firstTask) {
            // setState 是 AQS 的方法；
            // 特征：在 runWork()方法执行 之前,禁止 线程中断
            setState(-1);
            this.firstTask = firstTask;
            this.thread = getThreadFactory().newThread(this);
        }

        // 在 thread上 调用start() 之后，执行 runWorker()方法
        public void run() {
            runWorker(this);
        }
    }