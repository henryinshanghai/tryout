“ThreadLocal 的内部实现 使用了 ThreadLocalMap，
其中 key 是 ThreadLocal 的弱引用，但 value 是强引用” 这句话 能详细解释一下吗?

===
一、背景：ThreadLocal 数据存在哪里？
很多人误以为 ThreadLocal 把 数据 存储在 自己内部，其实 不是！

✅ 真实结构：
每个 Thread对象 内部 都有一个 ThreadLocal.ThreadLocalMap 成员变量。
当 你调用 threadLocal.set(value) 时，实际上是：
    Thread.currentThread().threadLocals.put(this, value);
即：以 当前 ThreadLocal实例 为 key，value 为 你设置的值，存入到 当前线程的ThreadLocalMap 中。

所以：
① 数据是 按线程隔离 的（每个线程 都持有 自己的 map）。
② ThreadLocal 本身 不存储 数据，它 只是 一个“钥匙”。

===
二、ThreadLocalMap 的结构
ThreadLocalMap 是 ThreadLocal的一个静态内部类，它的Entry 定义如下（简化版）：

    static class Entry extends WeakReference<ThreadLocal<?>> {
        Object value;

        Entry(ThreadLocal<?> k, Object v) {
            super(k); // 调用 WeakReference 的构造函数 → key 是弱引用
            value = v; // value 是 普通引用（强引用）
        }
    }

关键点来了：
字段	  |     引用类型                |	说明
key	  | WeakReference<ThreadLocal> | 弱引用 指向 ThreadLocal 实例
value |	Object	                   | 强引用 指向 你所存的值

===
三、什么是“弱引用”？为什么 key 用弱引用？
🔹 弱引用（WeakReference）的特点：
① 如果一个对象 只被 弱引用 指向，那么在 下一次GC 时，它会 被回收。
② 即使 还有 WeakReference 存在，只要没有 强引用，对象就“活不下去”。

🔹 为什么 key 设计成 弱引用？
目的：防止 ThreadLocal对象本身 无法被回收。

设想：
① 你 在某个类中 定义了一个 private static ThreadLocal<String> tl = new ThreadLocal<>();
② 后来 这个类 被卸载（比如 Web应用 热部署），或者你 不再持有 tl的强引用。
③ 如果 ThreadLocalMap 的 key 是强引用，那么 即使 外部没人用 tl，map里的key 仍会 强引用 它 → ThreadLocal对象 无法回收 → 内存泄漏。
✅ 所以，key 用弱引用，可以让 ThreadLocal实例 在 外部无引用 时 被GC掉。

===
四、那为什么还会 内存泄漏？问题出在 value！
虽然 key 是 弱引用，能被 GC，但 value 是 强引用！

🧨 内存泄漏场景（典型在线程池中）：
① 创建一个 ThreadLocal，并 在 某个线程（比如线程池中的线程 T）中 set("big object")。
② 使用完后，忘记调用 remove()。
③ 后来，外部 不再持有 这个 ThreadLocal 实例的引用（比如它是局部变量，方法结束了）。
④ 下次 GC 时：
    1.ThreadLocal 对象 被回收（因为 key 是弱引用，且无外部强引用）。
    2.但 ThreadLocalMap 中的 Entry 还在，只是 key 变成 null（称为 “陈旧条目” stale entry）。
    3.而 value 仍然 被Entry强引用着 → value 无法被回收！

    Thread T 的 ThreadLocalMap:
    [ Entry { key = null, value = "big object" } ]  ← key 已被 GC，但 value 还在！
→ 这就是 ThreadLocal内存泄漏 的真正原因：value 的强引用 + 忘记 remove。

===
五、JVM 如何缓解这个问题？
ThreadLocalMap 在 get()、set()、remove() 等操作时，会 自动探测并清理 key为null的 Entry（这个过程叫 “探测式清理”）。

例如，在 set() 方法中：
// 伪代码
for (Entry e : table) {
    if (e != null && e.get() == null) { // e.get() 就是 key
        e.value = null; // 清理 value
        table[i] = null; // 清理 entry
    }
}
✅ 但这不是实时的！如果之后 再也不访问 这个ThreadLocalMap，这些“僵尸 entry”就会 一直占着内存。

===
六、如何避免 内存泄漏？—— 最佳实践
每次用完 ThreadLocal，务必调用 remove()！

    try {
        threadLocal.set(value);
        // ... 业务逻辑
    } finally {
        threadLocal.remove(); // ✅ 关键！
    }

① 尽量将 ThreadLocal 声明为 private static final
→ 避免 频繁创建 ThreadLocal 实例，减少 key 被回收的机会。

② 在线程池场景中 尤其要小心
→ 因为线程会复用，ThreadLocalMap 长期存在，更容易积累 stale entries。

===
七、图解总结
          ┌───────────────┐
          │   Thread T    │
          │               │
          │ threadLocals  │ ────┐
          └───────────────┘     │
                                ▼
                   ┌───────────────────────┐
                   │   ThreadLocalMap      │
                   │                       │
                   │  [Entry]              │
                   │    key  ──(弱引用)──► ThreadLocal实例 ──× (已无 外部引用，可被GC)
                   │    value ──(强引用)──► "big object"   ← 无法 被GC！内存泄漏！
                   └───────────────────────┘
只有当 你调用 threadLocal.remove()，或者 ThreadLocalMap 在后续操作中 清理了这个 entry，"big object" 才能 被回收。

===
总结
问题	                | 解释
key 为什么是弱引用？	| 防止 ThreadLocal 实例 因 被map强引用 而无法回收
value 为什么是强引用？| 因为 需要保证 你存储的值 在 使用期间 不会 被GC掉
内存泄漏根源？	    | key 被GC 后，value 仍 被强引用，且 未手动 remove
如何避免？	        | 用完立即 remove()，尤其是 在使用线程池时