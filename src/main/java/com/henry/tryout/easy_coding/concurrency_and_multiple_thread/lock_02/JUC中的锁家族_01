目标：多线程场景下，需要声明 某个线程 对 某段代码 拥有执行权；
手段：对 部分场景的执行现场 进行加锁；
原理：多线程 会导致 资源竞争, 只有 合理安排 多个线程的执行，才能够 有序地操作资源、完成工作。

锁的发展：
    悲观锁 -> 乐观锁 -> 偏向锁 -> 分段锁等
锁的特征：
    1 互斥性；- 某个具体的时间点，代码 只会 被 某一个线程 执行
    2 不可见性???
特征：
    由于 锁的存在，有些操作 对外界来说 是 黑箱进行的, aka, 只有 锁的持有者(某个线程) 才知道 对变量进行了哪些操作。

学习锁的方式：
    通过 对 java.util.concurrent(JUC)包 中的 基础类 的解析，来 说明 锁的本质与特性。

    Java中锁的用法：
    - 1 使用 并发包中的锁类；
        Lock 是 JUC包中的 顶层接口；
            特征：它 没有使用 synchronized(提供 互斥性)，而是 使用volatile(提供 可见性)。
        JUC中的一些基础类型；
            Lock -> ReentrantLock -> { Sync, FairSync, NonFairSync}
        fact：
            #1 ReentrantLock 在 实现Lock 时，依赖了 Sync；
            #2 Sync 继承了 AbstractQueuedSynchronizer(AQS) - 这是 JUC包 实现同步的 基础工具；
            #3 在 AQS 中，有一个 state变量(volatile) 作为 共享资源；
        用法：
            1 如果 线程 获取资源 失败，则：线程 进入 同步FIFO队列 中 等待；
            2 如果 线程 获取资源 成功，则：执行 临界区的代码；
            3 执行完成 后，释放资源，然后 通知 同步队列中的等待线程(可以获取资源啦)

        JDK8中 添加了一个 新的锁： StampedLock；
        作用：改进了 读写锁 ReentrantReadWriteLock；
