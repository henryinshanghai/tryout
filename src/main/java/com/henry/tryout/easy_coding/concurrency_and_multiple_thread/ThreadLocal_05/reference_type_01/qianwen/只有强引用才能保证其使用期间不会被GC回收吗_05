为什么只有强引用 才能保证 在使用期间 不会被GC回收？
其他引用类型 会在引用被使用时，被GC回收掉吗?

===
一、GC 的基本判定原则
JVM 判断一个对象 是否“存活”，依据是：
    是否存在有 从 GC Roots 出发的、通过强引用链 能够到达 该对象？

① GC Roots 包括：活跃线程栈中的局部变量、静态变量、JNI 引用等。
② 只有 强引用（Strong Reference）参与“可达性”判断。
③ 软引用、弱引用、虚引用 不阻止 GC 回收对象。

✅ 所以：
只有强引用 能保证 对象 在 “被引用期间” 不被 GC。

===
二、其他引用类型会在“使用时”被 GC 吗？
答案：会！而且可能 在 你“正在用它” 的时候 就被回收！
这正是它们 与强引用的 根本区别。

我们逐个分析：

①. 软引用（SoftReference）
    1.语义：内存充足时 不回收，内存不足时 才回收。
    2.是否可能 在使用时被回收？ → 是的！
        Ⅰ 假设你 持有 SoftReference<MyObject> sr = new SoftReference<>(obj);
        Ⅱ 你调用 sr.get() 得到 obj，正 准备用它。
        Ⅲ 此时 JVM 发生Full GC 且 内存紧张 → obj 被回收。
        Ⅳ 下次再调用 sr.get() 就返回 null。
    3.风险：即使 你 刚拿到 引用，下一毫秒 就可能变成 null。
📌 所以：不能依赖 软引用 保证 对象在“逻辑使用期间” 存在。

②. 弱引用（WeakReference）
    1.语义：只要发生 GC，就回收（无论内存 是否充足）。
    2.是否可能 在使用时 被回收？ → 极大概率会！
        示例：
            WeakReference<MyObject> wr = new WeakReference<>(new MyObject());
            MyObject obj = wr.get(); // 拿到对象
            System.gc();             // 建议 GC

        // 此时 obj 可能已失效！但注意：obj 是 强引用，所以 不会被回收
        ⚠️ 关键点：如果你把 wr.get() 的结果 赋值给 一个局部变量（强引用），那这个对象 暂时安全。
        但如果只通过 WeakReference 访问：
            if (wr.get() != null) {
                // 在 if 判断时对象存在
                // 但在 执行下面代码 前，GC 可能已回收它！
                wr.get().doSomething(); // ❌ 可能 NPE！
            }
    ✅ 安全做法：先转为强引用，再使用：
    MyObject obj = wr.get();
    if (obj != null) {
        obj.doSomething(); // 安全：obj 是强引用
    }


3. 虚引用（PhantomReference）
    ① 语义：无法 通过它 访问对象！get() 永远返回 null。
    ② 用途：仅用于 感知对象 被回收的时机（配合 ReferenceQueue）。
    ③ 是否可能 在使用时 被回收？ → 它 根本不能 “使用”对象，所以这个问题不成立。

===
三、为什么 只有强引用 能保证 “使用期间安全”？
因为 强引用 直接参与 GC的可达性图 构建：

引用类型	| 是否阻止 GC	       | 能否保证“使用期间对象存在”
强引用	| ✅ 是	               | ✅ 能
软引用	| ❌ 否（内存不足时回收） | ❌ 不能
弱引用	| ❌ 否（下次 GC 就回收）| ❌ 不能
虚引用	| ❌ 否（且无法访问对象） | ❌ 不适用

💡 “使用期间”必须 由 强引用 来 锚定对象，否则 JVM 不认为 这个对象“还在被用”。

===
四、现实中的正确使用模式
场景：你想用 弱引用 来 避免内存泄漏，但又要 安全使用对象

    // 注册监听器（避免挟持）
    private final List<WeakReference<Listener>> listeners = new ArrayList<>();

    // 通知监听器
    void notifyListeners() {
        for (WeakReference<Listener> ref : listeners) {
            Listener l = ref.get(); // ← 转为强引用
            if (l != null) {
                l.onEvent(); // 安全：l 是强引用，不会在方法中被 GC
            }
            // 如果 l == null，说明已被回收，可清理 ref（可选）
        }
    }
✅ 关键：一旦要 “使用”对象，就必须 先 拿到 强引用。

===
五、总结
问题	                                | 答案
为什么只有强引用能保证使用期间不被 GC？	| 因为 GC 的“可达性”判定只认强引用
其他引用会在使用时被 GC 吗？	        | 会！ 软/弱引用的对象可能在你调用 get() 后立即被回收
如何安全使用非强引用？	                | 先通过 get() 获取强引用，再操作；不要连续多次调用 get()
虚引用能用来访问对象吗？	            | ❌ 不能，get() 永远返回 null

🌟 记住：
强引用 = “我在用它，请别回收”
软/弱引用 = “我不阻止你回收它”

这也是为什么日常编程中 我们 几乎只用 强引用———— 程序逻辑的正确性 依赖于 对象在使用期间的稳定性，而这 只有强引用 能保证。