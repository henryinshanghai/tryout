设计初衷：
    在 多线程并发 时，能够解决 变量 被多个线程共享 的问题。
结果：
    过度设计，反而 引发了 很多的问题。
    内存泄露、脏数据、共享对象更新...

学习路径：
内存模型 - 弱引用 - 哈希算法；

类比：
CS真人游戏；

预期：学习到 全新的编程思维方式，认识到 问题的来源。

===
引用的分类

==
背景知识：JVM内存布局 & JVM垃圾回收

fact：
1 对象 在堆上创建 之后 所持有的引用，其实是 一种变量类型。
2 多个引用 之间，通过 赋值操作，能够构成 一条引用链；
    用法：从 GC Root 开始遍历 引用链上的 每一个引用，就能够判断 引用 是否可达。
    应用：根据 一个引用 是否可达，JVM 会决定 是不是 把它当成垃圾 回收掉。
3 JVM会 自动管理 内存的 分配与回收，不需要 开发者的干预。

BUT，在 有些场景 下，即便 引用 可以到达，也会希望能够 根据 语义的强弱 来 决定 垃圾回收的阶段。

==
引用本身可以分成4类：
1 强引用；
    Object obj = new Object();
    这条语句 就会产生 对 对象的 强引用obj;
    作用：只要存在有 强引用 指向 一个对象，并且 该引用 GC可达。那么 这个对象 就不会 被回收；
    特征：这是最常见的引用类型。

2 软引用；
    作用：用于 非必需对象 的场景；
    特征：
        1 引用强度 弱于 强引用；
        2 在 即将OOM 之前，垃圾回收器 会 把 这些个 只被软引用指向的对象 添加到 回收范围中。
    应用：
        1 用来 缓存 服务器 中间计算结果；
        2 缓存 那些 不需要实时保存的 用户行为 等

3 弱引用；
    作用：同样用于 非必需的对象的场景；
    特征：
        1 引用强度 弱于 软引用；
        2 如果 某个对象 只被 弱引用 所指向，则：下一次YGC（新生代垃圾回收）时 会回收 此对象。
        3 弱引用 被回收的时机 取决于 YGC 什么时候发生，所以 具体时间点 不确定。
        4 调用 WeakReference的get()方法 可能会 返回null，留意 NPE
    应用：用来指向 某一个"容易消失的对象" - 强引用 断开 对 对象的指向 后，弱引用 不会 劫持对象。

4 虚引用；
    作用：一个 被虚引用指向的 对象，在 被回收 时，会 得到一个 系统通知。
    特征;
        1 引用强度极弱 - 通过 此引用 甚至无法获取到 它所指向的对象；
        2 必须 与 引用队列 一起使用；
        3 在 垃圾回收 时，如果 发现对象 存在虚引用，则：
            会在 回收对象 之前，把 虚引用 添加进 与之相关联的引用队列 中。

------
总结：
    1 引用类型的类比：
        强引用：买房；
        软引用：租房；
        弱引用：租假房；
        虚引用：空手套白狼；
    2 强引用 是最常见的，而 虚引用 在业务中 几乎用不到。
