------
线程安全

foundation/facts：
    #1 不同线程之间共享了资源；
    #2 不同线程会对共享的资源同时进行读写操作；
    #3 由于CPU时间片的存在，某个线程的读与写操作可能会被迫分开。

陌生词汇说明：
    为了保证线程安全，在多个线程并发地竞争共享资源时，一般会采用 “同步机制” 来协调各个线程的执行 - 以此来确保线程执行得到正确的结果。
    所以 同步,既可以做动词(表示协调),也可以做名词(表示为了协调线程所使用的方式)

------
线程安全问题只有在多线程环境下才会出现，单线程的执行方式是串行执行 - 串行执行是不会有线程安全问题。

如何保证高并发场景下的线程安全？
原理 与 手段：
- 1 数据单线程内可见。
    单线程总是安全的；
    延申：通过限制 资源/数据 仅仅在单线程内可见，就可以避免它被其他线程修改 - 因此它就是线程安全的
    应用： 线程局部变量；
        特征：存储在 虚拟机栈帧(线程私有区域)的局部变量表中 - 其他线程不会也无法对它进行操作。
        实例： ThreadLocal.

- 2 只读对象；
    只读对象总是安全的。
    特征：
        1 允许复制；
        2 拒绝写入。
    典型应用：
        String、Integer；
    实现手段：
        #1 使用final关键字来修饰类 - 避免类被继承（这可能引入可变性）；
        #2 使用 private final关键字来修饰属性 - 避免属性被修改；
        #3 类中不能有任何的更新方法；
        #4 返回值 不能是 可变对象。

- 3 线程安全类；
    原理：线程安全类内部会有非常明确的线程安全方式。
    实例： StringBuffer类中 就使用了 synchronized关键字 修饰了所有相关方法。

- 4 同步 & 锁；
    同步：协调多个线程按照特定的次序执行；
    用法：如果需要对某个对象进行并发地更新操作，但对象本身又不属于以上三类。则：需要开发者在代码中实现 线程之间的同步机制

    JDK中的并发包解析：
    - 1 线程同步类；
        作用：协调不同线程之间的交互/协作；
        demo：CountDownLatch（倒计数门闩）, Semaphore(信号量), CyclicBarrier(循环屏障)
    - 2 并发集合类；
        作用：支持多线程环境下的并发修改；
        demo:
            ConcurrentHashMap;
                特征：分段锁 -> CAS, 性能不断提升
            ConcurrentSkipListMap; 跳表
            CopyOnWriteArrayList; 奶牛列表
            BlockingQueue; 阻塞队列
    - 3 线程管理类；
        线程池；
        用法：
            1 Executors静态工厂 / ThreadPoolExecutor；
            2 使用 ScheduledExecutorService 来 执行定时任务；
    - 4 锁相关的类；
        作用：用于保证多线程操作的互斥性；
        demo: ReentrantLock;
        特征：锁的很多概念在弱化，因为很多类库都已经把锁做了很好的封装

并发包中的类有很多，彼此之间的差异也比较微妙。
需要开发者有很好的Java基础、逻辑思维能力，一定的数据结构基础。
才能分清楚各个类族的优缺点、差异点。

