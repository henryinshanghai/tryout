自从出现了资源竞争，人们才意识到 需要到对部分场景的执行现场进行加锁 -
以此告诉其他线程，自己短暂拥有。

锁的发展：
    悲观锁 - 乐观锁 - 偏向锁 - 分段锁等

锁的特征：
    1 互斥性；
    2 不可见性。
作用：
    由于锁的存在，有些操作对外界来说是黑箱进行的, aka, 只有锁的持有者 才知道
    对变量进行了哪些操作。
学习锁：
    通过 对 java.util.concurrent(JUC)包中的基础类的解析，来说明 锁的本质与特性。

    Java中锁的用法：
    - 1 使用并发包中的锁类；
        Lock是JUC包中的顶层接口；
            特征：它没有使用 synchronized(提供互斥性)，而是使用volatile(提供可见性)。
        JUC中的一些基础类型；
            Lock -> ReentrantLock -> Sync
                                    -> FairSync
                                    -> NonFairSync
        #1 ReentrantLock实现Lock时，依赖了 Sync；
        #2 Sync继承了 AbstractQueuedSynchronizer(AQS) - 这是 JUC包实现同步的基础工具；
        #3 在AQS中，有一个 volatile in state变量作为共享资源；
            用法：
                1 如果线程获取资源失败，则：线程进入同步FIFO队列中等待；
                2 如果线程获取资源成功，则：执行临界区的代码；
                3 执行完成后，释放资源，然后通知 同步队列中的等待线程(可以获取资源啦)

------
AQS：
    是：队列；
    作用：协调线程之间的合作, 因此是同步队列。
    手段：提供了独占、共享、中断等特性的方法
    特征：
        1 是抽象类；
        2 内置 自旋锁的实现；
        3 封装了 入队和出队的操作。
        4 AQS的子类中，能够定义不同的资源，以此实现不同性质的方法。
            如 可重入锁 Re-entrantLock - 定义
                如果state为0时，则：可以获取资源，并将其置为1.
                如果已经获取到资源了，则：再次获取资源时，state会+1；
                如果是要释放资源，则：state减一，直到为0.
            如 倒计数门槛 CountDown-Latch -
                初始时，定义资源的总量 state = count;
                调用countDown()方法，则：state减一；
                如果 state=0，则：获得锁。
                如果释放了锁，则：state会一直保持为0.
                特征：
                    线程调用 await()时不会等待 - 因此 countDownLatch是一次性的？？？
                如果想要循环使用的话，可以：使用 CyclicBarrier - 基于 ReentrantLock实现。
            如 Semaphore 信号量 -
                初始时，定义了资源总量 state = permits;
                如果 state>0，则：能够获取锁，并把state减一；
                如果 state=0，则：必须等待其他线程释放锁；
                如果 释放了锁，则：state加一 - 其他线程就又能够获得这个锁。
                用法： 如果把 Semaphore的permits设置为1，则：它就是互斥锁；
                    如果把它的permits设置为>1,则：它就是共享锁。

