foundation:
线程是CPU调度和分派的基本单位。
为了更充分利用CPU资源，一般都会使用多线程进行处理。
多线程的作用是提高任务的平均执行速度，但是导致程序可理解性变差,编程难度变大。

计算机的资源监视数据，红色箭头指向PID是进程ID，绿色箭头表示Java进程运行着30个线程。

特征：
    1 线程可以拥有自己的操作栈、程序计数器、局部变量表等资源。
    2 它和同一进程内的其他线程 共享该进程的所有资源。
    3 线程在生命周期内多种状态。
        NEW新建状态、RUNNABLE就绪状态、RUNNING运行状态、BLOCKED阻塞状态、DEAD终止状态。

线程的不同状态的转换条件：
                    阻塞状态
新建状态 NEW -> 就绪状态 <-> 运行状态 -> 终止状态

用法：
    NEW, 新建状态, 是线程被创建且未启动的状态；
    创建新线程的三种方式：
        继承自 Thread类；
        实现 Runnable接口；
        实现 Callable接口。

    Callable 与 Runnable：
    特征：
        第一, Callable 可以通过 call()获取返回值。
        前两种方式的共同缺陷 - 在任务执行完成后，无法直接获取执行结果，需要借助共享变量等获取。而 Callable和 Future则很好地解决了这个问题。
        第二, call()可以抛出异常。
        而 Runnable 只有通过 setDefaultUncaughtExceptionHandler()的方式才能在主线程中，捕捉到子线程异常。

    RUNNABLE, 就绪状态。
    aka 调用 start()之后的运行之前的状态。
    线程的start()不能被多次调用，否则会抛出 IllegalStateException。

    RUNNING，运行状态。
    aka run()正在执行时线程的状态。
    线程可能会由于某些因素而退出 RUNNING，如 时间、异常、锁、调度等

    BLOCKED 阻塞状态。
    有以下几种情况：
        - 同步阻塞： 锁被其他线程占用； 同步, 也就是 线程按照每种规则进行执行。
        - 主动阻塞： 调用 Thread的某些方法，主动让出 CPU执行权，比如 sleep()、join()等
        - 等待阻塞;  执行了 wait()

    DEAD, aka, 终止状态。
    是run()执行结束,或者异常退出后的状态。这个状态不能逆转

类比：
    用医生坐诊的例子说明，
    医生并发地处理多个病人的询问、开化验单、查看化验结果、开药等工作。
    因为各个线程轮流占用CPU的计算资源，所以可能会出现 某个线程没有执行完成就不得不中断的情况。- 这会导致线程不安全