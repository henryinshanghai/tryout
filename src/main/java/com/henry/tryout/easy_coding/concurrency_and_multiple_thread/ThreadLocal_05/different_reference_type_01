设计初衷：
    在多线程并发时，能够解决变量被多个线程共享的问题。
结果：
    过度设计，反而引发了很多的问题。
    内存泄露、脏数据、共享对象更新...

学习路径：
内存模型 - 弱引用 - 哈希算法；

类比：
CS真人游戏；

预期：学习到全新的编程思维方式，认识到问题的来源。

======
引用的分类

背景知识：JVM内存布局 & JVM垃圾回收

fact：对象在堆上创建之后 所持有的引用，其实是一种变量类型。
2 多个引用之间，通过赋值操作，能够构成一条引用链；
    用法：从 GC Root开始遍历引用链上的每一个引用，就能够判断 引用是否可达。
    应用：根据一个引用是否可达，JVM会决定是不是把它当成垃圾回收掉。
3 JVM会自动管理内存的分配与回收，不需要开发者的干预。

BUT，在有些场景下，即便引用可以到达，也会希望能够 根据语义的强弱 来决定垃圾回收的阶段。

引用本身可以分成4类：
1 强引用；
    Object obj = new Object();
    这条语句就会产生 对对象的强引用obj;
    作用：只要有强引用指向一个对象，并且 该引用GC可达。那么该对象就不会被回收
    特征：这是最常见的引用类型。

2 软引用；
    作用：用于非必需对象的场景；
    特征：
        1 引用强度弱于 强引用；
        2 在即将OOM之前，垃圾回收器 会把这些个软引用指向的对象 添加到回收范围中。
    应用：
        1 用来缓存 服务器中间计算结果；
        2 缓存哪些不需要实时保存的用户行为等
3 弱引用；
    作用：同样用于非必需的对象的场景；
    特征：
        1 引用强度 弱于 软引用；
        2 如果某个对象只被弱引用所指向，则：下一次YGC（新生代垃圾回收）时会回收此对象。
        3 弱引用被回收的时机取决于 YGC什么时候发生，所以具体时间点不确定。
        4 调用 WeakReference的get()方法可能会返回null,留意 NPE
    应用：用来指向 某一个容易消失的对象 - 强引用断开指向后，弱引用不会劫持对象。

4 虚引用；
    作用：一个被虚引用指向的对象，在被回收时，会得到一个系统通知。
    特征;
        1 引用强度极弱 - 通过此引用无法获取到 它所指向的对象；
        2 必须与 引用队列 一起使用；
        3 在垃圾回收时，如果发现对象存在虚引用，则：会在回收对象之前，把 虚引用添加进 与之关联的引用队列中。

------
总结：
    1 强引用：买房； 软引用：租房；弱引用：假租房； 虚引用：空手套白狼；
    2 强引用是最常见的，而虚引用业务中几乎用不到。
