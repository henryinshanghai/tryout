Java内存模型

happen before规则：
a happen before b -> hb(a, b)
如果 hb(a, b), 并且 hb(b, c),则：hb(a, c).这是一种传递性

fact:
1 线程的执行 与 线程的切换都是纳秒级别的。
2 由于CPU执行速度 与 CPU读取缓存速度 之间存在巨大差异，因此缓存必不可少。
    CPU访问一次内存，就相当于去一趟滴水湖了

指令优化：
有些指令放在一起执行效率会更高，且不会影响最终结果。

你要去还书，然后再借一本；
你室友请你帮忙换一本 Easy Coding,再借一本 《码出高效：Java开发手册》；
如果 先办你自己的事情，再去办你室友的事情，就属于单线程的死板行为。
不自觉的指令优化：把你自己要归还的书 与 Easy Coding一起归还，然后再一次性借出需要的书。
合并了数据的存 与 取操作。
fact： CPU在处理指令时，也会进行指令优化。分析哪些取数据的动作可以合并，哪些读数据的动作可以合并

可见性：
一个线程对变量做出的改动，其他线程能够即时察觉到。

fact：JVM中，每个线程都有其自己独占的内存区域（如虚拟机栈 = 局部变量表 + 操作数栈...）;
线程本地内存 VS. 堆内存(线程共享区域)
线程本地内存会保存一个 在堆内存中的引用变量 的副本 - 线程对此变量的所有操作都是对此副本完成的，执行结束后再把变量值同步回到堆内存中。
在此之前，线程对自己副本的操作，对其他线程都是不可见的。

晴空一声巨响，volatile闪亮登场！
作用：保证了变量的可见性；
原理：使用 volatile修饰变量时，意味着 此变量不会产生线程本地副本,
aka 所有对此变量的操作都是发生在堆内存中的。

指令重排的案例：双重检查锁 的失效
demo： LazyInitDemo

问题本身：对象引用在没有同步的情况下，进行读操作。
导致用户可能会获取未构造完成的对象。

解决方案：
手段1： 用volatile关键字 来 修饰目标属性；
    作用：限制 编译器对此变量的读写操作，以此确保 对象在实例化之后才返回引用。

锁 VS. volatile
锁的工作方式：
    线程得到锁的时候，读入变量的副本；释放锁时，把变量的副本写入堆内存空间。
特征：锁的操作 符合 happen-before规则。
应用：保证了 共享变量的可见性。

volatile的工作方式：
    多个线程之间共享变量时，volatile会使线程跳过自己的变量副本，直接操作变量本身。
    特征：
        1 volatile解决了 共享变量的可见性问题；
        2 volatile 无法保证互斥性；
        3 对 volatile的操作 并非都有原子性。 - Demo: VolatileNotAtomic
        4 volatile会使线程的执行变慢；
            因为 写操作需要时时地 同步给内存变量（而不是使用线程私有的变量副本）

实际的业务中，需要判断出一些多读的场景。
如果不确定共享变量是不是被多个线程并发地写，保险的做法是 - 使用同步代码块 来实现线程同步。

