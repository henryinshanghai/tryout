可见性：
    一个线程对变量做出的改动，其他线程能够即时察觉到。

fact：JVM中，每个线程都有其自己独占的内存区域（JVM虚拟机栈 = list of {局部变量表, 操作栈, 动态链接, 方法返回地址}）;

线程本地内存 VS. 堆内存(线程共享区域)
    原理："线程本地内存" 会保存一个 在堆内存中的引用变量 的副本;
    特征：
        1 当前线程 对变量的所有操作 都是对此副本完成的；
        2 执行结束后再把变量值同步回到堆内存中 - 在此之前，线程对自己副本的操作，对其他线程都是不可见的。
    作用：保证多个线程对变量的操作是安全的（因为每个线程都有自己的变量副本）
    疑问：线程本地内存写回到堆内存时，还是会出现值覆盖的情况呀？线程安全个鬼?!

------
Java对 "线程本地内存"引起的 多线程并发问题的解决手段 - volatile
晴空一声巨响，volatile闪亮登场！
作用1：保证了变量值 对多个线程的可见性；
原理：使用 volatile修饰变量时，意味着 此变量不会产生 "线程本地副本";
aka 所有对此变量的操作都是 发生在堆内存中的。

volatile作用2：防止JVM的指令重排 👇
指令重排导致 单例模式中双重检查锁的失效
原因：
    1 实例化对象的操作不是原子性的；
    2 JVM可能会对 字节码指令进行重新排序；
demo： LazyInitDemo

引发出问题的直接原因：
    对象引用 在没有同步(对象地址没有被初始化)的情况下，进行读/get操作 - 导致用户可能会获取 未构造完成的对象。
解决方案：
    手段：用volatile关键字 来 修饰目标属性；
    作用：限制 编译器对此变量的读写操作，以此确保 对象在实例化之后才返回引用。

