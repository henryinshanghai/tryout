锁 VS. volatile

===
锁的作用(之一)：确保 共享变量的可见性：
原理（工作方式）：
    ① 线程 得到锁 的时候，读入 变量的副本；
    ② 释放 锁时，把 变量的副本 写入 堆内存空间。
特征：锁的操作 必须要符合 happen-before规则。
应用：保证了 共享变量的可见性。

===
volatile的作用(之一)：确保 多线程下，共享变量的可见性；
原理(工作方式)：
    多个线程之间 共享变量 时，volatile 会使得线程：
        ① 跳过 自己的变量副本；
        ② 而去 直接 操作 变量本身。
    特征：
        1 volatile 解决了 共享变量的可见性问题；
        2 volatile 无法保证 互斥性；
        3 对 volatile的操作 并非都有 原子性。 - Demo: VolatileNotAtomic
        4 volatile 会 使 线程的执行 变慢；
            因为 写操作 需要 时时地 同步给 内存变量（而不是使用 线程私有的 变量副本）

实际的业务中，需要判断出 一些 多读的场景。
如果 不确定 共享变量 是不是 被 多个线程 并发地写，保险的做法是 - 使用 同步代码块 来 实现 线程同步。
