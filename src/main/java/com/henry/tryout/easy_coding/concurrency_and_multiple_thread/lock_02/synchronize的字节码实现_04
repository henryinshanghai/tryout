通过 字节码 来 学习 synchronized关键字 的实现原理：
字节码省略...

解释：
#1 方法元信息中 会使用 ACC_SYNCHRONIZED 来 表示 该方法 是一个 同步方法；
#2 同步代码块中 会使用 monitorenter 与 monitorexit两个字节码 来 获取与释放monitor；
#3 使用monitorenter进入时，
    如果 monitor为0，则：
        ① 表示 该线程 可以持有 monitor后继代码；
        ② 并把 monitor加一；
    如果 当前线程 已经持有了 monitor,则：
        monitor 继续加一；
#4 只要 monitor 不是0，那么 其他线程 就会 进入阻塞状态。

===
JVM 对synchronized的 优化手段：
    1 对monitor的 加锁 与 解锁 上。
    2 JDK6 之后，为 synchronized 添加了 不同的锁实现：
        偏向锁、轻量级锁、重量级锁。
    3 提供了 对锁的 升级与降级机制。

==
偏向锁：
    是：JVM 利用CAS 来 在对象头上 设置线程的ID - 表示该对象 会偏向于 当前线程。这就叫做 偏向锁
    作用：
        在 资源 没有被多线程竞争 的情况下，能够减少 锁 所带来的 性能开销。
    原理：
        在 锁对象的对象头 中 有一个 ThreadId字段；
        当 第一个线程 访问锁 时，如果 这个锁 还没有 被其他线程 访问过，则：
            1 JVM 会 让线程 持有 偏向锁；
            2 并 把 锁的ThreadId 设置为 当前线程的ID。
        当 有其他线程 再次获取锁 的时候，会判断 当前线程的ID 与 锁对象的ThreadId 是不是一致。
            如果 一致，则：此线程 不会再 重复获取锁 - 因此 提高了 程序的运行性能
        如果 出现了 锁竞争的情况，则：偏向锁 会被撤销，并且 升级成为 轻量级锁。
        如果 资源竞争 非常激烈，则：锁 会被升级成为 重量级锁。
    总结：
        偏向锁 可以降低 无竞争开销；
        aka, 在 不存在线程竞争的 情况下，它 省掉了 再次判断的步骤，因此 提升了性能。