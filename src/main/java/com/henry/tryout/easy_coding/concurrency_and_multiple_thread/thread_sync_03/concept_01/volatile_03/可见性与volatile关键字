可见性：
    一个线程 对 共享变量 所做出的改动，其他线程 能够 即时察觉到。
    它 表示的是 指令执行的实时透明度。

fact：JVM中，每个线程 都有 其自己独占的内存区域（JVM虚拟机栈 = list of {局部变量表, 操作栈, 动态链接, 方法返回地址}）;

线程本地内存 VS. 堆内存(线程共享区域)
    原理："线程本地内存" 会保存一个 在堆内存中的引用变量 的副本;
    特征：
        ① 当前线程 对变量的所有操作 都是对 此副本 进行的；
        ② 执行结束[1]后 再把 变量值 同步回到 堆内存 中[2]；
    问题：线程 对其所拥有的副本的操作，在一段时间[1]-[2]内，对 其他线程 是不可见的。

------
Java 对 此不可见问题👆 的解决手段 - volatile(易变的、不稳定的)
晴空一声巨响，volatile闪亮登场！

作用1：保证了 共享变量的值 对多个线程的可见性；
原理：使用 volatile 修饰变量 时，意味着 此变量 不会产生 "线程本地副本";
aka 所有 对此变量的操作 都是 发生在 堆内存 中的。

volatile作用2：部分防止 JVM的指令重排 👇
案例：指令重排(CPU对指令做出的优化动作) 导致 单例模式中 双重检查锁的失效
原因：
    1 实例化对象的操作 不是 原子性的；
    2 JVM 可能会 对 字节码指令 进行重新排序；

demo： LazyInitDemo

问题描述：
    对象引用 在没有同步(???)的情况下，进行 读操作 - 导致用户 可能会获取到 未构造完成的对象。
解决方案：
    手段：使用 volatile关键字 来 修饰 目标属性；
    作用：限制 编译器 对此变量的读写操作，以确保 对象 在实例化之后 才会返回引用。

