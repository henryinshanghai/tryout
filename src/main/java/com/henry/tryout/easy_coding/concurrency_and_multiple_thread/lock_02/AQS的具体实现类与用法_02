AQS（抽象队列同步器）：
    是：队列；
    作用：协调 线程之间的合作 - 因此 以作用命名 的话，是“用于同步的队列”。
    手段：提供了 独占、共享、中断 等特性的 方法
    特征：
        1 是 抽象类；
        2 内置 自旋锁的实现；
        3 封装了 入队和出队 的操作。
        4 AQS的子类中，能够 定义不同的资源，以此 实现 不同性质的方法。
            #1 如 可重入锁 Re-entrantLock，用法如下 👇
                如果 state为0 时，则：可以 获取资源，并 将其置为1.
                如果 已经获取到 资源 了，则：再次获取资源 时，state会+1；
                如果是要 释放资源，则：state会-1，直到 为0.

            #2 如 倒计数门槛 CountDown-Latch，用法如下 👇
                初始时，定义 资源的总量 state = count;
                如果 调用了countDown()方法，则：state减一；
                如果 state=0，则：获得锁。
                如果 释放了锁，则：state 会一直保持为 0.
                特征：
                    线程调用 await()时 不会等待 - 因此 countDownLatch是一次性的？？？
                如果想要 循环使用 的话，则：可以使用 CyclicBarrier - 基于 ReentrantLock实现。

            #3 如 Semaphore 信号量，用法如下 👇
                初始时，定义了 资源总量 state = permits;
                如果 state>0，则：能够 获取锁，并 把state减一；
                如果 state=0，则：必须 等待 其他线程 释放锁；
                如果 释放了锁，则：state+1 - 如此一来，其他线程 就又能够 获得这个锁。
                用法：
                    如果 把 Semaphore的permits 设置为1，则：它就是 互斥锁；
                    如果 把 它的permits 设置为 >1,则：它就是 共享锁。