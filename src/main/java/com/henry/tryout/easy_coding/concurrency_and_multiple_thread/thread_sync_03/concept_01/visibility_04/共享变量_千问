什么叫做 共享状态/共享变量?

===
在 并发编程（多线程/多进程）中，共享状态（Shared State） 或 共享变量（Shared Variable） 指的是：
    被两个或更多线程（或进程）同时访问（读或写）的 内存数据。

这是并发问题的根源所在————只要存在 共享状态，就可能引发 数据竞争、不一致、程序错误 等问题。

===
🔑 核心定义
术语	            |       含义
共享（Shared）	| 多个线程都能 “看到”并操作 同一块内存区域
状态（State）	| 程序 运行时的数据，如 变量、对象、数组、集合等
共享变量	        | 最常见的 共享状态形式，如 static int count;、全局对象 等

✅ 关键判断标准：
如果 多个线程 能读或写 同一个内存地址，那么 这个数据 就是 共享状态。

🌰 举例说明
✅ 是共享状态的例子：
    // 1. 静态变量（类级别共享）
    public class Counter {
        public static int count = 0; // 所有线程共享
    }

    // 2. 实例变量（多个线程 操作 同一个对象）
    Counter c = new Counter();
    new Thread(() -> c.count++).start();
    new Thread(() -> c.count++).start(); // 共享 c.count

    // 3. 全局集合
    List<String> list = new ArrayList<>();
    // 多个线程同时 add() → 共享状态！

    // 4. 单例对象的字段
    public class Config {
        private String url;
        // 所有线程 通过 getInstance() 访问同一个 url
    }

==
❌ 不是共享状态的例子：

    // 1. 局部变量（每个线程有自己的栈）
    void method() {
        int x = 0; // 每个线程调用 method() 时，x 独立存在
    }

    // 2. ThreadLocal 变量
    ThreadLocal<Integer> local = new ThreadLocal<>(); // 每个线程私有副本

    // 3. 不可变对象（只读，无修改）
    final String name = "Alice"; // 多个线程读，但没人写 → 安全

💡 注意：
① 只读的共享数据 ≠ 线程安全问题（因为没有 写操作）
② 问题出在“可变 + 共享 + 无同步”

===
⚠️ 为什么共享状态危险？
当 多个线程 同时写 或 一边写一边读 共享变量 时，会出现：

问题	                       |    说明
竞态条件（Race Condition）   | 结果 依赖于 线程执行顺序（如 i++ 丢失更新）
数据不一致	               | 对象 处于 中间状态时，就 被 其他线程 所读取（如 HashMap 还在扩容时，读到环形链表）
内存可见性问题	           | 一个线程的修改 对 其他线程 不可见（需 volatile 或锁）
原子性破坏	               | 复合操作 被中断（如先检查后执行：check-then-act）

===
✅ 如何 安全地处理 共享状态？
策略             |	原理                           | 	示例
避免共享（首选！）	| 线程封闭、局部变量、不可变对象	  | ThreadLocal, final 字段
加锁（互斥）	    | 一次只允许一个线程访问	          | synchronized, ReentrantLock
无锁同步	        | 利用 CAS 原子操作	              | AtomicInteger, ConcurrentHashMap
消息传递	        | 线程间 不共享内存，通过队列 来 通信  |	BlockingQueue, Actor 模型

🧠 并发设计黄金法则：
“无共享，不并发；有共享，必同步。”

===
📊 共享状态 vs 线程安全关系图

    多个线程
        │
        ▼
    访问同一数据？ ──否──→ 线程安全（无需同步）
        │
       是
        │
    数据是否可变？ ──否──→ 线程安全（只读）
        │
       是
        │
    是否有同步机制？ ──是──→ 线程安全
        │
       否
        ▼
    线程不安全！（可能出现各种并发 bug）

===
✅ 总结
问题	            | 答案
什么是共享状态？	| 被多个线程同时访问的可变数据
典型形式？	    | 静态变量、实例字段（多线程共用对象）、全局集合
为什么危险？	    | 导致竞态条件、数据不一致、可见性问题
如何解决？	    | 避免共享 > 加锁 > 无锁原子操作

💡 记住：
共享状态 本身不是错，错的是 “无保护地 共享 可变状态”。
优秀的并发程序，要么 ① 消除共享，要么 ② 严格同步。