锁 VS. volatile
锁的工作方式：
    线程得到锁的时候，读入变量的副本；释放锁时，把变量的副本写入堆内存空间。
特征：锁的操作 符合 happen-before规则。
应用：保证了 共享变量的可见性。

volatile的工作方式：
    多个线程之间共享变量时，volatile会使线程跳过自己的变量副本，直接操作变量本身。
    特征：
        1 volatile解决了 共享变量的可见性问题；
        2 volatile 无法保证互斥性；
        3 对 volatile的操作 并非都有原子性。 - Demo: VolatileNotAtomic
        4 volatile会使线程的执行变慢；
            因为 写操作需要时时地 同步给内存变量（而不是使用线程私有的变量副本）

实际的业务中，需要判断出一些多读的场景。
如果不确定共享变量是不是被多个线程并发地写，保险的做法是 - 使用同步代码块 来实现线程同步。
