为了验证 软引用的存在（在即将OOM之前，垃圾回收器 会把这些个软引用指向的对象 添加到回收范围中）:
先设置JVM参数： -Xms20m -Xmx20m.  aka 只有20MB的堆内存空间。

构造场景 - 引起OOM，进而验证软引用指向的对象被回收：
1 设置很小的堆内存空间；
2 使用代码，不断向集合中添加大的对象(House对象)；
3 定义House类，其中有2000个Door成员变量。
总之，小空间 + 大对象 -> 尽快触发内存被耗尽的临界状态。

Demo: SoftReferenceHouse

找不到像 Easy Coding中一样的工具来查看内存中的 对象的数量...

------
知识卡：
    软引用、弱引用、虚引用都有 带有队列的构造方法：
        public SoftReference(T referent, ReferenceQueue<? super T> q){...}
    作用：能够在队列中检查具体哪一个软引用的对象被回收了 - 进而把失去对象的软引用给回收掉。

demo的作用：证明了软引用在内存紧张时的回收能力。
应用：软引用一般用于 在同一服务器内缓存中间结果；
    如果命中缓存，则：直接提取缓存结果；否则，重新计算或者获取。
note：软引用不能用来缓存高频数据 - 因为一旦服务器重启或者内存紧张触发了对软引用的回收，则：缓存就会失效。

追问：如果内存没有到达OOM，软引用会被回收吗？
验证Demo: SoftReferenceWhenIdle
