表面上看，红黑树 是 一棵有序二叉搜索树（BST），查找一个节点 应该 像教科书那样简单：

while (node != null) {
    if (key < node.key) node = node.left;
    else if (key > node.key) node = node.right;
    else return node;
}

但 HashMap.TreeNode.find() 的实现却异常复杂，包含多个分支、tieBreakOrder、甚至对 Comparable 的动态检测。
为什么会这样？

==
✅ 核心原因一句话：
HashMap 的红黑树 不是 按key的“自然顺序”排序的，而是按 hash 排序的；
而 hash 可能冲突，key 又不一定可比较 —— 所以必须处理 “无法确定左右子树”的 模糊情况。

这打破了标准 BST 的前提！

🔍 一、标准 BST vs HashMap 的“伪 BST”
特性	            |   标准红黑树（如 TreeMap）                |	HashMap 的红黑树
排序依据	        | key 的自然顺序（Comparable）或 Comparator |	hash 值（int）
key 是否可比？    |	是（强制要求）	                         | 不一定！（任意 Object）
hash 冲突怎么办？ |	不存在（直接比 key）                    |	大量存在！（不同 key 可能同 hash）
树结构稳定性	    |   确定                                  |	需要额外规则打破平局
✅ 所以：HashMap的红黑树 本质上 是一个 “以 hash为主键的BST”，但 hash不是唯一标识！

==
🔍 二、find() 方法为什么复杂？—— 三大挑战

🧩 挑战 1：hash相等 但key不等（哈希冲突）
多个不同key 可能会有 相同的hash；
此时无法 仅靠hash 来 判断“往左还是往右”；
必须引入 额外的比较规则 来 维持树结构。
→ 这就是为什么需要 tieBreakOrder()。

🧩 挑战 2：key 不一定实现 Comparable
HashMap 允许任意 Object 作为 key；
如果 key 没有实现 Comparable，就不能用 compareTo()；
但树又 必须决定 插入方向（左 or 右）。
→ 所以 JDK 使用 System.identityHashCode() 作为最后手段，确保 总能比较。

🧩 挑战 3：不能破坏 已有树结构
即使 两个节点 hash 相同、key 不可比，也必须 稳定地 分配左右；
否则 多次插入 相同 key 会导致 树结构不一致，甚至 死循环。
→ tieBreakOrder 保证了 跨JVM实例的一致性（相对） 和 单次运行的稳定性。

==
三 find()实现中的关键分支分析

final TreeNode<K,V> find(int h, Object k, Class<?> kc) {
    TreeNode<K,V> p = this;
    do {
        int ph, dir; K pk;
        TreeNode<K,V> pl = p.left, pr = p.right;

        // 1. 当前节点 hash > 目标 hash → 往左
        if ((ph = p.hash) > h)
            p = pl;
        // 2. 当前节点 hash < 目标 hash → 往右
        else if (ph < h)
            p = pr;
        // 3. hash 相等！
        else if ((pk = p.key) == k || (k != null && k.equals(pk)))
            return p; // ✅ 找到了
        // 4. 左子树为空 → 只能往右
        else if (pl == null)
            p = pr;
        // 5. 右子树为空 → 只能往左
        else if (pr == null)
            p = pl;
        // 6. 两边都有！需要更精细比较
        else if ((kc != null ||
                  (kc = comparableClassFor(k)) != null) &&
                 (dir = compareComparables(kc, k, pk)) != 0)
            p = (dir < 0) ? pl : pr;
        // 7. 最后手段：用 identityHashCode 打破平局
        else {
            int d = tieBreakOrder(k, pk);
            p = (d < 0) ? pl : pr;
        }
    } while (p != null);
    return null;
}

各分支作用：
分支	| 场景	                 |   目的
1–2	| hash 不等	             | 标准 BST 查找
3	| hash 相等 + key 相等    |	找到目标
4–5	| hash 相等 + 一边为空     | 只能走另一边
6	| hash 相等 + key 可比较   |	用 compareTo 决定方向
7	| hash 相等 + key 不可比较 |	用 identityHashCode 强制排序

==
🔍 四、tieBreakOrder() 是什么？

static int tieBreakOrder(Object a, Object b) {
    int d;
    if (a == null || b == null ||
        (d = a.getClass().getName().compareTo(b.getClass().getName())) == 0)
        d = (System.identityHashCode(a) <= System.identityHashCode(b) ? -1 : 1);
    return d;
}

① 先比 类名（避免不同类型乱序）；
② 再比 identityHashCode（对象内存地址的哈希，基本唯一）；
③ 确保 任意两个对象 都能 排出“顺序”，从而 决定 其在树中位置。
⚠️ 注意：identityHashCode 不保证 全局唯一，但 在单次运行中 足够稳定。

==
✅ 五、为什么不能简化？
假设我们强行简化成“只比 hash”：

if (p.hash > h) go left;
else go right;

那么：
① 所有 hash相同的key 都会 挤在同一个路径上；
② 树 退化成 链表（最坏 O(n)）；
③ 失去红黑树 O(log n) 的优势！

所以，必须在 hash相等 时 引入第二、第三比较维度，才能 维持树的平衡和效率。

===
✅ 六、总结：为什么这么复杂？

问题	                    |       答案
红黑树查找不该很简单吗？	    |   是的，前提是 key可比 且 无冲突
HashMap 满足这个前提吗？	|  ❌ 不满足！key 任意，hash 必然冲突
那怎么办？	            | 引入 多级比较策略：hash → equals → Comparable → identityHashCode
这是过度设计吗？	        | ❌ 不是！这是在 通用性（任意 key）与 性能（O(log n)）之间 取得的必要妥协

💡 最后思考
① TreeMap 要求 key 可比较，所以 它的红黑树 简单高效；
② HashMap 允许任意 key，所以 它的红黑树 必须“自己造一套比较规则”。

灵活性的代价，就是复杂性。
