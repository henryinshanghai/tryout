考虑到 线程并发安全性，ConcurrentHashMap 是 比HashMap更加推荐的 一种哈希式的集合。
JDK8 对ConcurrentHashMap进行了 脱胎换骨式的改造，
使用了 大量的lock-free技术 来 减轻 因锁的竞争 而对性能造成的影响。

它是 学习并发编程的 一个绝佳示例，这个类超过了6300行代码，涉及 volatile、CAS、锁、链表、红黑树 等众多知识点。

扩展说明一下 CAS(Compare And Swap)，它 是 解决 轻微冲突的多线程并发场景下 使用锁造成性能损耗 的一种机制。
每一次执行 都必须 进行加锁与解锁的成本 是 比较高的，
在 并发度比较低的情况 下，这种时间成本消耗 是 比较奢侈的。

CAS就是 先比较，如果 不符合预期，则 进行重试。

CAS操作 包含三个操作要素：① 内存位置；② 预期原值(假设为A); ③ 新值(假设为B)。
用法：
    ① 如果 内存位置的值 与 预期原值 相等，则：
        处理器 会 把该位置的值 更新为 新值；
    ② 如果 不相等，则：
        1. 获取当前值；
        2. 然后 进行 不断的轮询操作，直到 成功 或者 达到某个阈值退出。

典型代码如下：
    public final int getAndIncrement() {
        for(;;) {
            int current = get();
            int next = current + 1;

            if(compareAndSet(current, next)) {
                return current;
            }
        }
    }

上述示例代码中的 compareAndSet的功能 是 与current比较，如果相等 则 值变成next。
这个原子操作 是在硬件层面 来 保证的，唯一要避免的是 ABA问题。

CAS这种 “不加锁而实现 操作原子化”的 并发编程方式，在 本节 和 后继的线程池中，都有涉及。
