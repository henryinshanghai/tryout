实践：相比于 HashMap，优先推荐使用 ConcurrentHashMap;
原因：两者性能 相差无几，但是后者 解决了 高并发下的 线程安全问题。

HashMap潜在的问题：
1 死链问题；
2 扩容时 可能引起 数据丢失；

===
案例1：
某个应用 在init()方法中 初始化了 static的HashMap集合对象，用于 从数据库中 获取数据 放到集合中。
预期：如果 应用启动过程 中，只是 单线程 调用了一次 初始化方法，应该能够 正常存取数据；
实际：机缘巧合下，init() 被执行了两次，导致 启动失败、CPU使用率飙升。
分析手段：dump分析，发现 存在HashMap死链；
解决方案：
    1 使用 ConcurrentHashMap 来 替换 HashMap；
    2 使用 Collections.synchronizedMap() 把 hashmap对象 包装成 同步集合；
    3 对 init()方法 添加 同步的约束，避免 多个线程 同时执行init()

===
案例2：CPU使用率100%, 大量请求超时（监控平台）；
方案1：对服务器 进行扩容 - 没管用
方案2：jstack命令查看？？？
    大量 RUNNABLE状态的线程 都在执行 HashMap的put与get操作；
    基本判定与 HashMap的get、put操作 相关。
