为什么在HashMap的put()方法实现中，会在if()条件中 使用 赋值表达式 来 赋值到一个局部变量k？

if (p.hash == hash &&
    ((k = p.key) == key || (key != null && key.equals(k))))

==
✅ 为什么要这样做？三大核心原因：
1. 避免 重复读取 字段（性能优化）
    p.key 是 堆中对象 的一个实例字段，每次访问 都可能触发一次 内存加载。
    后续比较中 既要用于 ==，又要用于 key.equals(k)。
    如果写成：
        (p.key == key || key.equals(p.key))
    → JVM 需要两次读取 p.key（一次 ==，一次 equals）。
    ✅ 而通过 (k = p.key)：
        ① 只读一次 p.key；
        ② 将 值 缓存在 栈上的局部变量 k 中；
        ③ 后续使用 k 访问速度极快（局部变量 通常在 CPU 寄存器 或 L1 缓存中）。
    🔍 在 HashMap 这种 高频调用的 热点路径 中，省一次 内存访问 = 提升 整体吞吐量。

<略>

===
✅ 总结一句话：
k = p.key 不是为了“炫技”，而是为了：

① 减少一次 堆内存访问（性能）；
② 确保 比较操作 使用的是 同一个引用（正确性）；
③ 帮助 JIT 生成 更高效代码（可优化性）。

这正是 OpenJDK 这类 高性能基础库 的 典型微观优化风格——每一纳秒 都值得争取。