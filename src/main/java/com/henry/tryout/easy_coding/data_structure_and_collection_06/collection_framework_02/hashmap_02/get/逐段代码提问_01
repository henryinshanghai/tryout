HashMap get()方法的实现中，如下的局部变量分别是什么作用？
Node<K,V>[] tab; Node<K,V> first, e; int n; K k;

==
✅ 三、总结：变量设计哲学
变量	    | 类型     |	   作用      |	设计意图
tab	    | Node[]  |  哈希表数组	| 减少字段访问，便于 JIT 优化
first	| Node    |	 桶头节点	    | 快速路径检查（hot path optimization）
e	    | Node    |	当前遍历节点	| 统一表示 “候选 entry”
n	    | int     |  表长度      |  避免重复计算，用于索引和边界检查
k	    | K       |	当前节点的 key| 减少字段访问，简化 equals 调用

==
✅ 四、为什么这样写？—— JDK 的高性能编码风格
局部变量 缓存字段 → 减少 内存访问；
单字母/简短命名 → 降低 视觉噪音（e, k, n 是惯例）；
先比 hash 再比 key → 快速过滤；
桶头节点 特殊处理 → 优化常见 case（无冲突 或 短链表）；
类型检查后转型 → 安全使用 树结构。

===
if ((tab = table) != null && (n = tab.length) > 0 &&
    (first = tab[(n - 1) & hash]) != null) {}
最外层的if在判断什么？怎么这么复杂？

✅ 整体目的：
确保 哈希表 已初始化、非空，并且 目标桶中 至少有一个节点，才值得 继续查找。

如果任一条件不满足，直接返回 null（表示 key 不存在）。

==
1️⃣ (tab = table) != null
作用：检查 底层哈希表数组 是否已创建。
为什么需要？
    ① HashMap 初始时 table == null（懒初始化）；
    ② 如果 从未 put过元素，table 仍是 null；
    ③ 此时任何 get 都应返回 null。
技巧：边赋值 边判断，将 table缓存到 局部变量tab，后续复用。
✅ 语义：“表存在吗？”

==
️⃣ (n = tab.length) > 0
作用：检查 哈希表长度 是否大于 0。
为什么需要？
    ① 虽然 table 非null，但可能是一个空数组（如刚扩容后？实际上 JDK 不会这样，但防御性编程）；
    ② 更重要的是：获取数组长度 n 并 缓存为 局部变量，用于 下一步计算索引；
    ③ 同时 确保 n > 0，这样才能 安全执行 (n - 1) & hash（若 n == 0，n - 1 = -1，位运算 结果错误）。
技巧：同样 边赋值边判断，缓存 n 提升性能。
✅ 语义：“表有容量吗？”

📌 补充：HashMap 的容量始终是 2的幂，所以 (n - 1) 是一个低位全是1 的掩码，
例如 n = 16 → n-1 = 15 (0b1111)，因此 (n - 1) & hash 等价于 hash % n，但更快。

==
️⃣ (first = tab[(n - 1) & hash]) != null
作用：计算 key 应在的桶位置，并 检查 该桶 是否非空。
关键点：
    ① (n - 1) & hash：计算桶索引（利用 容量为2的幂 的特性）；
    ② tab[index]：获取 该桶的头节点；
    ③ 如果为 null，说明 该key绝对不存在（因为 没发生过 哈希冲突，也没 插入过）；
    ④ 同时将 头节点 赋值给 first，供 后续快速比较（比如 头节点 就是 要找的key）。
技巧：再次边赋值边判断，避免重复访问 tab[index]。
✅ 语义：“这个 key 可能存在的地方有东西吗？”

==
✅ 总结：最外层 if 的三大职责
子表达式	                          |   检查内容     |	副作用（赋值）   |	目的
(tab = table) != null	          |  表是否已初始化 | tab = table	  | 避免 NPE，缓存字段
(n = tab.length) > 0	          |  表是否有容量	 | n = tab.length | 安全计算索引，缓存长度
(first = tab[(n-1)&hash]) != null |	目标桶是否非空  | first = 头节点  |	快速排除不存在的 key

💡 这一行代码，是 “防御性编程 + 性能优化 + 代码紧凑” 的典范。

===
if (first.hash == hash && // always check first node
    ((k = first.key) == key || (key != null && key.equals(k))))
        return first;
这部分代码是什么含义?

==
✅ 四、完整语义总结
“如果 桶的第一个节点的哈希值 与 目标hash 相同，
并且它的key 要么 是同一个对象（==），要么 逻辑上相等（equals()），

那么它 就是 我们要找的节点，直接返回。”

==
✅ 五、设计亮点
技巧	        |   说明
短路求值	    | hash 不等 → 不执行 equals()
引用优先	    | 先== 后equals()，提升常见 case 性能
null安全	    | 显式检查 key != null，避免 NPE
局部变量缓存	| k = first.key 减少字段访问
快速路径	    | 大多数查询 在此处结束，不进循环

===
do {
    if (e.hash == hash &&
        ((k = e.key) == key || (key != null && key.equals(k))))
        return e;
} while ((e = e.next) != null);
这段 在链表中查找entry的代码 为什么这样实现呢?

==
为什么使用do...while，而不是while?

✅ 这避免了 while 循环中 重复的非空检查，代码更紧凑。

对比：如果用 while
// 不够优雅的写法
while (e != null) {
    if (匹配) return e;
    e = e.next;
}
→ 功能相同，但 do-while 更贴合 “已知首节点非空”的上下文。

==
✅ 总结：为什么这样实现？
问题                  |	答案
为什么用 do-while？	 | 因为 入口 已保证 e != null，先执行后判断 更自然
为什么先比 hash？	     | 快速过滤，避免不必要的 equals()
为什么有 key != null？ |	防止 null.equals() 抛出异常
为什么缓存 k = e.key？  |	减少字段访问，提升 CPU 缓存效率
为什么不处理树？	     | 树的情况在外层已被分流