===
✅ 一、整体思路
putTreeVal() 的执行流程 可以概括为：

① 从树的根节点开始查找；
② 沿着树 向下遍历，比较 hash和key，找到：
    1.要么 已存在的 相同key的节点（返回它，用于 更新value）；
    2.要么 合适的插入位置（作为 新叶子节点 的 父节点）；
③ 如果需要插入：
    1.创建 新TreeNode；
    2.插入到树中；
    3.修复 红黑树性质（通过 旋转 和 变色）；
④ 返回结果：
    如果 key 已存在 → 返回该节点；
    否则 → 返回 null。
🔑 注意：这个方法 不负责 触发树化（那是 treeifyBin() 的事），它只在 已经是树的情况下 工作。

===
✅ 二、关键步骤详解
==
步骤 1️⃣：从根开始遍历

final TreeNode<K,V> root = root(); // 找到 当前桶的树根
通过 root()方法 向上找到 红黑树的根节点（因为调用者 可能是 子节点）。

==
步骤 2️⃣：循环 查找或定位 插入点

// 这里千问AI提供的代码 与 源码 不太一样
for (TreeNode<K,V> p = root;;) {
    int dir, ph;
    K pk;

    if ((ph = p.hash) > h)          dir = -1;   // 当前节点 hash 更大 → 往左
    else if (ph < h)                dir = 1;    // 当前节点 hash 更小 → 往右
    else if ((pk = p.key) == k || (k != null && k.equals(pk)))
        return p;                   // ✅ key 相同！直接返回已有节点
    else
        // hash 相等但 key 不同 → 需要更精细比较（如 Comparable）
        dir = tieBreakOrder(k, pk); // 打破平局（避免退化成链表）

    TreeNode<K,V> xp = p;
    if ((p = (dir <= 0) ? p.left : p.right) == null) {
        // 找到空位！xp 就是父节点
        TreeNode<K,V> x = new TreeNode<>(h, k, v, null, null);
        x.parent = xp;
        if (dir <= 0) xp.left = x;
        else xp.right = x;

        // 插入后平衡树
        root = balanceInsertion(root, x);
        break;
    }
}
关键点：
① 先比 hash：快速分流；
② hash 相等时，比较 key：防止不同key产生了 哈希冲突，导致误判；
③ hash 和 key 都相等？ → 返回 已有节点（用于更新）；
④ hash相等 但 key不同？ → 调用 tieBreakOrder() 用 System.identityHashCode() 或 Comparable 打破平局，确保树结构稳定。

==
步骤 3️⃣：插入后 修复红黑树（balanceInsertion）
红黑树插入 可能破坏以下性质：
① 根必须是黑色；
② 红色节点的子节点不能是红色；
③ 任意路径的黑高相同。

balanceInsertion(root, x) 会通过：
① 变色（recoloring）
② 旋转（leftRotate / rightRotate）
来 恢复 这些性质，确保 树的高度 保持 O(log n)。

📌 这部分是 标准的红黑树 插入修复算法（与《算法导论》一致）。

==
步骤 4️⃣：移动根节点到桶头（重要！）

moveRootToFront(tab, root);
因为 旋转 可能导致 根节点变化；
必须确保 table[index] 始终指向 当前树的根节点；
否则后续操作（如 get）会 找不到树！

===
✅ 三、设计亮点

亮点                   |   	说明
hash优先比较	          | 快速过滤，避免不必要的 equals()
tie-breaking 机制	  | 即使 hash冲突严重，也能 维持树形结构，防止退化
复用 TreeNode 结构	  | 节点 同时支持 哈希桶（next）、红黑树（left/right/parent）、顺序链表（before/after）
与 LinkedHashMap 兼容  | 插入后 会自动维护 before/after（通过钩子方法）

===
✅ 四、返回值语义
返回 非null：表示 key 已存在，返回的是 旧节点（putVal 会 更新其value）；
返回 null：表示 key是一个新key，在树中插入成功（putVal 会增加 size）。


✅ 总结：putTreeVal() 的核心思想
“在红黑树中 查找或插入，保持平衡，并兼容 HashMap 和 LinkedHashMap 的所有需求。”