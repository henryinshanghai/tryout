最后，让我们来聊一聊CHM 对于 计算集合size()的优化。
需要注意的是，无论是 JDK7 还是 JDK8，CHM的size() 都只返回 一个大概数量，无法做到 绝对的精准，
因为 已经统计过的槽 在 size()返回最终结果 前 有可能 又发生了 新的变化，故而导致 返回大小 与 实际大小 之间存在些许差异。

在 多个槽的设计 下，如果 仅仅是为了 统计元素数量 而停下 所有的增删改查操作，又会显得 因噎废食。
因此，CHM 在 设计 元素总数的相关更新和计算 时，会最大限度地 减少 锁的使用，以减少 线程间的竞争 与 相互等待。

在 这个设计思路 下，JDK8的CHM 对元素总数的计算 又做了 进一步的优化，具体表现在：
在 put()、remove()和 size()方法 中，涉及 元素总和的更新和计算 时，都彻底避免了 锁的使用，取而代之的 是 众多的CAS操作。

===
我们先来看 JDK7版本中的put()方法 和 remove()方法，
对于 segment内部元素 和 计数器的更新，全部处于 锁的保护之下。

比如 Segment.put()方法 的第一行：
// 经过这一行代码，能够保证 当前线程 取得 该Segment上的锁。
// 取得锁后，就可以 放心地 更新元素 和 内部的计数器
HashEntry<k> node = tryLock() ? null : scanAndLockForPut(key, hash, value);

JDK7中CHM 获取集合大小的流程图 如下👇

    开始

    遍历所有Segment                         所有Segment上加锁
    计算modCount和size

    自从上次计算后
    Segment结构有了变化   是否已经是第3次计算

    释放各Segment上的锁   返回size总和    结束
        《JDK7版本的CHM》

可以看到，在JDK7的版本，CHM 在 统计元素总数 时 已经开始 避免使用锁了，毕竟 加锁操作 会极大地影响到 其他线程 对哈希元素的修改。
当 经过了3次计算(2次对比) 后，发现 每次统计时 哈希都有 结构性变化，这时 它就会 气急败坏地 把 所有Segment 都加上锁；
在 自己统计完 成后，才会 把锁释放掉，再允许 其他线程 修改 哈希中的元素。

===
获取集合元素个数 是否还有 进一步的优化空间呢？
JDK8 对此给出了回答：有的，兄弟，有的。

在put()方法中，对 哈希元素总数 的更新，是放在 对某个槽的锁 之外的，主要会用到的属性 如下：
    // 记录了 元素总数量；主要用 无竞争状态 下
    // 在 总数被更新 后，通过 CAS方式 直接更新 这个值
    private transient volatile long baseCount;

    // 一个 计数器单元，维护了 一个value值
    static final class CounterCell {...}

    // 在 竞争激烈的状态 下 会启用，线程 会把 总数的更新情况 存放到 该结构中
    // 当 竞争进一步加剧 时，会 通过扩容 减少竞争
    private transient volatile CounterCell[] counterCells;


正是借助 baseCount 与 counterCells 这两个属性，并 配合 多次使用CAS方法，
JDK8中的CHM 避免了 锁的使用。

虽然 源码过程 看起来 非常复杂，但是 思路 却很清晰：
① 当 并发量较小的时候，优先使用 CAS的方式 来 直接更新baseCount；
② 如果 更新baseCount时 发生了冲突，则 认为 进入到 比较激烈的竞争状态，
    1. 通过 启用counterCells 来 减少竞争;
    2. 通过 CAS的方式 把 总数量的更新情况 记录在 counterCells所对应的位置上；
③ 如果 更新 counterCells上的某个位置时 出现了多次失败，则 会通过 扩容counterCells的方式 来 减少冲突。
④ 当 counterCells 处在扩容期间 时，会尝试 更新 baseCount的值。

对于 元素总数的统计，逻辑就更加 简单了，
只需要 让 baseCount 加上 各个counterCells中的数据，就可以得出 哈希内的元素总数量，
整个过程 完全不需要 借助锁。

正因为CHM 提供了 高效的 锁机制实现，在 各种 多线程应用场景中，推荐使用此集合 来 进行KV键值对的 存储与使用。
