什么叫做线程安全? 为什么HashMap是线程不安全的？

===
一、什么是线程安全？
线程安全（Thread-Safe） 是指：

当 多个线程 同时访问 某个类（或对象、方法）时，无论 运行时调度 如何交错，该类的行为 始终符合预期，
不会出现 数据错误、状态不一致 或 程序崩溃 等问题。

换句话说：
① 不需要 外部同步（如加锁），
② 多线程并发 调用其方法，
③ 结果仍然正确、一致、可预测。

✅ 线程安全的典型特征：
① 数据一致性（如计数器不会少加或多加）
② 无竞态条件（Race Condition）
③ 无死锁（虽然 线程安全 不等于 无死锁，但 设计良好的线程安全类 应避免）
④ 内存可见性 有保障（一个线程的修改 对 其他线程 立即可见）

===
二、为什么 HashMap 是 线程不安全的？
HashMap 在设计上 没有做 任何并发控制，其内部状态（数组、链表、size 等）在 多线程 下 极易被破坏。
具体表现为以下几类问题：

==
❌ 1. 数据丢失（最常见）
多个线程同时 put 不同 key，但 哈希到 同一个桶（bucket）：

// 假设 table[i] 初始为 null
Thread T1: map.put("A", 1);  // 创建节点 N1，执行 table[i] = N1;
Thread T2: map.put("B", 2);  // 创建节点 N2，执行 table[i] = N2;

由于 没有同步，T1 的写入 可能 被T2覆盖（或反之），导致 "A" 或 "B" 永久丢失。

==
❌ 2. 扩容时 形成死链（Java 7 特有）
在 Java 7 中，HashMap 扩容（resize）时 使用 头插法 迁移链表。

多线程并发 resize 会导致 链表节点的 next指针 互相指向，形成 环形链表。

后果：
① 调用 get(key) 时陷入无限循环（CPU 100%）
② 程序假死
✅ Java 8 已修复此问题（改用尾插法），但依然线程不安全！

==
❌ 3. size 统计错误
HashMap 的 size 字段 不是 原子的：
    // put 方法中类似逻辑：
    ++modCount;
    size++;  // 非原子操作！

两个线程 同时执行 size++，可能 只增加 1 次（如从 5 → 6，而不是 7）。
结果：map.size() 返回 错误值。

==
❌ 4. 读到中间状态（脏读）
一个线程 正在执行 put（修改链表结构），另一个线程 同时get，可能：
① 读到 部分初始化的节点（字段为 null）
② 遍历到 已被移除的节点
③ 抛出 NullPointerException

===
三、根本原因总结

原因              |   	说明
无 同步机制	     | HashMap 的所有方法 都没有 synchronized 或 volatile 保护
共享 可变状态	     | table 数组、size、modCount 等字段 被多个线程共享 且 可变
复合操作 非原子    | put 涉及 “检查→计算→写入”多个步骤，无法保证 原子性
内存可见性 无保障   |	一个线程 修改 table，另一个线程 可能看不到 最新值（缓存一致性问题）
🔑 核心：HashMap 是为 单线程高性能 设计的，牺牲了 线程安全性。

===
四、对比：线程安全的 Map 实现
类	                            |   线程安全？  |	原理                                          |	适用场景
HashMap	                        |  ❌ 否	      | 无同步	                                         | 单线程
Hashtable	                    |  ✅ 是	      | 所有方法加 synchronized                            | 过时，性能差
Collections.synchronizedMap(map)|  ✅ 是	      | 包装器 + 全局锁	                                 | 简单同步，性能一般
ConcurrentHashMap	            |  ✅ 是	      | 分段锁（Java 7） / CAS + synchronized锁桶（Java 8+）|	高并发首选

===
✅ 六、正确做法
① 单线程 or 只读 → 用 HashMap
② 多线程写 → 用 ConcurrentHashMap
③ 需要强一致性 → 用 Collections.synchronizedMap(new HashMap<>())（但性能差）

🚫 永远不要 在多线程环境中 直接使用 HashMap！

===
🎯 总结
问题	                 |   答案
什么是线程安全？	     | 多线程 并发访问时，行为 始终正确、一致、无异常
为什么 HashMap 不安全？| 无同步、共享 可变状态、复合操作 非原子、内存可见性 无保障
后果有哪些？	         | 数据丢失、死链（Java 7）、size 错误、NPE、无限循环
怎么办？	             | 改用 ConcurrentHashMap

💡 记住：
“高性能” 和 “线程安全” 是两个维度。
HashMap 选择了前者，因此必须 由使用者保证 单线程访问。