#Q: 为什么TreeMap中的Entry内部类 需要有parent这个成员变量呢？HashMap中的Node都没有记录parent

===
TreeMap 和 HashMap 是 Java集合框架中 两种不同的 Map 实现，它们 各自基于 不同的数据结构。
理解为什么 TreeMap 中的 Entry内部类 需要有 parent成员变量 而 HashMap 的 Node 不需要，
关键在于 它们 底层实现 所依赖的数据结构 和 操作方式。

==
TreeMap 与 红黑树
TreeMap 使用 红黑树 作为其 底层的数据结构，这是一种 自平衡二叉搜索树。
红黑树 保证了 基本的操作（如插入、删除和查找）的时间复杂度为 O(log n)。
为了 维持这种平衡性 并 在树中 进行有效的导航，红黑树节点 需要知道 其父节点的位置。这是因为：
① 插入和删除后的 修复操作：
    当 向红黑树中 添加或移除 节点 时，可能需要 通过 旋转 和 重新着色 来 恢复树的平衡属性。
    这些操作 通常需要知道 当前节点的父节点（有时甚至是 祖父节点），以便 正确地调整子树。
② 快速向上遍历：
    在执行某些操作时，比如：
    1. 从 某个叶子节点 向上回溯到 根节点，
    2. 或者是 在删除节点后 找到 合适的替代节点，能够 直接访问父节点 可以 显著提高效率。

因此，在 TreeMap 的 Entry 类中 包含一个 指向父节点的引用 是非常必要的，这有助于 简化代码逻辑，并 确保 所有必要的维护操作 都能高效完成。

==
HashMap 与链表/红黑树
HashMap 则 基于哈希表实现，它使用 数组加链表（或在 Java 8及以后版本 中，当 链表长度 超过一定阈值时 转换为红黑树）的形式存储元素。
在HashMap中的每个节点（即 Node 或者 在特定情况下转换为TreeNode）并不需要 显式地记录 它的父节点，因为：

① 哈希冲突 解决机制：
    对于 普通的链表形式 的冲突解决方法，节点之间 形成的是 一个单向链表，
    新元素 总是被添加到 链表的头部或尾部，不需要知道 前驱节点是谁。
② 性能考虑：
    由于HashMap 主要依赖于 哈希函数 将键映射到 特定索引位置，理论上 每个桶内的链表 应该是较短的（理想情况下是O(1)）。
    即使在 负载因子较高 时 转为红黑树，TreeNode 也实现了 自我指向（next 和 prev 指针 用于 双向链表连接），
    但是 在这个场景下，主要是为了 支持快速遍历 整个桶内的元素，而不是为了 像TreeMap那样 需要频繁地 对树结构 进行修改和调整。

总结来说，TreeMap 中的 Entry 需要有 parent 成员变量 是因为 它构建于 需要频繁进行结构调整 以 保持平衡性的红黑树之上；
而 在HashMap中，无论是 链表形式 还是 转换后的红黑树形式，都不需要 显式的父节点指针 来 满足其设计目标 和 操作需求。

这是因为 HashMap的设计重点 在于 通过哈希函数 快速定位元素，而不是 像TreeMap那样 依赖于 树形结构的严格顺序 和 平衡性。

===
AI总结

为什么 TreeMap 的 Entry 有 parent，而 HashMap 的 Node 没有？

TreeMap 基于 红黑树，是一种 二叉搜索树，需要频繁：
① 向上查找 父节点（比如插入/删除后修复平衡）
② 做旋转、重新着色等操作
→ 所以 每个节点 必须知道 自己的父节点是谁，因此 Entry 里有 parent 字段。

HashMap 基于哈希表 + 链表/红黑树（仅在桶内）：
① 正常情况下是 单向链表，只需 next 指针；
② 即使 桶内 转成 红黑树（TreeNode），它的树操作 是 局部的、独立的，
    且 JDK 通过其他方式（如 双向链表链接）处理遍历，不需要 通用的 parent 指针 来 维护全局结构 → 所以普通 Node 不需要 parent

✅ 一句话总结：
TreeMap 要靠 parent 来 维护 整棵树的结构和平衡；
HashMap 不需要，因为它 不依赖 树的父子关系 来 工作。