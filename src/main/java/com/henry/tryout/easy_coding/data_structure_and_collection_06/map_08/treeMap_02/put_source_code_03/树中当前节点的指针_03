x = parentOf(x);
这行代码是在做什么？感觉有点子奇怪的

===
一、这行代码出现的典型上下文
它通常出现在 “折线型”（LR或RL）情况 中，例如：

    if (x == rightOf(parentOf(x))) {      // x 是父节点的右孩子 → LR 型
        x = parentOf(x);                  // ←←← 就是这行！
        rotateLeft(x);                    // 对原来的父节点左旋
    }
🎯 目标：
我们要 把 LR型（或 RL型） 转换成 LL型（或 RR型），这样才能用 统一的方式（一次旋转 + 变色）完成修复。

二、为什么需要 x = parentOf(x)？
情景还原（以 LR 型为例）：
假设 插入后 结构如下（R=红，B=黑）：
        g(B)
       /
     p(R)
       \
       x(R)   ← 当前插入的节点
① 这里 x 是 p的右孩子，p 是 g的左孩子 → LR型红红冲突
② 我们不能 直接对g旋转（会破坏 BST 性质）
③ 正确做法：先 对p左旋，把 x 提上去，变成 LL 型

但注意：rotateLeft(node) 的语义是 “以node为轴 进行左旋”。
所以我们需要调用：rotateLeft(p)
然而，在代码中，我们手头 只有变量 x（指向 新插入的节点）。

要拿到 p，就得写 parentOf(x)。
于是：
    x = parentOf(x);   // 现在 x 指向 原来的父节点p
    rotateLeft(x);     // 即 rotateLeft(p)
✅ 这行代码的本质是：让 x 指向 即将被旋转的节点（即 原来的父节点）

三、为什么不用 新变量？比如 Entry p = parentOf(x); rotateLeft(p);？
完全可以！从逻辑上讲，这样更清晰。例如：
    Entry<K,V> p = parentOf(x);
    rotateLeft(p);
    x = p;  // 后续可能还需要用 x 指向新位置？

但 JDK 的实现选择 复用 x 变量，原因包括：
① 减少 局部变量数量（JDK 源码风格偏向紧凑）
② 后续逻辑 仍以 “当前关注节点” 为中心，旋转后，新的子树根 是 原来的 x（现在 变成了 p的父），
    但 修复逻辑 接下来 会对g旋转，所以 其实 x的值 在下一行就不再关键。
③ 历史/习惯写法：很多经典算法教材（如《算法导论》）也采用类似 “移动 x 指针”的方式 描述 修复过程。
所以 x = parentOf(x) 并不是“bug”或“多余”，而是为了 方便调用旋转函数 而 临时调整指针。

===
可以看到，x = parentOf(x) 是 为旋转做准备 的中间步骤。

五、总结
问题                      |       	解答
x = parentOf(x) 在做什么？ |	让 x 指向 其父节点，以便 对该父节点 执行旋转操作
为什么看起来奇怪？          |	因为 变量名x 原本代表 “新插入节点”，现在 却指向 它的父节点，语义 发生了变化
是否必要？	             | 不是 逻辑上必要，但是一种 简洁的编码技巧，避免 引入新变量
会不会影响后续逻辑？	     | 不会。因为在 折线型 处理完后，马上会 进行第二次旋转（对祖父），之后 循环通常就结束了

✅ 记住一句话：
x = parentOf(x) 是为了“把 旋转的轴心 赋给 x”，方便调用 rotateLeft(x) 或 rotateRight(x)。

如果你觉得混淆，完全可以理解为：
    Entry pivot = parentOf(x);
    rotateLeft(pivot);
JDK 只是省略了 pivot，直接复用了 x。