多线程条件下 HashMap为什么会有数据丢失的问题?

===
✅ 为什么 ConcurrentHashMap 不会丢数据？
因为它通过 以下机制 保证 线程安全：
    ① 分段锁（Java 7） 或 CAS + synchronized 锁桶（Java 8+）
    ② 对 每个桶（bin）单独加锁，避免 全局竞争
    ③ size() 使用 CounterCell 精确统计
    ④ 扩容时 采用 协作式迁移，确保每个节点 只被迁移一次

📌 总结：多线程下 HashMap 数据丢失的原因
原因类型         |             说明                	      | 是否存在于 Java 8
并发 插入同一桶   |	多个线程 同时写 table[i]，互相覆盖	      |  ✅ 是
并发 扩容迁移	    | 多线程 同时迁移节点，部分节点 未被迁移 或覆盖 |  ✅ 是
size 计数不准确	| modCount 和 size 非原子更新               |	✅ 是
死链（无限循环）	| Java 7 特有，Java 8 已修复	              | ❌ 否


🔒 根本结论：
HashMap 的 所有修改操作 都不是原子的，也没有 内存可见性保证。
因此，在 多线程环境 中，无论 是否发生扩容，都可能出现 数据丢失、覆盖、计数错误等问题。

✅ 正确做法
① 单线程 or 只读 → 用 HashMap
② 多线程写 → 用 ConcurrentHashMap
③ 需要强一致性 → 用 Collections.synchronizedMap(new HashMap<>())（但性能差）

永远不要为了“性能”而在并发场景冒险使用非线程安全的 HashMap —— 数据丢失的代价远高于锁的开销。