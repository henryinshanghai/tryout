public V get(Object key) {
    Node<K,V> e;
    return (e = getNode(hash(key), key)) == null ? null : e.value;
}

final Node<K,V> getNode(int hash, Object key) {
    // 局部变量：tab是 散列表的副本; first 是 哈希桶(bin)中的的第一个节点的指针; e表示 遍历过程中 当前正在检查的条目；
    // n 为 哈希表数组的长度（避免重复调用 tab.length）； k?
    Node<K,V>[] tab; Node<K,V> first, e; int n; K k;

    --- 从 散列表的哈希桶 中 查找节点 - 分类讨论 {① 哈希槽节点, ② 非哈希槽节点} ---
    // 如果 散列表 不为空 & 哈希槽上的节点 不为null
    if ((tab = table) != null && (n = tab.length) > 0 &&
        (first = tab[(n - 1) & hash]) != null) {
        // 检查 哈希桶中的第一个节点 是否是 待查询的节点
        if (first.hash == hash && // always check first node
            ((k = first.key) == key || (key != null && key.equals(k))))
            // 如果 是，则：返回节点
            return first;

        --- 从 非哈希槽节点 中 查找节点 - 分类讨论 {① 哈希槽节点 是 树节点；② 哈希槽节点 是 链表节点} ---
        // 如果 头节点的下一个节点 不为null
        if ((e = first.next) != null) {
            // 检查 头节点 是不是 树节点，如果 是，则：
            if (first instanceof TreeNode)
                // 从树中查找 指定key 所对应的树节点
                return ((TreeNode<K,V>)first).getTreeNode(hash, key);
            // 否则，哈希桶中 一定是 一个链表。则：
            // 沿着 链表节点 一路向后查找 - 手段：do-while循环
            do {
                // 如果 当前节点 就是 要查找的节点(其key 与 待查询的key 相同)，
                if (e.hash == hash &&
                    ((k = e.key) == key || (key != null && key.equals(k))))
                    // 则：返回当前节点
                    return e;
                // 否则，继续查找 下一个节点 - e = e.next
            } while ((e = e.next) != null);
        }
    }

    // 实在 找不到，则：返回null
    return null;
}