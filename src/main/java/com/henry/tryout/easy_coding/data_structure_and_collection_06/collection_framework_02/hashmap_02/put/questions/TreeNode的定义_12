HashMap中树化的结果是一棵红黑树吗？
为什么TreeNode的节点定义 比起 标准红黑树的节点定义 感觉复杂很多呢?

===
✅ 一、先确认：树化后真的是红黑树吗？
是的！

JDK 8 引入 树化机制 时，明确说明 使用 红黑树 来 替代 长链表；
源码中包含完整的红黑树操作：
① balanceInsertion() → 插入后修复
② balanceDeletion() → 删除后修复
③ rotateLeft() / rotateRight() → 旋转操作
这些算法 与 《算法导论》中的 标准红黑树 一致。
✅ 所以：结构上是 红黑树，性能上 保证 O(log n) 查找。

===
✅ 二、为什么 TreeNode 比“标准红黑树节点”复杂？
📌 标准红黑树节点（教科书版）通常长这样：
class RBNode {
    boolean red;        // 颜色
    Key key;
    Value value;
    RBNode left;
    RBNode right;
    RBNode parent;      // 有些实现不需要 parent
}

📌 而 HashMap.TreeNode 长这样（简化）：
static final class TreeNode<K,V> extends LinkedHashMap.Entry<K,V> {
    TreeNode<K,V> parent;  // 红黑树父节点
    TreeNode<K,V> left;    // 左子
    TreeNode<K,V> right;   // 右子
    TreeNode<K,V> prev;    // needed to unlink next upon deletion
    boolean red;           // 颜色

    // 继承自 LinkedHashMap.Entry:
    Entry<K,V> before, after;  // 全局顺序链表指针

    // 继承自 HashMap.Node:
    final int hash;
    final K key;
    V value;
    Node<K,V> next;        // 哈希桶内链表指针
}

===
🔍 三、为什么这么复杂？—— 四重身份合一！
TreeNode 不只是 一个红黑树节点，它 同时承担 四种角色：

角色	                            |        字段               |	用途
1. 哈希表节点（HashMap.Node）      | hash, key, value, next   |	支持 table[i] 存储、链表兼容、entrySet()
2. 红黑树节点	                    | parent, left, right, red | 	支持 O(log n) 查找、插入、删除
3. 双向顺序链表节点（LinkedHashMap）|	before, after	       | 支持插入/访问顺序遍历（如 LRU）
4. 链表删除辅助（prev）	        |      prev	               | 在树转回链表（untreeify）或删除时快速断开 next 链

🌟 一个节点，四套指针系统，全部共存！

===
✅ 四、逐个解释 “多余”的字段
1. next（来自 HashMap.Node）
即使 在树中，next 仍然保留；
作用：当 树退化（节点数 < 6）时，能 快速转回 链表（untreeify()）；
无需 重建链表，直接用 现有的next指针。

2. prev（由TreeNode 特有）
用于 在 删除节点 时，快速 从 next链表中 断开自己；
因为 next 是单向的，没有 prev的话，就需要 从头遍历 找前驱，效率低；

// 删除节点 p
if (p.next != null)
    p.next.prev = p.prev; // ← 需要 prev 字段！

if (p.prev != null)
    p.prev.next = p.next;

3. before / after（来自 LinkedHashMap.Entry）
即使 节点 在红黑树中，LinkedHashMap 仍需维护 全局顺序；
所以 TreeNode 必须保留 这两个指针；
使得 entrySet().iterator() 依然 按插入/访问顺序遍历。

4. 继承链设计

TreeNode
  → extends LinkedHashMap.Entry
    → extends HashMap.Node

这种继承不是“为了树”，而是为了 复用和兼容；
让 HashMap 和 LinkedHashMap 都能 无缝使用 TreeNode。

===
✅ 五、这种设计的代价与收益
方面	     |   说明
内存开销	 |  每个 TreeNode 比 标准红黑树节点 多出了 3~4 个引用（约 24~32 字节）
代码复杂度 |	高（需维护 多套指针的一致性）
性能收益	 |  ✅ 极高：
            • 树化/反树化 O(n) 完成
            • LinkedHashMap 无需额外存储顺序
            • 删除操作高效
架构收益	 | ✅ 一套节点，三种数据结构（链表 + 红黑树 + 双向链表）无缝切换

===
✅ 总结
问题	                    |       答案
树化后是红黑树吗？	        |   ✅ 是，完整实现了红黑树的平衡规则
为什么 TreeNode 更复杂？	|   因为它同时服务于三种结构：
                                1. 哈希桶（next）
                                2. 红黑树（left/right/parent/red）
                                3. 全局顺序（before/after）
                                4. 高效删除（prev）
这是过度设计吗？	        | ❌ 不是！这是在内存、性能、兼容性之间做出的精妙权衡

你现在看到的，是 JDK 在 单一数据结构 中 融合 多种抽象的典范。

这种“多功能合一”的思想，在操作系统、数据库、编译器等底层系统中极为常见。