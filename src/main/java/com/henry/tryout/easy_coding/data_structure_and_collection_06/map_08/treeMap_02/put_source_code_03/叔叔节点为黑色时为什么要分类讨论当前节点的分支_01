🖼️ 对比图示总结
情况	                |     结构          |	是否需要预旋转？  |	修复步骤
叔叔黑 + x 是左孩子	| G ← P ← x（直线）  |      ❌ 不需要	    | 染色 + 对 G 右旋
叔叔黑 + x 是右孩子	| G ← P → x（折线）  |      ✅ 需要	    | 先对 P 左旋 → 变直线 → 再染色 + 对 G 右旋

对称地，当父节点是 祖父的右孩子 时，方向反过来：
① x 是右孩子 → 直线 → 左旋
② x 是左孩子 → 折线 → 先右旋父，再左旋祖父

===
💡 为什么不能跳过 “折线→直线”的转换？
因为 旋转操作 只能有效消除 “直线型”的双红冲突。
在折线结构中，直接旋转祖父 会让 x 和 P 仍然保持 父子关系 且 同为红色，冲突未解决！

只有 先把折线“拉直”，才能 通过一次旋转 将红色节点移到外侧，中间插入一个黑色节点 作为缓冲，从而满足 “红节点的孩子必须是黑”的规则。

===
✅ 总结
当 叔叔为黑色 时，必须区分 x 是左/右孩子，是因为：
① 结构形状不同（直线 vs 折线）决定了 是否需要 预旋转；
② 折线结构 不能 直接 仅通过一次旋转 修复双红冲突；
③ 预旋转（如左旋/右旋父节点）是为了 转化为 标准直线情形，再用 统一方式修复。

这是红黑树 插入修复 中 最精妙的设计之一，确保了 O(1) 次旋转 即可完成修复！