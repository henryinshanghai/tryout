重新染色 不会打破红黑树的黑高约束吗？

===
这是一个非常核心、触及红黑树设计精髓的问题！
“重新染色不会打破红黑树的黑高约束吗？”
答案是：在 fixAfterInsertion() 中，所有 合法的 重新染色操作 都经过精心设计，确保 不会 破坏黑高（Black-Height）约束（即红黑树性质5）。

下面我们从两种主要染色场景来详细解释 为什么不会破坏黑高。

===
✅ 场景一：叔叔为红色（Red Uncle）→ “向上冒泡”型染色
操作：
    父节点 → 黑
    叔叔节点 → 黑
    祖父节点 → 红

初始状态（插入后）：
        G(B)
       /     \
     P(R)    U(R)
     /
   N(R)   ← 新插入（红）

❌ 问题：P 和 N 都是红 → 违反性质4（连续红）

染色后：
        G(R)
       /     \
     P(B)    U(B)
     /
   N(R)

🔍 黑高分析（以 G 为根的子树）：
路径	                |       染色前黑高        |	染色后黑高
G → P → N → NIL	    | G(B) + NIL = 2        | G(R) + P(B) + NIL = 2
G → P → NIL（若无N）	| G(B) + NIL = 2	    | G(R) + P(B) + NIL = 2
G → U → NIL	        | G(B) + U(R) + NIL = 2	| G(R) + U(B) + NIL = 2

===
✅ 所有路径黑高仍为 2！

🧠 为什么？
① 祖父 由黑变红 → 所有经过 G 的路径 黑高 -1
② 父和叔叔 由红变黑 → 所有经过 P 或 U 的路径 黑高 +1
净变化：(-1) + (+1) = 0 → 黑高守恒！
💡 这就像“把黑色从祖父 下放给 两个孩子”，总量不变。

⚠️ 唯一副作用：G 变红后，如果 G 的父也是红，会 向上冒泡 新冲突——但这是递归修复的一部分，局部黑高 始终守恒。

===
✅ 场景二：叔叔为黑色（Black Uncle）→ “旋转+染色”型

以 LL 型 为例：

操作：
    父节点 → 黑
    祖父节点 → 红
    然后对祖父右旋

染色后（旋转前）：
        G(R)
       /
     P(B)
     /
   N(R)

黑高分析（以 G 为根）：
路径	             |   黑高
G → P → N → NIL	 | G(R) + P(B) + NIL = 2
G → U（叔叔）→ NIL|	G(R) + U(B) + NIL = 2

✅ 仍然一致！

==
🔄 旋转后结构：
      P(B)
     /   \
   N(R)  G(R)
          \
          U(B)
现在以 P 为新子树根，检查黑高：

路径              |	黑高
P → N → NIL	     | P(B) + NIL = 2
P → G → U → NIL	 | P(B) + U(B) + NIL = 2
✅ 依然一致！

🧠 为什么？
① 旋转 不改变 任何路径上的节点集合，只改变 父子关系
② 染色时：父变黑（+1），祖父变红（-1） → 子树内 黑高总和 不变
③ 旋转前后，每条 从根到 NIL 的路径 所经过的黑色节点数量完全相同

===
✅ 总结：为什么 重新染色 不破坏 黑高？

染色类型        |	黑高守恒原理
叔叔红（情况1）  |	祖父 黑→红（-1），父+叔 红→黑（+2），但因父/叔 各在一侧，每条路径 只经过其中一个
                    → 实际每条路径：-1（祖父）+1（父或叔）= 0
叔叔黑（情况2/3）|	父 红→黑（+1），祖父 黑→红（-1）→ 每条路径 净变化为0
旋转操作	       |    仅重排指针，不 增删节点、不 改变颜色 → 黑高天然不变

🌟 红黑树修复的核心思想：
所有操作（染色+旋转）都保持“局部黑高守恒”，从而保证 全局性质5 始终成立。
因此，你可以放心：fixAfterInsertion() 中的 重新染色，是 数学上 严格保证 黑高不变的精巧设计，不是 随意修改颜色。