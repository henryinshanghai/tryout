根据 对属性的初步认识，我们可以 勾勒出 CHM的大致存储结构👇
    [桶节点0(Node类型)] - <链表>
    [桶节点1]
    [桶节点2(ReservationNode类型)]
    [桶节点3]
    [桶节点4(TreeBin类型)] - <红黑树>
    [桶节点5(ForwardingNode类型)]

图中，table的长度为64，数据存储结构 分为两种：链表 和 红黑树。
    ① 当 某个槽中的元素个数 增加到 超过8个 且 table的容量 大于或等于 64时，由链表转为红黑树；
    ② 当 某个槽中的元素个数 减少到6个时，由 红黑树 重新转回 链表。

链表转红黑树 的过程，就是 把给定顺序的元素 构造成 一棵红黑树的过程。
需要注意的是，当 table容量 小于 64 时，只会 进行扩容，并不会 把链表转化为红黑树。

在 转化过程 中，使用 同步块 锁住 当前槽的首元素，防止 其他进程 对 当前槽 进行增删改查操作；
转化完成后，利用 CAS 替换 原有链表??

因为 TreeNode节点 也存储了 next引用，所以 红黑树转链表的操作 就变得 非常简单，
只需要 从 TreeBin的first元素 开始 遍历所有的节点，并 把节点 从 TreeNode类型 转化为 Node类型 即可。
当 构造好 新的链表 之后，同样会 利用CAS 替换 原有红黑树。

相对来说，链表转红黑树 更为复杂，流程图如下。

    开始

    table为空

    table容量小于64

    是否为链表结构

    锁住该槽

    构建红黑树来替换链表      释放槽上的锁      结束

    《存储结构转换的流程图》
