package com.henry.tryout.easy_coding.data_structure_and_collection_06.map_08.treeMap_02.build_a_RBTree_04;

import java.util.TreeMap;

// 验证：通过put()来构建红黑树时，可能产生的冲突情形 及 对应的解决方案；
// 对 插入情形 的分类：{① 插入节点的父节点 是 其爷爷节点的左子节点 还是 右子节点；② 插入节点的叔叔节点 是 红色节点 还是 黑色节点；
// ③ 插入节点 是其父节点的左子节点 还是 右子节点；}
// 对 各个冲突情形 针对性的解决方案：
// ① 如果 叔叔节点 是红色节点，则：对 它们以及爷爷节点 都重新染色即可；
// ② 如果 插入节点 与 其父节点 构成了 折线形的红红冲突，则：先通过旋转父节点 转化为 直线型的红红冲突，再 通过 “染色 + 旋转”的组合拳 解决冲突；

// *4 一个路径上不能出现 "相邻的两个红色节点"；
// *5 在任何递归子树上，根节点到叶子节点的 所有路径上，都要包含 "相同数量的黑色节点"。
public class BehindTheSceneOnPut {
    public static void main(String[] args) {
        TreeMap<Integer, String> treeMap = new TreeMap<>();

        // 构建 红黑树
        // 插入55节点
        /* 作为根节点，把节点涂黑 */
        treeMap.put(55, "fifty-five");

        // 插入56节点
        /* 节点 插入时为红色，父节点55为黑色 不需要做调整 */
        treeMap.put(56, "fifty-six");

        // 插入57节点
        /*
            插入的节点57 为红色，父节点56 也是红色，因此 出现了 两个连续的红色节点（红红冲突）
            条件：① 插入节点的父节点 是 其爷爷节点 的右子节点；② 插入节点 的 叔叔节点是黑色的(nil节点)；③ 插入节点 是 其父节点的右子节点
            据此，可以定位到 具体执行的分支为 TreeMap[2289,2291]
            步骤：
                ① 先对 当前节点的父节点、当前节点的爷爷节点 重新染色；
                ② 再 以爷爷节点为轴进行左旋转（效果：爷爷节点下沉到左下方）；
                ③ 退出循环后，把根节点染黑；（这个是单独的操作）
         */
        treeMap.put(57, "fifty-seven");

        // 插入58节点
        /*
            插入的节点58 是红色，父节点57 也是红色，因此 出现了 两个连续的红色节点（红红冲突）
            条件：① 插入节点的父节点 是 其爷爷节点的 右子节点；② 插入节点的叔叔节点 为 红色节点(55)；
            据此，可以定位到 具体执行的分支为 TreeMap[2280,2284]
            步骤：
                ① 把父节点、叔叔节点 重新染色(黑色)；
                ② 把 爷爷节点 重新染色（红色） - 相当于把红链接向上传递
                ③ 退出循环后，把根节点染黑；（这个是单独的操作）
         */
        treeMap.put(58, "fifty-eight");

        // 插入83节点
        /*
            条件：① 插入节点的父节点58 是 其爷爷节点57的 右子节点；② 插入节点的叔叔节点 是 黑色节点（nil节点）；③ 插入节点为 其父节点的右子节点；
            据此，可以定位到 具体执行的分支为 TreeMap[2289,2291]
            步骤：① 给 父节点、爷爷节点 都重新染色；② 以爷爷节点为轴 进行左旋转（效果是 爷爷节点下沉到左下方）
         */
        treeMap.put(83, "eighty-three");

        // 删除57节点 - 红色的叶子节点，删除它 不会影响 红黑树的任何性质 所以直接删除就行
        treeMap.remove(57);

        // 插入59节点 - 父亲83是 爷爷的右子节点; 左叔是 黑色节点; 自己是 父亲的左子节点(大儿子) #case02
        /*
            条件：① 插入节点的父节点83 是 其爷爷节点的右子节点；② 插入节点的叔叔节点 是黑色的(nil节点)； ③ 插入节点 是 其父节点的左子节点；
            据此，定位到 具体执行的分支为 TreeMap[2285, 2291]
            步骤：
                ① 把 当前节点指针 移动到 插入节点的父节点上，然后 以之为轴 进行右旋转；（效果 - 得到 RR型冲突）
                ② 对 当前节点 的父节点、爷爷节点 重新染色；
                ③ 以 爷爷节点 作为轴心，进行左旋转（效果 - 爷爷节点 会下沉到 左下方）
         */
        treeMap.put(59, "fifty-nine");
    }
}
/*
为了 恢复平衡，可能需要 多次的操作 - 但至多不超过3次（比如节点59）
红黑树的任何不平衡 都能 在3次旋转中 调整完成 - 向上回溯的步长是2 - 对于 频繁插入与删除的场景，优势很明显(相比于AVL树)
TreeMap本身是 线程不安全的。
 */