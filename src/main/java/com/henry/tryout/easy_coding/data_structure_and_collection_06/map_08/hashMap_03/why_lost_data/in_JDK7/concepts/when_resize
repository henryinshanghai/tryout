与扩容相关的概念：
#1 length - table数组的长度；
#2 size - 通过put方法 添加到HashMap中的 所有元素的个数
#3 hashCode - Object.hashCode()返回的int值。 要求：尽可能 数学上 离散分布
#4 hash - hashCode 与 当前集合的table.length 进行 位运算 的结果，用来 确定hash槽的位置

扩容机制：
当 容器中的元素数量 > 默认容量大小 * 负载因子 时，就会 进行扩容。

resize操作：
    在 第4次元素 复制完成 后，哈希桶内的元素 被 逆序排列到新表 中。

    为什么会 逆序排列呢？
    resize() + transfer()数据迁移 [JDK7]

    分析 - 元素是 怎么丢失的
    #1 transfer()数据迁移方法 - 如果 数组非常大，则：方法会 非常消耗资源；
    #2 多线程条件下，当前线程 迁移过程中，其他线程新增的元素 可能就会落到 已经遍历过的哈希槽 中了；
    #3 遍历完成后，table的数组引用 会指向 newTable - 这时 新增元素 就会丢失，然后 被作为垃圾回收。

    如果 resize完成(也就是执行了 table = newTable), 则：
        后继的元素 就可以 在新的表上 执行插入操作。
    但如果 多个线程 同时执行 resize操作(每个线程 都会 new Entry[newCapacity] - 这是线程的 局部数组对象，不同线程之间 是 不可见的。)

    在 迁移完成 后，resize的线程 就会赋值给 table 这个线程共享变量。
    结果：覆盖 其他线程的操作 - 在 新的表 中 插入的对象 就会 被丢弃掉。