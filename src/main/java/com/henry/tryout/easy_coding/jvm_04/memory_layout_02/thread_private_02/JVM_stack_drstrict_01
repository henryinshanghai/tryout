JVM Stack(虚拟机栈)

运行环境的不同分类：
    相对于 基于寄存器register 的运行环境（CPU的方式）来说，JVM是 基于栈stack结构的运行环境。

JVM中的虚拟机栈
    作用：描述 Java方法执行的内存区域。
    特征：
        1 这个区域是线程私有；
        2 栈中的元素 用于 支持虚拟机进行方法调用 - 每个方法 从开发调用到执行完成的过程，就是 栈帧从入栈到出栈的过程。
        3 在活动线程中，只有位于栈顶的帧才是有效的，aka 当前栈帧。
        4 正在执行的方法 叫做当前方法 - 栈帧也是方法运行的基本结构。
            在 执行引擎运行时，所有指令都 只能针对当前栈帧 进行操作。
            而 StackOverflowError 表示 请求的栈溢出，导致 内存耗尽 - 通常出现递归方法中。

比喻：
    0 JVM虚拟机栈 = 方法帧 所组成的栈结构；
    1 当前方法的栈帧 都是正在战斗的战场。
    2 其中的操作栈 是参与战斗的士兵。
原理：
    虚拟机栈 通过压栈与出栈的方式，对 每个方法对应的活动栈帧 进行运算处理：
    - 方法正常执行结束，肯定会跳转到 另一个栈帧上。
    - 在执行的过程中，如果出现异常，会进行异常回溯 - 返回地址 通过异常处理表确定。
评论：
    栈帧在整个JVM体系中的地位很高，包括(4个成员 ) 局部变量表、操作栈、动态连接、方法返回地址。

---
Ⅰ 局部变量表(Local variable)：
作用： 存放 方法参数 与 局部变量；
特征：
    1 相对于 类属性变量(有两个处理阶段： 准备阶段 和 初始化阶段)来说：
        局部变量 没有准备阶段；
        局部变量 必须进行显式的初始化；
    2 对于非静态方法，index[0]位置上 存储的是 方法所属对象的实例引用，然后存储的是 参数和局部变量。
    3 字节码指令中的 STORE指令的作用 就是 把操作栈(👇)中计算完成的局部变量 写回到 局部变量表中。

---
Ⅱ 操作栈(Stack)：

是：一个初始状态为空的桶式结构栈。
作用：在方法执行的过程中，会有各种指令往栈中写入 或者 提取信息。
fact： JVM的执行引擎是基于栈的执行引擎 - 这里的栈指的就是 操作栈。
特征：
    1 字节码指令集的定义 都是基于栈类型的。
    2 栈的深度 在方法元信息的stack属性中。
用法：操作栈 与 局部变量表的交互；
代码demo： simpleMethod
延伸：a=i++的字节码 vs. a=++i的字节码

---
Ⅲ 动态连接(Link) - 这里的动态连接 与 加载字节码文件时的Link阶段是一样的吗？

特征：每个栈帧中都包含有一个 在常量池中对当前方法的引用；
作用：支持 方法调用过程中的动态连接操作。

---
Ⅳ 方法返回地址(Address)

方法执行时，有两种退出情况：
第一：正常退出。
当方法执行到 返回字节码指令时，比如 RETURN, IRETURN,ARETURN;
第二：异常退出。

两种情况下，方法都会返回到 方法被调用的位置。

方法退出的过程，等价于 弹出当前栈帧。
退出的三种方式：
    1 返回值压入上层调用栈帧；
    2 异常信息 抛出给 能够处理的栈帧；
    3 PC计数器 指向方法调用后的 下一条指令。

======
warp up:
1 方法调用 -> 形成栈帧 -> 方法帧 被压进 JVM虚拟机栈。
2 JVM虚拟机栈的栈顶帧 = 当前活动栈帧 -> {局部变量表L + 操作栈S + 动态连接L + 方法返回地址R} （4个独立的区域 LSLR）