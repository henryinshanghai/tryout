CPU - 内存 - 硬盘；

内存的作用：
    承载着操作系统 以及 应用程序的实时运行。

JVM内存布局
作用：规定了 Java在运行过程中的 内存申请、分配、管理的手段，以此保证 JVM的高效稳定运行。

JVM虚拟机规范 -> JVM内存布局
1. Heap堆区域
作用：存储几乎所有的实例对象。
特征：
    1 堆空间由垃圾回收器自动回收；
    2 堆空间 由各个子线程所共享；
    3 堆空间 是所有内存区域中最大的一块。
    4 堆空间的大小可以是固定的，也可以是动态变化的
        手段： JVM运行时参数 -Xms（最小堆容量） -Xmx（最大堆容量）
        实践：在线上生产环境中，吧 Xms与Xmx设置成一样大小，避免 GC后调整堆大小所带来的压力。
    5 堆空间 分成两个大的部分：新生代 + 老年代。
堆空间的工作方式：
    1 对象最开始创建的时候，被存放在 新生代；
    2 新生代 = 一个 Eden区 + 两个 Survivor区域。
    对象一般在 Eden区域生成， 当 Eden区域快被填满时，会触发 Young Garbage Collection(YGC);
    垃圾回收策略：
        1 Eden区域中没有被引用的对象会被直接回收。
        2 依然存活的对象 会被移送到 Survivor区域中。

    Survivor区域：分为 S0 + S1两个内存空间。
    用法：
        每次 YGC的时候，它将存活的对象 复制到 未使用的那块空间；
        然后把 当前正在使用的空间 完全清除；
        再交换两块空间的使用状态。
    特征：
        如果 YGC需要移送的对象非常大，大于 Survivor区域的上限，则：直接移交给 老年代；

    会不会出现一些对象 在 Survivor区域的 S0与S1之间交换来交换去呢？
    手段：
        1 每个对象都会有一个 计数器，每次 YGC的时候都会+1.
        2 使用-XX:MaxTenuringThreshold 参数 能够配置 当计数器到达某个阈值时，对象会从新生代晋升到老年代。
        aka 如果 这个参数被配置为1，那么 对象会被从新生代的Eden区 直接移动到 老年代。

    如果 Survivor区域中放不下对象，则：尝试在老年代中分配空间。
    如果老年代也放不下，则： 触发 Full Garbage Collection (FGC);
    如果还是放不下这个对象，则：抛出 OOM。

fact： 堆中出现OOM的概率 是 内存耗尽异常中最高的。
为了使7JVM遇到OOM异常时能够输出 堆内信息，可以设置 -XX:+HeapDumpOnOutOfMemoryError这个JVM运行参数。

在不同的JVM实现中，堆内存的划分方式是不一样的。

2 Metaspace（元空间）

早在 JDK8版本中，元空间的前身 Perm区已经被淘汰了。
在JDK7及之前的版本中，只有 Hotspot才有 Perm区域，被译为 永久代，它在启动时固定大小，很难进行调优。
在某些场景下，如果动态加载类过多，容易产生 Perm区的OOM -
    某个实际Web工程中，如果功能点比较多，在运行过程中，要不断动态加载很多的类，经常出现致命错误：
    OOM：PermGenspace

    为了解决这个问题，需要设定运行参数 -XX:MaxPermSize=1280m,如果部署到新机器上，往往会因为JVM参数没有修改导致故障再现。
    不熟悉此应用的人排查问题时往往苦不堪言。
而且，永久代在垃圾回收过程中还存在诸多问题。

所以 在JDK8中使用元空间 替换 永久代。
在JDK8及以上版本上，如果再去设定 MaxPermSize参数， JVM启动时并不会报错。但是会提示： warning...

区别于永久代，元空间在本地内存中分配。
在JDK8中，Perm区中的所有内容中：
    - 字符串常量 移到 “堆内存”；
    - 其他内容包括 类元信息、字段、静态属性、方法、常量都移到 “元空间”内。
        比如 Object类元信息、静态属性System.out、整型常量 1000000

在常量池中的String，其实际对象 是被保存在 堆内存中的。

===
JVM Stack(虚拟机栈)

运行环境的不同分类：
    相对于 基于寄存器的运行环境来说，JVM是 基于栈结构的运行环境。

JVM中的虚拟机栈
    作用：描述 Java方法执行的内存区域。
    特征：
        1 这个区域是线程私有；
        2 栈中的元素 用于 支持虚拟机进行方法调用 - 每个方法 从开发调用到执行完成的过程，就是 栈帧从入栈到出栈的过程。
在活动线程中，只有位于栈顶的帧才是有效的，aka 当前栈帧。
正在执行的方法 成为当前方法 - 栈帧也是方法运行的基本结构。
在 执行引擎运行时，所有指令都只能 针对当前栈帧进行操作。
而 StackOverflowError 表示 请求的栈溢出，导致 内存耗尽，通常出现递归方法中。

JVM能够横扫千军，虚拟机栈就是它的心腹大将，
当前方法的栈帧 都是正在战斗的战场。
其中的操作栈 是参与战斗的士兵。

方法调用，形成栈帧 -> 压栈进JVM虚拟机栈。
栈顶帧 = 当前活动栈帧 -> {局部变量表 + 操作栈 + 动态连接  + 方法返回地址}

虚拟机栈 通过压栈与出栈的方式，对 每个方法对应的活动栈帧 进行运算处理：
    - 方法正常执行结束，肯定会跳转到 另一个栈帧上。
    - 在执行的过程中，如果出现异常，会进行异常回溯，返回地址 通过异常处理表确定。
栈帧在整个JVM体系中的地位很高，包括 局部变量表、操作栈、动态连接、方法返回地址。

---
局部变量表：
作用： 存放 方法参数 与 局部变量；
特征：
    1 相对于 类属性变量的准备阶段 和 初始化阶段来说：
        局部变量 没有准备阶段；
        局部变量 必须进行显式的初始化；
    2 对于非静态方法，index[0]位置上 存储的是 方法所属对象的实例引用，然后存储的是 参数和局部变量。
    3 字节码指令中的 STORE指令的作用 就是 把操作栈中计算完成的局部变量 写回到 局部变量表中。

---
操作栈：

是：一个初始状态为空的桶式结构栈。
作用：在方法执行的过程中，会有各种指令往栈中写入 或者 提取信息。
fact： JVM的执行引擎是基于栈的执行引擎 - 这里的栈指的就是 操作栈。
特征：
    1 字节码指令集的定义 都是基于栈类型的。
    2 栈的深度 在方法元信息的stack属性中。
用法：操作栈 与 局部变量表的交互；

---
动态连接

每个栈帧中都包含一个 在常量池中对当前方法的引用，作用：支持 方法调用过程中的动态连接。

---
方法返回地址

方法执行时，有两种退出情况：
第一：正常退出。
当方法执行到 返回字节码指令时，比如 RETURN, IRETURN,ARETURN;
第二：异常退出。

两种情况下，方法都会返回到 方法被调用的位置。

方法退出的过程，等价于 弹出当前栈帧。
退出的三种方式：
    1 返回值压入上层调用栈帧；
    2 异常信息 抛出给 能够处理的栈帧；
    3 PC计数器 指向方法调用后的 下一条指令。

---
4 本地方法栈 对标 虚拟机栈
作用：为 native方法服务；
特征：
    1 线程对象私有；
    2 线程开始调用 本地方法时，会进入一个 不受JVM约束的世界。
    3 本地方法 能够通过 JNI（Java 本地接口）来：
        - 访问 虚拟机运行时的数据区
        - 调用寄存器
      aka，有和JVM相同的能力与权限 —— 这会削弱JVM对系统的控制能力。
用法：
    最出名的本地方法 System.currentTimeMillis.

---
5 Program Counter Register(程序计数寄存器)

特征：
    Register的命名 来自与 CPU的寄存器：
        1 CPU只有把数据装载到寄存器后才能够运行。
        2 寄存器 用来 存储指令相关的现场信息；
        3 由于 CPU的轮询限制，多线程在并发执行的过程中，某一个确定的时刻，某个CPU内核指挥执行 某个线程中的一条指令。

    线程由于CPU时间片的原因被中断后，怎么能够恢复执行呢？
    原理：
        1 每个线程在创建后，都会有自己的程序计数器 与 栈帧；
        2 程序计数器 用来 存放执行指令的偏移量 与 行号执行器；
        3 线程恢复执行 就需要依赖程序计数器。
    特征：
        程序计数器 在各个线程之间互不影响，所以这个内存区域不会发生 内存溢出类型的异常。

======
warp up:

从线程共享的方面来看，
- 堆内存 + 元空间内存 是所有线程共享的；
- 虚拟机栈 + 本地方法栈 + 程序计数器 是线程私有的。

堆内存、元空间内存；
虚拟机栈、本地方法栈、程序计数器；
















