JVM Stack(虚拟机栈)

对 运行环境 的不同分类：
    相对于 基于 寄存器register 的运行环境（CPU的方式）来说，JVM 是 基于 栈stack结构 的运行环境。

JVM中的虚拟机栈
    作用：描述 Java方法执行 的内存区域。
    特征：
        1 这个区域 是 线程私有；
        2 栈中的元素 用于 支持虚拟机 进行方法调用 - 每个方法 从 开始调用 到 执行完成 的过程，就是 栈帧 从入栈 到 出栈的过程。
        3 在 活动线程 中，只有 位于栈顶的帧 才是有效的，aka 当前栈帧。
        4 正在执行的方法 叫做 当前方法 - 栈帧 也是 方法运行的基本结构。
            在 执行引擎 运行 时，所有指令 都只能 针对当前栈帧 进行操作。
            而 StackOverflowError 表示 请求的栈溢出，导致 内存耗尽 - 通常出现在 递归方法 中。

比喻：
    0 JVM虚拟机栈 = 由 方法帧 所组成的栈结构；
    1 当前方法的栈帧 都是 正在战斗的战场。
    2 其中的操作栈 是 参与战斗的士兵。
原理：
    虚拟机栈 通过 压栈 与 出栈 的方式，对 每个方法 所对应的活动栈帧 进行 运算处理：
    - 方法正常执行结束，肯定会跳转到 另一个栈帧上。
    - 在 执行的过程 中，如果 出现异常，会 进行异常回溯 - 返回地址 通过 异常处理表 来 确定。
评论：
    栈帧 在 整个JVM体系 中的地位很高，包括(4个成员) 局部变量表、操作栈、动态连接、方法返回地址。

---
Ⅰ 局部变量表(Local variable)：
作用：存放 ① 方法参数、② 局部变量 以及 ③ 对象的引用；
特征：
    1 相对于 类属性变量(有两个处理阶段：准备阶段 和 初始化阶段)来说：
        ① 局部变量 没有 准备阶段；
        ② 局部变量 必须进行 显式的初始化；
    2 对于 非静态方法，index[0]位置上 存储的是 方法所属对象的 实例引用，然后 存储的是 参数 和 局部变量。
    3 字节码指令中的 STORE指令的作用 就是 把 操作数栈(👇)中 计算完成的局部变量 写回到 局部变量表 中。

---
Ⅱ 操作数栈(Operand Stack)：

是：一个 初始状态为空 的 桶式结构栈。
作用：在 方法执行的过程 中，会有 各种指令 往栈中 写入或者提取 信息。
fact：JVM的执行引擎 是 基于栈的执行引擎 - 这里的栈 指的就是 操作栈。
特征：
    1 字节码指令集的定义 都是 基于栈类型的。
    2 栈的深度 在 方法元信息 的stack属性 中。
用法：操作栈 与 局部变量表 的交互；
代码demo：simpleMethod
延伸：a=i++的字节码 vs. a=++i的字节码

---
Ⅲ 动态连接(Link)

特征：每个栈帧中 都包含有一个 在”运行时常量池“中 对当前方法的引用；
作用：支持 方法调用过程中的 动态绑定操作（多态）。
原理：
    在字节码层面，方法调用 通常通过 符号引用 来 表示；
    动态链接的作用：在运行时，把 符号引用 转化成为 可以直接指向 方法内存地址 的直接引用。

---
Ⅳ 方法返回地址(Address)

方法执行时，有两种 退出情况：
第一：正常退出。
    当方法 执行到 返回字节码指令 时，比如 RETURN, IRETURN,ARETURN;
第二：异常退出。

两种情况下，方法 都会返回到 方法被调用的位置。

方法退出的过程，等价于 弹出当前栈帧。
退出的三种方式：
    1 返回值 压入 上层调用栈帧；
    2 异常信息 抛出给 能够处理的栈帧；
    3 PC计数器 指向 方法调用后的 下一条指令。

======
wrap up:
1 方法调用 -> 形成栈帧 -> 方法帧 被压进 JVM虚拟机栈。
2 JVM虚拟机栈的栈顶帧 = 当前活动栈帧 -> {局部变量表L + 操作栈S + 动态连接L + 方法返回地址R} （4个独立的区域 LSLR）