1. Heap堆区域
作用：存储 几乎所有的 实例对象。
特征：
    1 堆空间 由 垃圾回收器 自动回收；
    2 堆空间 由 各个子线程 所共享；
    3 堆空间 是 所有内存区域中 最大的一块。
    4 堆空间的大小 可以是 固定的，也可以是 动态变化的
        手段： JVM运行时参数 -Xms（最小堆容量） -Xmx（最大堆容量）
        实践：在 线上生产环境 中，把 Xms与Xmx 设置成一样大小，避免 GC后 调整堆大小 所带来的压力。
    5 堆空间 分成 两个大的部分：新生代 + 老年代。
    6 在 不同的JVM实现 中，堆内存的划分方式 是 不一样的。

堆空间的工作方式：
    1 对象 最开始创建 的时候，会被存放在 新生代；
    2 新生代 = 一个 Eden区 + 两个 Survivor区域。
        用法：对象一般在 Eden区域生成， 当 Eden区域 快被填满 时，会触发 Young Garbage Collection(YGC);
    垃圾回收策略：
        1 Eden区域中 没有被引用的对象 会被直接回收。
        2 新生代中 依然存活的对象 会被移送到 Survivor区域中。 - 具体送到 哪块区域中呢？
    作用：能够 解决 内存碎片化的问题。
    Survivor区域：分为 S0 + S1 两个内存空间。
    手段：从逻辑上分类 两块空间的职责 - From区（用于存储存活对象）；To区（用作空闲区域）
    用法：
        1 每次 YGC的时候，
            ① 将 Eden中当前存活的对象 复制到 To空间(S0或者S1)；
            ② 把 From空间 中的适龄对象，也复制到 To空间中；
            ③ 把 From空间 中的老龄对象，移动到 老年代；
        2 然后 把 From空间 以及 Eden区 完全清除；
        3 再 交换 两块空间的使用职责；
    特征：
        如果 YGC 需要移送的对象 非常大，大于 Survivor区域的上限，则：直接 移交给 老年代；

    会不会出现一些对象 在 Survivor区域的 S0与S1之间 交换来 交换去呢？
    手段：
        1 每个对象 都会有一个 计数器，每次 YGC的时候 都会+1.
        2 使用-XX:MaxTenuringThreshold 参数 能够配置 当 计数器到达某个阈值 时，对象会 从 新生代 晋升到 老年代。
            aka 如果 这个参数 被配置为1，那么 对象会被 从 新生代的Eden区 直接移动到 老年代。
            默认值是15，也就是说，默认 在 Survivor区域中 交换14次 之后，会 晋升到 老年代。

    如果 Survivor区域中 放不下 该对象，则：尝试 在老年代中 分配空间。
    如果 老年代 也放不下，则： 触发 Full Garbage Collection (FGC);
    如果 还是放不下 这个对象，则：抛出 OOM。

fact：堆中 出现OOM的概率 是 内存耗尽异常 中最高的。
为了 使JVM 遇到OOM异常时 能够输出 堆内信息，可以设置 -XX:+HeapDumpOnOutOfMemoryError 这个JVM运行参数。

------
wrap up:
堆内存：
    1 空间划分：新生代(Eden + Survivor区(S0 + S1)) + 老年代；
    2 工作方式：
        ① 新建对象 最初在Eden区;
        ② 发生YGC时，Eden区中的存活对象 会被转移到 S0/S1;
        ③ 存活对象 在S0与S1之间 转移一定次数后,就会 被转移到 老年代；
    3 基础用法：
        为了避免 堆内存空间 反复扩容的资源消耗，生产环境中，一般会把 Xms参数(最小堆容量) 与 Xmx(最大堆容量) 设置成一样的大小
