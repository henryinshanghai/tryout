1. Heap堆区域
作用：存储几乎所有的实例对象。
特征：
    1 堆空间由垃圾回收器自动回收；
    2 堆空间 由各个子线程所共享；
    3 堆空间 是所有内存区域中最大的一块。
    4 堆空间的大小可以是固定的，也可以是动态变化的
        手段： JVM运行时参数 -Xms（最小堆容量） -Xmx（最大堆容量）
        实践：在线上生产环境中，吧 Xms与Xmx设置成一样大小，避免 GC后调整堆大小所带来的压力。
    5 堆空间 分成两个大的部分：新生代 + 老年代。
    6 在不同的JVM实现中，堆内存的划分方式是不一样的。

堆空间的工作方式：
    1 对象最开始创建的时候，被存放在 新生代；
    2 新生代 = 一个 Eden区 + 两个 Survivor区域。
        用法：对象一般在 Eden区域生成， 当 Eden区域快被填满时，会触发 Young Garbage Collection(YGC);
    垃圾回收策略：
        1 Eden区域中没有 被引用的对象 会被直接回收。
        2 新生代中依然存活的对象 会被移送到 Survivor区域中。 - 具体送到哪块区域中呢？
    Survivor区域：分为 S0 + S1两个内存空间。
    用法：
        1 每次 YGC的时候，将Eden中存活的对象 复制到 未使用的那块空间(S0或者S1)；
        2 然后把 当前正在使用的空间(在S0或者S1中) 完全清除；
        3 再交换两块空间的使用状态。
    特征：
        如果 YGC需要移送的对象非常大，大于 Survivor区域的上限，则：直接移交给 老年代；

    会不会出现一些对象 在 Survivor区域的 S0与S1之间交换来交换去呢？
    手段：
        1 每个对象都会有一个 计数器，每次 YGC的时候都会+1.
        2 使用-XX:MaxTenuringThreshold 参数 能够配置 当计数器到达某个阈值时，对象会从新生代晋升到老年代。
        aka 如果 这个参数被配置为1，那么 对象会被从新生代的Eden区 直接移动到 老年代。
        默认值是15 - 在Survivor区域中交换14次之后，会再晋升到老年代。

    如果 Survivor区域中放不下对象，则：尝试在老年代中分配空间。
    如果老年代也放不下，则： 触发 Full Garbage Collection (FGC);
    如果还是放不下这个对象，则：抛出 OOM。

fact： 堆中出现OOM的概率 是 内存耗尽异常中最高的。
为了使JVM遇到OOM异常时能够输出 堆内信息，可以设置 -XX:+HeapDumpOnOutOfMemoryError这个JVM运行参数。