最基础的 垃圾回收算法 - 标记-清除算法。

算法步骤：
    1 从每个 GC Root触发，依次标记 有引用关系的对象；
    2 把 没有被标记到的对象 清除。
缺点：会产生大量的内存空间碎片，进而导致 再需要分配比较大的空间时，经常会引发 FGC。

算法2：标记 - 整理算法；
步骤：
    1 从 GC Roots出发来标记 存活的对象；
    2 把存活的对象 整理到 内存空间的一侧/一端，以形成连续的已使用空间；
    3 把已使用空间之外的其他部分 清空掉。
特征：不会产生 内存空间碎片的问题。

算法3：Mark - copy算法；
特征：
    1 能够并行地标记与整理对象；
    2 有效地减少了 内存空间的浪费。
原理：
    把空间分成两块，每次都只激活其中的某一块。
步骤：
    1 把存活的对象 复制到 未激活的空间上；
    2 把未激活的空间 标识为 已激活，把已激活的空间 标识为未激活；
    3 清除原始空间中的原对象。
用法：
    堆内存空间分为 Eden（较大） + Survivor（较小，分成两块），每次都只会使用其中的一块???
应用：
    Mark-Copy是 现在主流的YGC算法（Young Garbage Collection 新生代的垃圾收集）.

======
垃圾回收算法的具体实现 - Garbage Collector

具体的3种 - Serial、CMS、G1

Serial回收器：
    特征：
        1 主要用于 YGC；
        2 采用串行单线程的方式 完成GC任务；
        3 GC过程种的STW阶段(Stop The World)会 暂停整个应用程序的执行。
    评价：FGC的时间比较长，可能会影响到程序性能。

CMS回收器（Concurrent Mark Sweep Collector）：
    特征：
        1 回收停顿时间比较短；
        2 比较常用的GC回收器；
        3 实现的是 标记-清除算法，所以会产生大量的内存空间碎片。
    步骤：
        1 初始标记； // 会引发 STW
        2 并发标记；
        3 重新标记； // 会引发 STW
        4 并发清除；
    用法：
        配置 -XX:+UseCMSCompactAtFullCollection参数，以此 强制 JVM在FGC完成之后：
            - 1 对老年代进行压缩；
            - 2 执行空间碎片的整理 - 这个过程会引发 STW。

G1回收器：
    set for another day.


