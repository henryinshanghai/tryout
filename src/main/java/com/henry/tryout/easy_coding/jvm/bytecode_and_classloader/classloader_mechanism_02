类加载器时怎么定位到具体的类文件并读取呢？

类加载器的层级
最高一层：Bootstrap类加载器
作用：是最根基的类加载器，负责加载 最核心的Java类型，比如 Object，System，String等
特征：
    1 它是在在JVM启动时创建的；
    2 一般是由 与操作系统相关的本地代码实现的；

第二层：平台类加载器
作用：用来加载一些扩展的系统类（比如 xml, 加密,压缩相关的功能类）。
特征：
    1 由Java语言实现；

第三层：应用类加载器
作用：用来加载 CLASSPATH下用户自定义的类型。
特征：
    1 由Java语言来实现；

查看本地类加载器；
手段：class对象.getClassLoader()

wrap up: 类加载器由等级制度，但却并不是继承关系。而是用组合的方式 来 复用父加载器的功能。

不同层级的多个类加载器的工作方式：
01 在 低层次类加载器 需要加载一个未知的类时，需要向上逐级询问：这个类又被您加载过吗？
02 当 高层次类加载 接到询问后，会自问两个问题：
    #1 我是不是已经加载过这个类了？
    #2 如果没有，我是不是有能力加载这个类？
03 在 所有高层次类加载器 对以上两个问题的答案都是 no时，当前 类加载器才能够 “加载这个类”。

一般情况下，JVM启动时加载的类会非常多。
因此 调试的时候很难捕捉到 某个指定类的加载过程，这时候 可以使用条件断点功能。

======
双亲委派模型并不是一个强制的规范，那什么时候会需要自定义类加载器呢？
#1 在某些框架中，进行 中间件与应用的模块隔离，从而把 类加载到不同的环境中。
    通过自定义的类加载器 确保 应用中依赖的jar包 不会影响到 中间件运行时使用的jar包。 - 这不是项目依赖的问题吗？为啥和类加载器有关系

#2 修改类加载的方式
    类的加载机制不是一种强制规范,aka, 除了 Bootstrap之外，其他的加载并不一定需要引入。
    可以根据实际情况在某个时间点 进行按需动态加载

#3 扩展 类加载的源头
    从数据库、网络 或者电视的机顶盒进行加载

#4 防止源码泄露
    Java代码容易被编译和篡改，可以进行 编译加密。此时就需要自定义类加载器，来还原加密的字节码。

实现自定义类加载器：
1 继承 ClassLoader；
2 重写 findClass()方法；
3 调用defineClass()方法；

demo: CustomClassLoader

中间件一般都会有自己所依赖的jar包，
当在同一个项目中引用多个框架的时候，很大可能需要被迫 进行类的仲裁。- 这是 jar包的冲突吗？
按照某种规则 jar包的版本被统一指定，这会导致 如果有些类的包路径、类名一样的时候，引起类的冲突。
所以 主流的容器类框架都会自定义类加载器，来实现不同中间件之间的类的隔离，从而避免了类的冲突。

