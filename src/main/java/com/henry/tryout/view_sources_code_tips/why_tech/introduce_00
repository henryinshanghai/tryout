调试目标：找到 Spring的@Transactional注解对于异常是否应该回滚的具体判断逻辑；

tip01 - 带着问题来调试源码；

== 方法论之 关注方法的调用栈 ==
自己debug的过程就是一个不断打断点的过程；

tip02 - 调试业务代码时，需要顺着断点往下调试。而阅读框架代码时，则需要往回看。
Debugger-Frame: 用于展示 以当前断点位置为终点的程序调用链路。
特征：当点击调用栈的时候，程序的位置也会随之发生变化。

tip03 - 查看方法调用栈中的方法调用信息，根据包的名称 来 判断应该具体查看哪一个方法调用；
🐖 不要被源码牵着鼻子走，目标要清晰。

tip04 - 根据找到的方法调用位置，重新添加断点；

== 方法论之 死盯日志 ==
tip05 - 通过观察日志输出，是一个很好的寻找阅读源码突破口的方式。
🐖 Demo要保持单一，不要引入与排查问题无关的代码和依赖；
🐖 把日志级别修改成 debug - logging.level.root=debug

tip06 - 找到与调试目标相关的日志后，回到源码中，定位日志打印的位置；然后添加断点，继续调试
🐖 新的断点，会产生新的调用栈。然后就能从调用栈中找到更加相关的源码位置
手段1：先找到类，再找日志的具体位置；
手段2：全局搜索日志关键字；
手段3：配置日志，打印行号~

== 方法论之 查看方法被调用的地方 ==
tip07 - 如果usage找到了很多处，可以 {排除测试类、JavaDoc中的备注、自己项目中的usage}

tip08 - 关注timing（时机） 断点处什么时机会被用到？
如：项目启动时，进入了断点。但是发起调用时，执行却没有进入断点。

tip09 - 查看JavaDoc。

tip10 - 如果方法是接口中的抽象方法，其实可以直接在接口的方法上添加断点；

